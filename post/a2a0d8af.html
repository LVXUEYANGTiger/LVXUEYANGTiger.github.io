<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RocketMQ源码分析 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="消息队列,RocketMQ"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 环境搭建依赖工具JDK ：1.8+MavenIntelliJ IDEA  1.1 源码拉取从官方仓库 https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq clone 或者 download 源码。​ 源码目录结构：  broker: broker 模块（broke 启动进程）  client ：消息客户端，包含消息生产者、消息消费者相关类  common ：公共包  dev">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ源码分析">
<meta property="og:url" content="https://lvxueyangtiger.github.io/post/a2a0d8af.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="1. 环境搭建依赖工具JDK ：1.8+MavenIntelliJ IDEA  1.1 源码拉取从官方仓库 https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq clone 或者 download 源码。​ 源码目录结构：  broker: broker 模块（broke 启动进程）  client ：消息客户端，包含消息生产者、消息消费者相关类  common ：公共包  dev">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg">
<meta property="article:published_time" content="2021-08-06T23:47:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:40.208Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="消息队列">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://lvxueyangtiger.github.io/post/a2a0d8af"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-06T23:47:00.000Z" title="发表于 2021-08-07 07:47:00">2021-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:40.208Z" title="更新于 2022-11-27 17:16:40">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">RocketMQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h1><p>依赖工具<br>JDK ：1.8+<br>Maven<br>IntelliJ IDEA </p>
<h2 id="1-1-源码拉取"><a href="#1-1-源码拉取" class="headerlink" title="1.1 源码拉取"></a>1.1 源码拉取</h2><p>从官方仓库 <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a> clone 或者 download 源码。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737067.png" alt="image.png"><br>​</p>
<p><strong>源码目录结构：</strong></p>
<ul>
<li>broker: broker 模块（broke 启动进程） </li>
<li>client ：消息客户端，包含消息生产者、消息消费者相关类 </li>
<li>common ：公共包 </li>
<li>dev ：开发者信息（非源代码） </li>
<li>distribution ：部署实例文件夹（非源代码） </li>
<li>example: RocketMQ 例代码 </li>
<li>filter ：消息过滤相关基础类 </li>
<li>filtersrv：消息过滤服务器实现相关类（Filter启动进程） </li>
<li>logappender：日志实现相关类 </li>
<li>namesrv：NameServer实现相关类（NameServer启动进程） </li>
<li>openmessageing：消息开放标准 </li>
<li>remoting：远程通信模块，基于Netty </li>
<li>srcutil：服务工具类 </li>
<li>store：消息存储实现相关类 </li>
<li>style：checkstyle相关实现 </li>
<li>test：测试相关类 </li>
<li>tools：工具类，监控命令相关实现类</li>
</ul>
<h2 id="1-2-导入IDEA"><a href="#1-2-导入IDEA" class="headerlink" title="1.2 导入IDEA"></a>1.2 导入IDEA</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737265.png" alt="image.png">​<br>**执行安装 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clean install -Dmaven.test.skip=<span class="keyword">true</span> </span><br></pre></td></tr></table></figure>
<h2 id="1-3-调试"><a href="#1-3-调试" class="headerlink" title="1.3 调试"></a>1.3 调试</h2><p>创建 conf 配置文件夹,从 distribution 拷贝 broker.conf 和 logback_broker.xml 和 logback_namesrv.xml<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737111.png" alt="image.png"><br>​</p>
<h2 id="1-4-启动NameServer"><a href="#1-4-启动NameServer" class="headerlink" title="1.4 启动NameServer"></a>1.4 启动NameServer</h2><p>配置NameServer的启动环境：<br>NameServer启动的类就是这里的 NamesrvStartup 。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737531.png" alt="image.png"><br>添加NameServer的启动环境：<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737710.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737487.png" alt="image.png"><br>启动NameServer：<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737712.png" alt="image.png"><br>控制台打印结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>
<h2 id="1-5启动Broker"><a href="#1-5启动Broker" class="headerlink" title="1.5启动Broker"></a>1.5启动Broker</h2><p>在项目根目录下创建数据文件夹 dataDir<br>从<strong>rocketmq-distribution</strong>模块的conf目录拷贝三个文件：<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041737054.png" alt="image.png"><br>broker.conf文件内容修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = <span class="number">0</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"># namesrvAddr地址</span><br><span class="line">namesrvAddr=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9876</span></span><br><span class="line"></span><br><span class="line"># 启用自动创建主题</span><br><span class="line">autoCreateTopicEnable=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 存储路径</span><br><span class="line">storePathRootDir=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir</span><br><span class="line"></span><br><span class="line"># commitLog路径</span><br><span class="line">storePathCommitLog=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir\\commitlog</span><br><span class="line"># 消息队列存储路径</span><br><span class="line">storePathConsumeQueue=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir\\consumequeue</span><br><span class="line"># 消息索引存储路径</span><br><span class="line">storePathIndex=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir\\index</span><br><span class="line"># checkpoint文件路径</span><br><span class="line">storeCheckpoint=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir\\checkpoint</span><br><span class="line"># abort文件存储路径</span><br><span class="line">abortFile=E:\\workspace\\source-code\\rocketmq-rocketmq-all-<span class="number">4.5</span><span class="number">.1</span>\\dataDir\\abort</span><br></pre></td></tr></table></figure>
<p>启动 BrokerStartup ,配置 broker.conf 和 ROCKETMQ_HOME<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041738096.png" alt="image.png"><br>现在下图中已经存在NameServer或Broker的启动环境了，如果没有，可以点击左上角的”➕”，选择创建Application环境，在Name一栏修改名字。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041738889.png" alt="image.png"></p>
<h2 id="1-6发送消息"><a href="#1-6发送消息" class="headerlink" title="1.6发送消息"></a>1.6发送消息</h2><p>进入example模块的 org.apache.rocketmq.example.quickstart<br>指定Namesrv地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>); <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>运行 main 方法，发送消息</p>
<h2 id="1-7消费消息"><a href="#1-7消费消息" class="headerlink" title="1.7消费消息"></a>1.7消费消息</h2><p>进入example模块的 org.apache.rocketmq.example.quickstart<br>指定Namesrv地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_4&quot;</span>); </span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行 main 方法，消费消息 </p>
<h1 id="2-NameServer"><a href="#2-NameServer" class="headerlink" title="2. NameServer"></a>2. NameServer</h1><h2 id="2-1-架构设计"><a href="#2-1-架构设计" class="headerlink" title="2.1 架构设计"></a>2.1 架构设计</h2><p>消息中间件的设计思路一般是基于主题订阅发布的机制。<br>生产者（Producer）发送消息到消息服务器的某个主题，消息服务器负责将消息持久化存储。</p>
<p>消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送 到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。 为了避免消息服务器的单点故障，部署多台消息服务器共同承担消息的存储。 </p>
<p>生产者如何知道消息要发送到哪台消息服务器呢？<br>如果某一台消息服务器宕机了，生产者如何在不重启服务情况下感知呢？<br>NameServer就是为了解决以上问题设计的。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739411.png" alt="image.png"><br>Broker消息服务器在启动时向所有NameServer注册，生产者（Producer)在发送消息之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。 NameServer与每台Broker保持长连接，并间隔<strong>30S</strong>检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。<br>但是路由变化不会马上通知生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。<br>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这 也是NameServer设计的一个<strong>亮点</strong>，总之，RocketMQ设计追求简单高效。</p>
<h2 id="2-2-启动流程"><a href="#2-2-启动流程" class="headerlink" title="2.2 启动流程"></a>2.2 启动流程</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739542.png" alt="image.png"><br>启动类： org.apache.rocketmq.namesrv.NamesrvStartup<br>*<em>​</em></p>
<p><strong>步骤一 **<br>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController<br>代码：</strong><em>NamesrvController#createNamesrvController</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException </span>&#123;</span><br><span class="line">       <span class="comment">//rocketmq.remoting.version  4.5.1 指定当前版本  生产者和消费者客户端都需要与服务端版本一致</span></span><br><span class="line">       System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">       <span class="comment">//PackageConflictDetect.detectFastjson();</span></span><br><span class="line"></span><br><span class="line">       Options options = ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> Options());</span><br><span class="line">       commandLine = ServerUtil.parseCmdLine(<span class="string">&quot;mqnamesrv&quot;</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> PosixParser());</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == commandLine) &#123;</span><br><span class="line">           System.exit(-<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建NamesrvConfig 与NameServer相关的配置参数对象</span></span><br><span class="line">       <span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line">       <span class="comment">//与netty相关的配置参数封装对象</span></span><br><span class="line">       <span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line">       <span class="comment">//指定Netty服务器监听的端口为9876</span></span><br><span class="line">       nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line">       <span class="comment">//如果命令行参数中有c 则表示指定了nameserver的配置文件</span></span><br><span class="line">       <span class="comment">//需要解析加载其中的配置项</span></span><br><span class="line">       <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">           <span class="comment">//文件路径  类似于 mqnamesrv -c /opt/rocketmq/conf/namesrv.conf</span></span><br><span class="line">           String file = commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">           <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">               InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">               properties = <span class="keyword">new</span> Properties();</span><br><span class="line">               <span class="comment">//将配置文件的配置信息封装到properties中</span></span><br><span class="line">               properties.load(in);</span><br><span class="line">               <span class="comment">//将properties对象中包含的nameserver有关的配置封装到NamesrvConfig</span></span><br><span class="line">               MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">               MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">               namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">               System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">               in.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// -p 表示打印配置信息</span></span><br><span class="line">       <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;p&#x27;</span>)) &#123;</span><br><span class="line">           InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">           MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">           MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">           System.exit(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将命令行中的参数封装到namesrvConfig中</span></span><br><span class="line">       MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line">       <span class="comment">//如果找不到ROCKETMQ_HOME环境变量。则退出</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == namesrvConfig.getRocketmqHome()) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;</span>, MixAll.ROCKETMQ_HOME_ENV);</span><br><span class="line">           System.exit(-<span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">       JoranConfigurator configurator = <span class="keyword">new</span> JoranConfigurator();</span><br><span class="line">       configurator.setContext(lc);</span><br><span class="line">       lc.reset();</span><br><span class="line">       configurator.doConfigure(namesrvConfig.getRocketmqHome() + <span class="string">&quot;/conf/logback_namesrv.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">       log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">       MixAll.printObjectProperties(log, namesrvConfig);</span><br><span class="line">       MixAll.printObjectProperties(log, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// remember all configs to prevent discard 缓存所有的配置信息到properties  防止controller对象销毁 配置信息没有了</span></span><br><span class="line">       controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> controller;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>NamesrvConfig属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</span><br><span class="line"><span class="keyword">private</span> String kvConfigPath = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;namesrv&quot;</span> + File.separator + <span class="string">&quot;kvConfig.json&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> String configStorePath = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;namesrv&quot;</span> + File.separator + <span class="string">&quot;namesrv.properties&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> String productEnvName = <span class="string">&quot;center&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterTest = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> orderMessageEnable = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>rocketmqHome：</strong>rocketmq主目录<br><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径<br><strong>configStorePath：</strong>nameServer默认配置文件路径<br><strong>orderMessageEnable：</strong>是否支持顺序消息 </p>
<p><strong>NettyServerConfig属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serverPooledByteBufAllocatorEnable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make make install</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ../glibc-2.10.1/configure \ --prefix=/usr \ --with-headers=/usr/include \</span></span><br><span class="line"><span class="comment"> * --host=x86_64-linux-gnu \ --build=x86_64-pc-linux-gnu \ --without-gd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useEpollNativeSelector = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br>**serverWorkerThreads： **Netty业务线程池线程个数<br> <strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数， Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。 <strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br> <strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br> <strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br>**serverSocketRcvBufSize： **网络接收端缓存区大小。<br> **serverPooledByteBufAllocatorEnable： **ByteBuffer是否开启缓存;<br> <strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p>
<p><strong>步骤二 **<br>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为 NameServer核心控制器<br>代码：</strong><em>NamesrvController#initialize</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//加载配置参数</span></span><br><span class="line">       <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line">       <span class="comment">//创建固定线程池 用于处理用户请求</span></span><br><span class="line">       <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">           Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//扫描不活跃的broker,从元数据删除</span></span><br><span class="line">               NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//每10秒执行一次</span></span><br><span class="line">       &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//每10秒打印所有的k-v配置信息</span></span><br><span class="line">               NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>步骤三 **<br>在JVM进程关闭之前，先将线程池关闭，及时释放资源<br>代码：</strong><em>NamesrvStartup#start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title">start</span><span class="params">(<span class="keyword">final</span> NamesrvController controller)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == controller) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;NamesrvController is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先初始化controller</span></span><br><span class="line">        <span class="keyword">boolean</span> initResult = controller.initialize();</span><br><span class="line">        <span class="keyword">if</span> (!initResult) &#123;</span><br><span class="line"></span><br><span class="line">            controller.shutdown();</span><br><span class="line">            System.exit(-<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加关闭的钩子函数</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//释放资源 关闭nettyserver  线程池等。。</span></span><br><span class="line">                controller.shutdown();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">//启动controller</span></span><br><span class="line">        controller.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-路由管理"><a href="#2-3-路由管理" class="headerlink" title="2.3 路由管理"></a>2.3 路由管理</h2><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。 </p>
<h3 id="2-3-1-路由元信息"><a href="#2-3-1-路由元信息" class="headerlink" title="2.3.1 路由元信息"></a>2.3.1 路由元信息</h3><p>代码：**<em>RouteInfoManager</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应于每个主题的mq列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">  <span class="comment">//对应每个broker的位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">  <span class="comment">//跟集群相关的地址列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739466.png" alt="image.png"><br><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡<br><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址<br><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称<br><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息<br><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RocketMQ基于订阅发布机制，一个Topic拥有多个消息队列，一个Broker为默认每一个主题创建<span class="number">4</span>个读队列和<span class="number">4</span>个写队列。多个Broker组成一个集群，</span><br><span class="line">集群由相同的多台Broker组成Master-Slave架构，brokerId为<span class="number">0</span>代表Master，大于<span class="number">0</span>为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rocketmq中的读写队列</span><br><span class="line"></span><br><span class="line">在创建或更改topic时，需要配置writeQueueNums和readQueueNums数，这里的读写队列有什么作用？</span><br><span class="line"></span><br><span class="line">初识rocketmq的童鞋，很容易把读写队列和读写分离混淆在一起。其实在rocketmq里是完全不同的两个概念。读写分离，是用HA机制，将一个节点的数据同步到另外一个节点，</span><br><span class="line">主节点多用于写（也可读），从节点只用于读。往往一主多从，通过读写分离减轻系统压力。</span><br><span class="line"></span><br><span class="line">读写队列，则是在做路由信息时使用。在消息发送时，使用写队列个数返回路由信息，而消息消费时按照读队列个数返回路由信息。在物理文件层面，</span><br><span class="line">只有写队列才会创建文件。举个例子：写队列个数是8，设置的读队列个数是4.这个时候，会创建8个文件夹，代表0 1 2 3 4 5 6 7，但在消息消费时，</span><br><span class="line">路由信息只返回4，在具体拉取消息时，就只会消费0 1 2 3这4个队列中的消息，4 5 6 7中的信息压根就不会被消费。</span><br><span class="line">反过来，如果写队列个数是4，读队列个数是8，在生产消息时只会往0 1 2 3中生产消息，消费消息时则会从0 1 2 3 4 5 6 7所有的队列中消费，</span><br><span class="line">当然 4 5 6 7中压根就没有消息 ，假设消费group有两个消费者，事实上只有第一个消费者在真正的消费消息(0 1 2 3)，第二个消费者压根就消费不到消息。</span><br><span class="line"></span><br><span class="line">由此可见，只有readQueueNums&gt;=writeQueueNums,程序才能正常进行。最佳实践是readQueueNums=writeQueueNums。</span><br><span class="line">那rocketmq为什么要区分读写队列呢？直接强制readQueueNums=writeQueueNums，不就没有问题了吗？</span><br><span class="line"></span><br><span class="line">rocketmq设置读写队列数的目的在于方便队列的缩容和扩容。思考一个问题，一个topic在每个broker上创建了128个队列，现在需要将队列缩容到64个，</span><br><span class="line">怎么做才能100%不会丢失消息，并且无需重启应用程序？</span><br><span class="line"></span><br><span class="line">最佳实践：</span><br><span class="line">先缩容写队列128-&gt;64，写队列由0 1 2 ......127缩至 0 1 2 ........63。等到64 65 66......127中的消息全部消费完后，</span><br><span class="line">再缩容读队列128-&gt;64.(同时缩容写队列和读队列可能会导致部分消息未被消费)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739418.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739443.png" alt="image.png"></p>
<h3 id="2-3-2-路由注册"><a href="#2-3-2-路由注册" class="headerlink" title="2.3.2 路由注册"></a>2.3.2 路由注册</h3><p>1）发送心跳包<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041739306.png" alt="image.png"><br>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。<br>代码：**<em>BrokerController#start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//想NameSrv注册broker信息</span></span><br><span class="line"><span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;registerBrokerAll Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码：**<em>BrokerOuterAPI#registerBrokerAll</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;RegisterBrokerResult&gt; <span class="title">registerBrokerAll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> <span class="keyword">boolean</span> oneway,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> <span class="keyword">int</span> timeoutMills,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">final</span> <span class="keyword">boolean</span> compressed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> List&lt;RegisterBrokerResult&gt; registerBrokerResultList = Lists.newArrayList();</span><br><span class="line">       <span class="comment">//获得nameServer地址信息</span></span><br><span class="line">       List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line">       <span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//封装请求头</span></span><br><span class="line">           <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</span><br><span class="line">           requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">           requestHeader.setBrokerId(brokerId);</span><br><span class="line">           requestHeader.setBrokerName(brokerName);</span><br><span class="line">           requestHeader.setClusterName(clusterName);</span><br><span class="line">           requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">           <span class="comment">//消息是否压缩</span></span><br><span class="line">           requestHeader.setCompressed(compressed);</span><br><span class="line">           <span class="comment">//封装请求体</span></span><br><span class="line">           RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</span><br><span class="line">           requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">           requestBody.setFilterServerList(filterServerList);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</span><br><span class="line">           requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">           <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());</span><br><span class="line">           <span class="comment">//遍历所有nameserver列表</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">               <span class="comment">//使用线程池并行注册</span></span><br><span class="line">               brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">//分别向NameServer注册</span></span><br><span class="line">                           RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                           <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               registerBrokerResultList.add(result);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           log.info(<span class="string">&quot;register broker[&#123;&#125;]to name server &#123;&#125; OK&quot;</span>, brokerId, namesrvAddr);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           log.warn(<span class="string">&quot;registerBroker Exception, &#123;&#125;&quot;</span>, namesrvAddr, e);</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           countDownLatch.countDown();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> registerBrokerResultList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>BrokerOutAPI#registerBroker</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过nettyClient发送单向消息 进行注册  不用等待响应</span></span><br><span class="line">        <span class="keyword">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不是单向请求 则同步等待nameserver的响应</span></span><br><span class="line">RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span><br><span class="line"><span class="keyword">assert</span> response != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>2）处理心跳包<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041740324.png" alt="image.png"><br>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor 网路处理类解析请求类型，如果请求类型是为**<em>REGISTER_BROKER</em>**，则将请求转发到 RouteInfoManager#regiesterBroker<br>​</p>
<p>代码：**<em>DefaultRequestProcessor#processRequest</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是注册broker</span></span><br><span class="line">     <span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">         Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">         <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">             <span class="comment">//注册broker </span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>DefaultRequestProcessor#registerBroker</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">          requestHeader.getClusterName(),</span><br><span class="line">          requestHeader.getBrokerAddr(),</span><br><span class="line">          requestHeader.getBrokerName(),</span><br><span class="line">          requestHeader.getBrokerId(),</span><br><span class="line">          requestHeader.getHaServerAddr(),</span><br><span class="line">          topicConfigWrapper,</span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          ctx.channel()</span><br><span class="line">      );</span><br></pre></td></tr></table></figure>
<p>代码：**_RouteInfoManager#registerBroker _**<br>维护路由信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//都是hashmap 需要加锁</span></span><br><span class="line">          <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">          <span class="comment">//维护clusterAddrTable</span></span><br><span class="line">          Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">          <span class="comment">//第一次注册</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">              brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">              <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">          &#125;</span><br><span class="line">          brokerNames.add(brokerName);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//都是hashmap 需要加锁</span></span><br><span class="line">             <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">             <span class="comment">//维护clusterAddrTable</span></span><br><span class="line">             Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">             <span class="comment">//第一次注册</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                 brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                 <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">             &#125;</span><br><span class="line">             brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">//维护brokerAddrTable</span></span><br><span class="line">             BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">             <span class="comment">//第一次注册,则创建brokerData</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                 registerFirst = <span class="keyword">true</span>;</span><br><span class="line">                 brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">                 <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//非第一次注册,更新Broker</span></span><br><span class="line">             Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">             <span class="comment">//Switch slave to master: first remove &lt;1, IP:PORT&gt; in namesrv, then add &lt;0, IP:PORT&gt;</span></span><br><span class="line">             <span class="comment">//The same IP:PORT must only have one record in brokerAddrTable</span></span><br><span class="line">             Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line">             <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                 Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">                 <span class="comment">//新加的broker的与本地的同名broker的id不同</span></span><br><span class="line">                 <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">                     it.remove();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">             <span class="comment">//是否是第一次注册</span></span><br><span class="line">             registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br><span class="line">             <span class="comment">//维护topicQueueTable</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                 &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                     || registerFirst) &#123;</span><br><span class="line">                     ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                         topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                     <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                             <span class="comment">//更新broker和主题的配置关系</span></span><br><span class="line">                             <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>


<p>代码：**_RouteInfoManager#createAndUpdateQueueData _**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建queueData</span></span><br><span class="line">    QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">    queueData.setBrokerName(brokerName);</span><br><span class="line">    queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">    queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">    queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">    queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line">    <span class="comment">//获得topicQueueTable中队列集合</span></span><br><span class="line">    List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="comment">//主题没有注册过queue topicQueueTable为空,则直接添加queueData到队列集合</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</span><br><span class="line">        queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</span><br><span class="line">        queueDataList.add(queueData);</span><br><span class="line">        <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">        log.info(<span class="string">&quot;new topic registered, &#123;&#125; &#123;&#125;&quot;</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是新的队列</span></span><br><span class="line">        <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</span><br><span class="line">        Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            QueueData qd = it.next();</span><br><span class="line">            <span class="comment">////如果brokerName相同,代表不是新的队列 判断队列数据是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">                    addNewOne = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;&quot;</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">                        queueData);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是新的队列,则添加队列到queueDataList</span></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：**_RouteInfoManager#registerBroker _**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护brokerLiveTable</span></span><br><span class="line">              BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                  <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                      System.currentTimeMillis(),</span><br><span class="line">                      topicConfigWrapper.getDataVersion(),</span><br><span class="line">                      channel,</span><br><span class="line">                      haServerAddr));</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                  log.info(<span class="string">&quot;new broker registered, &#123;&#125; HAServer: &#123;&#125;&quot;</span>, brokerAddr, haServerAddr);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//维护filterServerList</span></span><br><span class="line">              <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                  String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                  <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                      <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                          result.setMasterAddr(masterAddr);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-路由删除"><a href="#2-3-3-路由删除" class="headerlink" title="2.3.3 路由删除"></a>2.3.3 路由删除</h3><p>Broker 每隔30s向 NameServer 发送一个心跳包，心跳包包含 BrokerId ， Broker 地址， Broker 名称， Broker 所属集群名称、 Broker 关联的 FilterServer 列表。但是如果 Broker 宕机， NameServer 无法收到心跳包，此时 NameServer 如何来剔除这些失效的 Broker 呢？ NameServer 会每隔10s扫描 brokerLiveTable 状态表，如果 BrokerLive 的<strong>lastUpdateTimestamp</strong>的时间戳距当前时间超过120s，则认为 Broker 失效，移除该 Broker ，关闭与 Broker 连接，同时更新topicQueueTable 、 brokerAddrTable 、 brokerLiveTable 、 filterServerTable 。 </p>
<p><strong>RocketMQ有两个触发点来删除路由信息：</strong> </p>
<ul>
<li>NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。 </li>
<li>Broker在正常关闭的情况下，会执行unregisterBroker指令 </li>
</ul>
<p>这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041740112.png" alt="image.png"></p>
<p>代码：**_NamesrvController#initialize _**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//扫描不活跃的broker,从元数据删除</span></span><br><span class="line">        NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每10秒执行一次</span></span><br><span class="line">&#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>代码：**<em>RouteInfoManager#scanNotActiveBroker</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得brokerLiveTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历brokerLiveTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            <span class="comment">//移除broker</span></span><br><span class="line">            it.remove();</span><br><span class="line">            log.warn(<span class="string">&quot;The broker channel expired, &#123;&#125; &#123;&#125;ms&quot;</span>, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class="line">            <span class="comment">//维护路由表</span></span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>RouteInfoManager#onChannelDestroy</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelDestroy</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">       String brokerAddrFound = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line">                   Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; itBrokerLiveTable =</span><br><span class="line">                       <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">                   <span class="keyword">while</span> (itBrokerLiveTable.hasNext()) &#123;</span><br><span class="line">                       Entry&lt;String, BrokerLiveInfo&gt; entry = itBrokerLiveTable.next();</span><br><span class="line">                       <span class="keyword">if</span> (entry.getValue().getChannel() == channel) &#123;</span><br><span class="line">                           brokerAddrFound = entry.getKey();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">this</span>.lock.readLock().unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;onChannelDestroy Exception&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddrFound) &#123;</span><br><span class="line">           brokerAddrFound = remoteAddr;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;the broker&#x27;s channel destroyed, &#123;&#125;, clean it&#x27;s data structure at once&quot;</span>, brokerAddrFound);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (brokerAddrFound != <span class="keyword">null</span> &amp;&amp; brokerAddrFound.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></span><br><span class="line">                   <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">                   <span class="keyword">this</span>.brokerLiveTable.remove(brokerAddrFound);</span><br><span class="line">                   <span class="keyword">this</span>.filterServerTable.remove(brokerAddrFound);</span><br><span class="line">                   <span class="comment">//维护brokerAddrTable</span></span><br><span class="line">                   String brokerNameFound = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">boolean</span> removeBrokerName = <span class="keyword">false</span>;</span><br><span class="line">                   Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =</span><br><span class="line">                       <span class="keyword">this</span>.brokerAddrTable.entrySet().iterator();</span><br><span class="line">                   <span class="comment">//遍历brokerAddrTable</span></span><br><span class="line">                   <span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="keyword">null</span> == brokerNameFound)) &#123;</span><br><span class="line">                       BrokerData brokerData = itBrokerAddrTable.next().getValue();</span><br><span class="line">                       <span class="comment">//遍历broker地址</span></span><br><span class="line">                       Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</span><br><span class="line">                       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                           Entry&lt;Long, String&gt; entry = it.next();</span><br><span class="line">                           Long brokerId = entry.getKey();</span><br><span class="line">                           String brokerAddr = entry.getValue();</span><br><span class="line">                           <span class="comment">//根据broker地址移除brokerAddr</span></span><br><span class="line">                           <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</span><br><span class="line">                               brokerNameFound = brokerData.getBrokerName();</span><br><span class="line">                               it.remove();</span><br><span class="line">                               log.info(<span class="string">&quot;remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">                                   brokerId, brokerAddr);</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></span><br><span class="line">                       <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">                           removeBrokerName = <span class="keyword">true</span>;</span><br><span class="line">                           itBrokerAddrTable.remove();</span><br><span class="line">                           log.info(<span class="string">&quot;remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">                               brokerData.getBrokerName());</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//维护clusterAddrTable</span></span><br><span class="line">                   <span class="keyword">if</span> (brokerNameFound != <span class="keyword">null</span> &amp;&amp; removeBrokerName) &#123;</span><br><span class="line">                       Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.clusterAddrTable.entrySet().iterator();</span><br><span class="line">                       <span class="comment">//遍历clusterAddrTable</span></span><br><span class="line">                       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                           Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">                           <span class="comment">//获得集群名称</span></span><br><span class="line">                           String clusterName = entry.getKey();</span><br><span class="line">                           <span class="comment">//获得集群中brokerName集合</span></span><br><span class="line">                           Set&lt;String&gt; brokerNames = entry.getValue();</span><br><span class="line">                           <span class="comment">//从brokerNames中移除brokerNameFound</span></span><br><span class="line">                           <span class="keyword">boolean</span> removed = brokerNames.remove(brokerNameFound);</span><br><span class="line">                           <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                               log.info(<span class="string">&quot;remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed&quot;</span>,</span><br><span class="line">                                   brokerNameFound, clusterName);</span><br><span class="line"></span><br><span class="line">                               <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</span><br><span class="line">                                   log.info(<span class="string">&quot;remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster&quot;</span>,</span><br><span class="line">                                       clusterName);</span><br><span class="line">                                   <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></span><br><span class="line">                                   it.remove();</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//维护topicQueueTable队列</span></span><br><span class="line">                   <span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">                       <span class="comment">//遍历topicQueueTable</span></span><br><span class="line">                       Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</span><br><span class="line">                           <span class="keyword">this</span>.topicQueueTable.entrySet().iterator();</span><br><span class="line">                       <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</span><br><span class="line">                           Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</span><br><span class="line">                           <span class="comment">//主题名称</span></span><br><span class="line">                           String topic = entry.getKey();</span><br><span class="line">                           <span class="comment">//队列集合</span></span><br><span class="line">                           List&lt;QueueData&gt; queueDataList = entry.getValue();</span><br><span class="line">                           <span class="comment">//遍历该主题队列</span></span><br><span class="line">                           Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</span><br><span class="line">                           <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</span><br><span class="line">                               <span class="comment">//从队列中移除为活跃broker信息</span></span><br><span class="line">                               QueueData queueData = itQueueData.next();</span><br><span class="line">                               <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</span><br><span class="line">                                   itQueueData.remove();</span><br><span class="line">                                   log.info(<span class="string">&quot;remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed&quot;</span>,</span><br><span class="line">                                       topic, queueData);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//如果该topic的队列为空,则移除该topic</span></span><br><span class="line">                           <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</span><br><span class="line">                               itTopicQueueTable.remove();</span><br><span class="line">                               log.info(<span class="string">&quot;remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed&quot;</span>,</span><br><span class="line">                                   topic);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//释放写锁</span></span><br><span class="line">                   <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;onChannelDestroy Exception&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-路由发现"><a href="#2-3-4-路由发现" class="headerlink" title="2.3.4 路由发现"></a>2.3.4 路由发现</h3><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端， 而是由客户端定时拉取主题最新的路由。<br>代码：**<em>DefaultRequestProcessor#getRouteInfoByTopic</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">        RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">            (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line">        <span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、</span></span><br><span class="line">        <span class="comment">// filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、 filterServer</span></span><br><span class="line">        TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line">        <span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取 关于顺序消息相关的配置填充路由信息</span></span><br><span class="line">        <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">                String orderTopicConf =</span><br><span class="line">                    <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                        requestHeader.getTopic());</span><br><span class="line">                topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">            response.setBody(content);</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码：org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager#pickupTopicRouteData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TopicRouteData <span class="title">pickupTopicRouteData</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">       TopicRouteData topicRouteData = <span class="keyword">new</span> TopicRouteData();</span><br><span class="line">       <span class="keyword">boolean</span> foundQueueData = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> foundBrokerData = <span class="keyword">false</span>;</span><br><span class="line">       Set&lt;String&gt; brokerNameSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       List&lt;BrokerData&gt; brokerDataList = <span class="keyword">new</span> LinkedList&lt;BrokerData&gt;();</span><br><span class="line">       topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">       HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">       topicRouteData.setFilterServerTable(filterServerMap);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line">               <span class="comment">//通过主题 获取所有的messagequeue</span></span><br><span class="line">               List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topic);</span><br><span class="line">               <span class="keyword">if</span> (queueDataList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                   foundQueueData = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">//遍历MessageQueue列表</span></span><br><span class="line">                   Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                   <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                       QueueData qd = it.next();</span><br><span class="line">                       <span class="comment">//拿到每个messagequeue对应的brokername</span></span><br><span class="line">                       brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                       BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                       <span class="keyword">if</span> (<span class="keyword">null</span> != brokerData) &#123;</span><br><span class="line">                           <span class="comment">//克隆一份brokerData</span></span><br><span class="line">                           BrokerData brokerDataClone = <span class="keyword">new</span> BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData</span><br><span class="line">                               .getBrokerAddrs().clone());</span><br><span class="line">                           brokerDataList.add(brokerDataClone);</span><br><span class="line">                           foundBrokerData = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="comment">//遍历获取broker地址</span></span><br><span class="line">                           <span class="keyword">for</span> (<span class="keyword">final</span> String brokerAddr : brokerDataClone.getBrokerAddrs().values()) &#123;</span><br><span class="line">                               List&lt;String&gt; filterServerList = <span class="keyword">this</span>.filterServerTable.get(brokerAddr);</span><br><span class="line">                               filterServerMap.put(brokerAddr, filterServerList);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.lock.readLock().unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;pickupTopicRouteData Exception&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.debug(<span class="string">&quot;pickupTopicRouteData &#123;&#125; &#123;&#125;&quot;</span>, topic, topicRouteData);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">           <span class="keyword">return</span> topicRouteData;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741241.png" alt="image.png"><br>​</p>
<h1 id="3-Producer"><a href="#3-Producer" class="headerlink" title="3. Producer"></a>3. Producer</h1><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12497888/1623912720329-8f5ce8c0-76a4-4460-897b-d9b59d9ccb0a.png#" alt="image.png"><br><strong>​</strong></p>
<h2 id="3-1-方法和属性"><a href="#3-1-方法和属性" class="headerlink" title="3.1 方法和属性"></a>3.1 方法和属性</h2><h3 id="3-1-1主要方法介绍"><a href="#3-1-1主要方法介绍" class="headerlink" title="3.1.1主要方法介绍"></a>3.1.1主要方法介绍</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741075.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MQAdmin</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key accesskey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newTopic topic name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueNum topic&#x27;s queue number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String newTopic, <span class="keyword">final</span> <span class="keyword">int</span> queueNum)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an topic</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key accesskey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newTopic topic name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueNum topic&#x27;s queue number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topicSysFlag topic system flag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(String key, String newTopic, <span class="keyword">int</span> queueNum, <span class="keyword">int</span> topicSysFlag)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间戳从队列中查找消息偏移量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mq Instance of MessageQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp from when in milliseconds.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">searchOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *查找消息队列中最大的偏移量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mq Instance of MessageQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the max offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">maxOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找消息队列中最小的偏移量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mq Instance of MessageQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the minimum offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">minOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the earliest stored message time</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mq Instance of MessageQueue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the time in microseconds</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">earliestMsgStoreTime</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据偏移量查找消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offsetMsgId message id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(<span class="keyword">final</span> String offsetMsgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException, MQClientException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据条件查找消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic message topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key message key index word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxNum max message number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin from when</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end to when</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Instance of QueryResult</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">QueryResult <span class="title">queryMessage</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum, <span class="keyword">final</span> <span class="keyword">long</span> begin,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">long</span> end)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The &#123;<span class="doctag">@code</span> MessageExt&#125; of given msgId</span></span><br><span class="line"><span class="comment">     * 根据消息ID和主题查找消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String topic,</span></span></span><br><span class="line"><span class="params"><span class="function">        String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741103.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741155.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741800.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041741517.png" alt="image.png"></p>
<h3 id="3-1-2-属性介绍"><a href="#3-1-2-属性介绍" class="headerlink" title="3.1.2 属性介绍"></a>3.1.2 属性介绍</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742641.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producerGroup：生产者所属组</span><br><span class="line">createTopicKey：默认Topic </span><br><span class="line">defaultTopicQueueNums：默认主题在每一个Broker队列数量 </span><br><span class="line">sendMsgTimeout：发送消息默认超时时间，默认3s </span><br><span class="line">compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认4k </span><br><span class="line">retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为<span class="number">2</span>，总共执行<span class="number">3</span>次 </span><br><span class="line">retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为<span class="number">2</span> </span><br><span class="line">retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为<span class="keyword">false</span> </span><br><span class="line">maxMessageSize：允许发送的最大消息长度，默认为4M</span><br></pre></td></tr></table></figure>
<h2 id="3-2-启动流程"><a href="#3-2-启动流程" class="headerlink" title="3.2 启动流程"></a>3.2 启动流程</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742990.png" alt="image.png"><br>代码：**<em>DefaultMQProducerImpl#start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//刚刚创建的</span></span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">//检测配置</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="comment">//将instanceName属性改为pid</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取MQ客户端实例</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">            <span class="comment">//注册生产者 保证生产者唯一 //注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The producer group[&quot;</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缓存主题的发布信息  &#123;“TBW102”=&gt; new TopicPublishInfo()&#125;</span></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">//  启动</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>**整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表 **<br>**ConcurrentMap&lt;String/* clientId */, MQClientInstance&gt; factoryTable = new ConcurrentHashMap&lt;String,MQClientInstance&gt;(); **<br>**同一个clientId只会创建一个MQClientInstance。 **<br><strong>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</strong></p>
<p>代码：**<em>MQClientManager#getAndCreateMQClientInstance</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建客户端ID</span></span><br><span class="line">        String clientId = clientConfig.buildMQClientId();</span><br><span class="line">        <span class="comment">//通过客户端id获取MQClientInstance对象</span></span><br><span class="line">        MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">        <span class="comment">//没有获取到 创建新的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance =</span><br><span class="line">                <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line">                    <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">            <span class="comment">//获取旧的MQClientInstance</span></span><br><span class="line">            MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">            <span class="comment">//保证当前客户端只有一个MQClientInstance对象</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = prev;</span><br><span class="line">                log.warn(<span class="string">&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码：**<em>org.apache.rocketmq.client.impl.factory.MQClientInstance#registerProducer</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerProducer</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> DefaultMQProducerImpl producer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == group || <span class="keyword">null</span> == producer) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果原来有对应于该生产组名称的生产组。则注册失败，否则注册成功</span></span><br><span class="line">      MQProducerInner prev = <span class="keyword">this</span>.producerTable.putIfAbsent(group, producer);</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;the producer group[&#123;&#125;] exist already.&quot;</span>, group);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>org.apache.rocketmq.client.impl.factory.MQClientInstance#start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">                <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                    <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                    <span class="comment">//获取NameServer地址，如果为空就获取 一般实例化的时候进行设置 如果没有 设置走此逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                        <span class="comment">//通过http访问指定服务器   从jmenv.tbsite.net获取nameserver地址</span></span><br><span class="line">                        <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Start request-response channel</span></span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                    <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                    <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                    <span class="comment">// Start pull service</span></span><br><span class="line">                    <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                    <span class="comment">// Start rebalance service</span></span><br><span class="line">                    <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                    <span class="comment">// Start push service</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;the client factory [&#123;&#125;] start OK&quot;</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">&quot;The Factory object[&quot;</span> + <span class="keyword">this</span>.getClientId() + <span class="string">&quot;] has been created before, and failed.&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-消息发送"><a href="#3-3-消息发送" class="headerlink" title="3.3 消息发送"></a>3.3 消息发送</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742282.png" alt="image.png"><br>​</p>
<p>代码：**<em>DefaultMQProducerImpl#send(Message msg)</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Send message in synchronous mode. This method returns only when the sending procedure totally completes.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">  *同步方式发送消息，只有当发送消息过程完全结束，该方法才会返回</span></span><br><span class="line"><span class="comment">  * &lt;strong&gt;Warn:&lt;/strong&gt; this method has internal retry-mechanism, that is, internal implementation will retry</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #retryTimesWhenSendFailed&#125; times before claiming failure. As a result, multiple messages may potentially</span></span><br><span class="line"><span class="comment">  * delivered to broker(s). It&#x27;s up to the application developers to resolve potential duplication issue.</span></span><br><span class="line"><span class="comment">  *该方法包含重试机制，如果发送失败，重试&#123;<span class="doctag">@link</span> #retryTimesWhenSendAsyncFailed&#125;次</span></span><br><span class="line"><span class="comment">  * broker中可能会有重复的消息，需要应用开发者处理该问题</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> msg Message to send.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> SendResult&#125; instance to inform senders details of the deliverable, say Message ID of the message,</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> SendStatus&#125; indicating broker storage/replication status, message queue sent to, etc.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> MQClientException 客户端异常</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException 网络层异常</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> MQBrokerException broker异常</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException 发送线程被打断异常</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">     Validators.checkMessage(msg, <span class="keyword">this</span>);</span><br><span class="line">     msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//指定要发送的消息  指定发送模式：单向oneway , sync, async</span></span><br><span class="line">       <span class="comment">//当前方法中，调用该方法发送消息，不需要回调</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-验证消息"><a href="#3-3-1-验证消息" class="headerlink" title="3.3.1 验证消息"></a>3.3.1 验证消息</h3><p>代码：**<em>Validators#checkMessage</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Validate message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// topic</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg.getBody()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body length is zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">            <span class="string">&quot;the message body size over max value, MAX: &quot;</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-查找路由"><a href="#3-3-2-查找路由" class="headerlink" title="3.3.2 查找路由"></a>3.3.2 查找路由</h3><p>代码：**<em>DefaultMQProducerImpl#tryToFindTopicPublishInfo</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过同步访问nameserver获取指定主题的路由信息 缓存到本地</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先从本地缓存中获取</span></span><br><span class="line">       TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">       <span class="comment">//如果本地缓存中没有</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">           <span class="comment">//在本地缓存中先占座，一会儿在填充</span></span><br><span class="line">           <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">           <span class="comment">//从NameServer获取路由信息</span></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">           <span class="comment">//查询路由信息</span></span><br><span class="line">           topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">           <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//从NameServer获取路由信息</span></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">           topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">           <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742528.png" alt="image.png"><br>代码：**<em>TopicPublishInfo</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否是顺序主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否包含主题路由信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//MQ集合 空的</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    <span class="comment">//存放各个线程应该发送消息到哪个MQ 每选择一次消息队列,该值+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();</span><br><span class="line">    <span class="comment">//关联Topic路由元信息</span></span><br><span class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>MQClientInstance#updateTopicRouteInfoFromNameServer</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TopicRouteData topicRouteData;</span><br><span class="line">                   <span class="comment">//使用默认主题从NameServer获取路由信息</span></span><br><span class="line">                   <span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// TBW102</span></span><br><span class="line">                       topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">                           <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                       <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">                               <span class="comment">//设置写队列个数和读队列个数</span></span><br><span class="line">                               <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">                               data.setReadQueueNums(queueNums);</span><br><span class="line">                               data.setWriteQueueNums(queueNums);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">////使用指定主题从NameServer获取路由信息</span></span><br><span class="line">                       topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>MQClientInstance#updateTopicRouteInfoFromNameServer</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断路由是否需要更改</span></span><br><span class="line">             <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line">                 <span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line">                 <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">                     changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     log.info(<span class="string">&quot;the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]&quot;</span>, topic, old, topicRouteData);</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>MQClientInstance#updateTopicRouteInfoFromNameServer</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                     TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// Update Pub info</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">                         publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">                         <span class="comment">//遍历生产者</span></span><br><span class="line">                         Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">                         <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                             Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">                             MQProducerInner impl = entry.getValue();</span><br><span class="line">                             <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 <span class="comment">//生产者不为空时,更新publishInfo信息</span></span><br><span class="line">                                 impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>MQClientInstance#topicRouteData2TopicPublishInfo</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建TopicPublishInfo对象</span></span><br><span class="line">    TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">    <span class="comment">//关联topicRoute</span></span><br><span class="line">    info.setTopicRouteData(route);</span><br><span class="line">    <span class="comment">//顺序消息,更新TopicPublishInfo</span></span><br><span class="line">    <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String[] brokers = route.getOrderTopicConf().split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">            String[] item = broker.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                info.getMessageQueueList().add(mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//非顺序消息更新TopicPublishInfo</span></span><br><span class="line">        List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">        Collections.sort(qds);</span><br><span class="line">        <span class="comment">//遍历topic队列信息</span></span><br><span class="line">        <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">            <span class="comment">//是否是写队列</span></span><br><span class="line">            <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//遍历写队列Broker</span></span><br><span class="line">                <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                    <span class="comment">//根据名称获得读队列对应的Broker</span></span><br><span class="line">                    <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                        brokerData = bd;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//封装TopicPublishInfo写队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回TopicPublishInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-选择队列"><a href="#3-3-3-选择队列" class="headerlink" title="3.3.3 选择队列"></a>3.3.3 选择队列</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041746726.png" alt="image.png"><br>​</p>
<ul>
<li>默认不启用Broker故障延迟机制 </li>
</ul>
<p>代码：**<em>TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次选择队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//轮询</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">        <span class="comment">//遍历消息队列集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//sendWhichQueue自增后取模</span></span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="comment">//规避上次Broker队列</span></span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>TopicPublishInfo#selectOneMessageQueue()</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次选择队列</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//sendWhichQueue自增</span></span><br><span class="line">     <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">     <span class="comment">//对队列大小取模</span></span><br><span class="line">     <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">     <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">         pos = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//返回对应的队列</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启用Broker故障延迟机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果重试启动了延迟发送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取本次应该向哪个MQ发送消息，getAndIncrement表示每次该数字+1</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="comment">//index对写mq个数取模</span></span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//验证队列是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">//可用</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//获得Broker的写队列集合</span></span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041746223.png" alt="image.png"></p>
</li>
<li><p>延迟机制接口规范</p>
</li>
<li><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747381.png" alt="image.png"></p>
</li>
<li><p>FaultItem：失败条目 </p>
</li>
</ul>
<p>如果向一个brokerName的broker发送消息失败，等待多长时间重试该broker<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747057.png" alt="image.png"><br>消息失败策略<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747434.png" alt="image.png"><br>原理分析<br>代码：**<em>DefaultMQProducerImpl#sendDefaultImpl</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747282.png" alt="image.png"><br>如果上述发送过程出现异常，则调用 DefaultMQProducerImpl#updateFaultItem<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747701.png" alt="image.png"><br>代码：**<em>MQFaultStrategy#updateFaultItem</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747895.png" alt="image.png"><br>代码：**<em>MQFaultStrategy#computeNotAvailableDuration</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747529.png" alt="image.png"><br>代码：**<em>LatencyFaultToleranceImpl#updateFaultItem</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747506.png" alt="image.png"></p>
<h3 id="3-3-4-发送消息"><a href="#3-3-4-发送消息" class="headerlink" title="3.3.4 发送消息"></a>3.3.4 发送消息</h3><p>消息发送API核心入口**<em>DefaultMQProducerImpl#sendKernelImpl</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747907.png" alt="image.png"><br>代码：**<em>DefaultMQProducerImpl#sendKernelImpl</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747053.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041748664.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041748375.png" alt="image.png"><br>代码：**<em>SendMessageHook</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041748759.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041748648.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749127.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041747496.png" alt="image.png"><br>​</p>
<h2 id="3-4-批量消息发送"><a href="#3-4-批量消息发送" class="headerlink" title="3.4 批量消息发送"></a>3.4 批量消息发送</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749479.png" alt="image.png"><br>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。<br>批量消息发送要解决的问题是<strong>如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容</strong>。<br>代码：**<em>DefaultMQProducer#send</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749990.png" alt="image.png"><br>代码：**<em>DefaultMQProducer#batch</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749921.png" alt="image.png">​<br>​</p>
<p>encode()=&gt; org.apache.rocketmq.common.message.MessageDecoder#encodeMessage<br>批量消息统一编码成一个消息 bytep[]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encodeMessage(Message message) &#123;</span><br><span class="line">    <span class="comment">//only need flag, body, properties</span></span><br><span class="line">    <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">    <span class="keyword">int</span> bodyLen = body.length;</span><br><span class="line">    String properties = messageProperties2String(message.getProperties());</span><br><span class="line">    <span class="keyword">byte</span>[] propertiesBytes = properties.getBytes(CHARSET_UTF8);</span><br><span class="line">    <span class="comment">//note properties length must not more than Short.MAX</span></span><br><span class="line">    <span class="keyword">short</span> propertiesLength = (<span class="keyword">short</span>) propertiesBytes.length;</span><br><span class="line">    <span class="keyword">int</span> sysFlag = message.getFlag();</span><br><span class="line">    <span class="keyword">int</span> storeSize = <span class="number">4</span> <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">// 2 MAGICCOD</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">// 3 BODYCRC</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">// 4 FLAG</span></span><br><span class="line">        + <span class="number">4</span> + bodyLen <span class="comment">// 4 BODY</span></span><br><span class="line">        + <span class="number">2</span> + propertiesLength;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(storeSize);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    byteBuffer.putInt(storeSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    byteBuffer.putInt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 BODYCRC</span></span><br><span class="line">    byteBuffer.putInt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 FLAG</span></span><br><span class="line">    <span class="keyword">int</span> flag = message.getFlag();</span><br><span class="line">    byteBuffer.putInt(flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 BODY</span></span><br><span class="line">    byteBuffer.putInt(bodyLen);</span><br><span class="line">    byteBuffer.put(body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 properties</span></span><br><span class="line">    byteBuffer.putShort(propertiesLength);</span><br><span class="line">    byteBuffer.put(propertiesBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> byteBuffer.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-消息存储"><a href="#4-消息存储" class="headerlink" title="4. 消息存储"></a>4. 消息存储</h1><h2 id="4-1-消息存储核心类"><a href="#4-1-消息存储核心类" class="headerlink" title="4.1 消息存储核心类"></a>4.1 消息存储核心类</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749817.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749309.png" alt="image.png"></p>
<h2 id="4-2-消息存储流程"><a href="#4-2-消息存储流程" class="headerlink" title="4.2 消息存储流程"></a>4.2 消息存储流程</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041749017.png" alt="image.png"><br>pageCache为CommitLog映射的内存文件<br>​</p>
<p>消息存储入口：**<em>DefaultMessageStore#putMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750859.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750578.png" alt="image.png"><br>代码：**<em>CommitLog#putMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750273.png" alt="image.png"><br>​</p>
<p>代码：appendMessage=&gt; <strong><em>MappedFile#appendMessagesInner</em></strong><br><strong><em>直接写入内核空间中映射的MappedFile的内存区，由操作系统进行刷盘  零拷贝</em></strong><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750769.png" alt="image.png"><br>​</p>
<p>代码：**<em>CommitLog#doAppend</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750365.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041750812.png" alt="image.png"><br>​</p>
<p>代码：**<em>CommitLog#calMsgLength</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751366.png" alt="image.png"><br>代码：**<em>CommitLog#doAppend</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751642.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751107.png" alt="image.png"><br>代码：**<em>CommitLog#putMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751844.png" alt="image.png"><br>​</p>
<h2 id="4-3-存储文件"><a href="#4-3-存储文件" class="headerlink" title="4.3 存储文件"></a>4.3 存储文件</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758594.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758398.png" alt="image.png"></p>
<ul>
<li>commitLog：消息存储目录 </li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录 </li>
<li>index：消息索引文件存储目录 </li>
<li>abort：如果存在改文件寿命Broker非正常关闭 </li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。 </li>
</ul>
<h2 id="4-4-存储文件内存映射"><a href="#4-4-存储文件内存映射" class="headerlink" title="4.4 存储文件内存映射"></a>4.4 存储文件内存映射</h2><p>MMap<br>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是 IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p>
<h3 id="4-4-1-MappedFileQueue"><a href="#4-4-1-MappedFileQueue" class="headerlink" title="4.4.1 MappedFileQueue"></a>4.4.1 MappedFileQueue</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758388.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String storePath; <span class="comment">//存储目录</span></span><br><span class="line"><span class="keyword">int</span> mappedFileSize; <span class="comment">// 单个文件大小 </span></span><br><span class="line">CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles; <span class="comment">//MappedFile文件集合</span></span><br><span class="line">AllocateMappedFileService allocateMappedFileService; <span class="comment">//创建MapFile服务类 </span></span><br><span class="line"><span class="keyword">long</span> flushedWhere = <span class="number">0</span>; <span class="comment">//当前刷盘指针 将内存数据刷到硬盘</span></span><br><span class="line"><span class="keyword">long</span> committedWhere = <span class="number">0</span>; <span class="comment">//当前数据提交指针,内存中ByteBuffer当前的写指针 将数据提交到Mapfile映射的内存,该值大于等于flushWhere</span></span><br></pre></td></tr></table></figure>

<ul>
<li>根据存储时间查询MappedFile </li>
</ul>
<p>代码：**<em>MappedFileQueue#getMappedFileByTime</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758553.png" alt="image.png"></p>
<ul>
<li>根据消息偏移量offset查找MappedFile </li>
</ul>
<p>代码：**<em>MappedFileQueue#findMappedFileByOffset</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758674.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758236.png" alt="image.png"><br>​</p>
<ul>
<li>获取存储文件最小偏移量 </li>
</ul>
<p>代码：**<em>MappedFileQueue#getMinOffset</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758613.png" alt="image.png"><br>​</p>
<ul>
<li>获取存储文件最大偏移量</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759144.png" alt="image.png"></p>
<ul>
<li>返回存储文件当前写指针</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759591.png" alt="image.png"><br>​</p>
<h3 id="4-4-2-MappedFile"><a href="#4-4-2-MappedFile" class="headerlink" title="4.4.2 MappedFile"></a>4.4.2 MappedFile</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759883.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">//操作系统每页大小,默认4K </span></span><br><span class="line">AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); <span class="comment">//当前JVM实例中 MappedFile虚拟内存</span></span><br><span class="line">AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">//当前JVM实例中 MappedFile对象个数</span></span><br><span class="line">AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">//当前文件的写指针</span></span><br><span class="line">AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">//当前文件的提交指针</span></span><br><span class="line">AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">//刷写到磁盘指针</span></span><br><span class="line"><span class="keyword">int</span> fileSize; <span class="comment">//文件大小 </span></span><br><span class="line">FileChannel fileChannel; <span class="comment">//文件通道</span></span><br><span class="line">ByteBuffer writeBuffer = <span class="keyword">null</span>; <span class="comment">//堆外内存ByteBuffer </span></span><br><span class="line">TransientStorePool transientStorePool = <span class="keyword">null</span>; <span class="comment">//堆外内存池</span></span><br><span class="line">String fileName; <span class="comment">//文件名称 </span></span><br><span class="line"><span class="keyword">long</span> fileFromOffset; <span class="comment">//该文件的处理偏移量 </span></span><br><span class="line">File file; <span class="comment">//物理文件</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer; <span class="comment">//物理文件对应的内存映射Buffer </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>; <span class="comment">//文件最后一次内容写入时间</span></span><br><span class="line"><span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>; <span class="comment">//是否是MappedFileQueue队列中第一个文件</span></span><br></pre></td></tr></table></figure>
<p><strong><em>​</em></strong></p>
<ul>
<li>**<em>MappedFile</em>**初始化 </li>
</ul>
<p>未开启 transientStorePoolEnable 。 transientStorePoolEnable=true 为 true 表示数据先存储到堆外内存，然后通过 Commit 线程将数据提交到内存映射Buffer中，再通过 Flush线程将内存映射 Buffer 中数据持久化磁盘。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759325.png" alt="image.png"><br>开启 transientStorePoolEnable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize, <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    init(fileName, fileSize); </span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer(); <span class="comment">//初始化 //堆外内存</span></span><br><span class="line">    writeBuffer <span class="keyword">this</span>.transientStorePool = transientStorePool; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<em>MappedFile</em>**提交 </li>
</ul>
<p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满 commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759814.png" alt="image.png"><br>​</p>
<p><strong>_MappedFile#isAbleToCommit _</strong><br>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较 writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量， 如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759121.png" alt="image.png"><br>​</p>
<p><strong>_MappedFile#commit0 _</strong><br>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把 commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为 wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel 中。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041759463.png" alt="image.png"><br>​</p>
<p><strong>_MappedFile#flush _</strong><br>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则 flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer 中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是 MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800672.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800906.png" alt="image.png"><br>​</p>
<p><strong>_MappedFile#getReadPosition _</strong><br>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer 不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800018.png" alt="image.png"><br>​</p>
<p><strong><em>MappedFile#selectMappedBuffer</em></strong><br>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针， 如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置 ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit 为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作 SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800517.png" alt="image.png"><br>​</p>
<p><strong>_MappedFile#shutdown _</strong><br>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)， intervalForcibly表示拒绝被销毁的最大存活时间。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800650.png" alt="image.png"><br><strong>​</strong></p>
<h3 id="4-4-3-TransientStorePool"><a href="#4-4-3-TransientStorePool" class="headerlink" title="4.4.3 TransientStorePool"></a>4.4.3 TransientStorePool</h3><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池（堆外内存），用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800812.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize; <span class="comment">//availableBuffers个数 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fileSize; <span class="comment">//每隔ByteBuffer大小 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers; <span class="comment">//ByteBuffer容器。双端队列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//创建poolSize个堆外内存 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> address = ((DirectBuffer) byteBuffer).address(); </span><br><span class="line">        Pointer pointer = <span class="keyword">new</span> Pointer(address); </span><br><span class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能 </span></span><br><span class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> NativeLong(fileSize));</span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-实时更新消息消费队列与索引文件"><a href="#4-5-实时更新消息消费队列与索引文件" class="headerlink" title="4.5 实时更新消息消费队列与索引文件"></a>4.5 实时更新消息消费队列与索引文件</h2><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程<strong>ReputMessageService</strong>来<strong>准实时</strong>转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新<strong>ConsumerQueue</strong>、 <strong>IndexFile</strong>文件。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801054.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041800153.png" alt="image.png"><br>代码：**<em>DefaultMessageStore</em><strong>：</strong><em>start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动 </span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>
<p>代码：**<em>DefaultMessageStore</em><strong>：</strong><em>run</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>); </span><br><span class="line">    <span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">this</span>.doReput(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：**<em>DefaultMessageStore</em><strong>：</strong><em>doReput</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">    DispatchRequest dispatchRequest = DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.<span class="function">getByte <span class="title">Buffer</span><span class="params">()</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</span>;</span><br><span class="line">    <span class="keyword">int</span> size = dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize(); </span><br><span class="line">    <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123; </span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>DispatchRequest</em></strong><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041802008.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041802114.png" alt="image.png"><br>​</p>
<h3 id="4-5-1-转发到ConsumerQueue"><a href="#4-5-1-转发到ConsumerQueue" class="headerlink" title="4.5.1 转发到ConsumerQueue"></a>4.5.1 转发到ConsumerQueue</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801747.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801485.png" alt="image.png"><br>​</p>
<p>代码：**_DefaultMessageStore#putMessagePositionInfo _**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801397.png" alt="image.png"><br>代码：**<em>DefaultMessageStore#putMessagePositionInfo</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801847.png" alt="image.png"><br>​</p>
<h3 id="4-5-2-转发到Index"><a href="#4-5-2-转发到Index" class="headerlink" title="4.5.2 转发到Index"></a>4.5.2 转发到Index</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801655.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801509.png" alt="image.png"><br>代码：**<em>DefaultMessageStore#buildIndex</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801285.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801084.png" alt="image.png"><br>​</p>
<h2 id="4-6-消息队列和索引文件恢复"><a href="#4-6-消息队列和索引文件恢复" class="headerlink" title="4.6 消息队列和索引文件恢复"></a>4.6 消息队列和索引文件恢复</h2><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一 致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到 ConsumerQueue，这部分消息将永远无法被消费者消费。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801319.png" alt="image.png"><br>​</p>
<h3 id="4-6-1-存储文件加载"><a href="#4-6-1-存储文件加载" class="headerlink" title="4.6.1 存储文件加载"></a>4.6.1 存储文件加载</h3><p>代码：**_DefaultMessageStore#load _**<br>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函 数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与 ConsumerQueue数据有可能不一致，需要进行修复。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801649.png" alt="image.png"><br>代码：**<em>DefaultMessageStore#load</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041801875.png" alt="image.png"><br>​</p>
<p>代码：**_MappedFileQueue#load _**<br>加载CommitLog到映射文件<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758998.png" alt="image.png"></p>
<p>代码：**_DefaultMessageStore#loadConsumeQueue _**<br>加载消息消费队列<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041758454.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757329.png" alt="image.png"><br>代码：**_IndexService#load _**<br>加载索引文件<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757438.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757807.png" alt="image.png"></p>
<p>代码：**_DefaultMessageStore#recover _**<br>文件恢复，根据Broker是否正常退出执行不同的恢复策略<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757272.png" alt="image.png"></p>
<p>代码：**_DefaultMessageStore#recoverTopicQueueTable _**<br>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757106.png" alt="image.png"></p>
<h3 id="4-6-2-正常恢复"><a href="#4-6-2-正常恢复" class="headerlink" title="4.6.2 正常恢复"></a>4.6.2 正常恢复</h3><p>代码：**<em>CommitLog#recoverNormally</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757463.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757965.png" alt="image.png"></p>
<p>代码：**<em>MappedFileQueue#truncateDirtyFiles</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757120.png" alt="image.png"></p>
<h3 id="4-6-3-异常恢复"><a href="#4-6-3-异常恢复" class="headerlink" title="4.6.3 异常恢复"></a>4.6.3 异常恢复</h3><p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停 止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复， 而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog 目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。<br>代码：**<em>CommitLog#recoverAbnormally</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041757644.png" alt="image.png"></p>
<h2 id="4-7-刷盘机制"><a href="#4-7-刷盘机制" class="headerlink" title="4.7 刷盘机制"></a>4.7 刷盘机制</h2><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p>
<h3 id="4-7-1-同步刷盘"><a href="#4-7-1-同步刷盘" class="headerlink" title="4.7.1 同步刷盘"></a>4.7.1 同步刷盘</h3><p>消息追加到内存后，立即将数据刷写到磁盘文件<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756866.png" alt="image.png"><br>代码：**<em>CommitLog#handleDiskFlush</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756066.png" alt="image.png"><br>​</p>
<p><strong><em>GroupCommitRequest</em></strong><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756770.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> nextOffset; <span class="comment">//刷盘点偏移量 </span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">//倒计树锁存器 </span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>; <span class="comment">//刷盘结果;默认为false</span></span><br></pre></td></tr></table></figure>
<p>代码：**<em>GroupCommitService#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756729.png" alt="image.png"><br>​</p>
<p>代码：**<em>GroupCommitService#doCommit</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756855.png" alt="image.png"><br>**4.7.2 异步刷盘 **<br>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ 会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确 保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷 写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷 写到磁盘中.<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756704.png" alt="image.png"><br>开启transientStorePoolEnable后异步刷盘步骤: </p>
<ol>
<li>将消息直接追加到ByteBuffer（堆外内存） </li>
<li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到 MappedByteBuffer（就是映射的物理文件）中 </li>
<li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动 </li>
<li>commit操作成功返回，将committedPosition位置恢复 </li>
<li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘<br>​</li>
</ol>
<p>代码：**_CommitLog$CommitRealTimeService#run _**<br>提交线程工作机制<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756795.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756560.png" alt="image.png"><br>​</p>
<p>代码：**_CommitLog$FlushRealTimeService#run _**<br>刷盘线程工作机制<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756585.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756688.png" alt="image.png"><br>​</p>
<h2 id="4-8-过期文件删除机制"><a href="#4-8-过期文件删除机制" class="headerlink" title="4.8 过期文件删除机制"></a>4.8 过期文件删除机制</h2><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、 ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前 的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。<br>​</p>
<p>代码：**<em>DefaultMessageStore#addScheduleTask</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756506.png" alt="image.png"><br>​</p>
<p>代码：**<em>DefaultMessageStore#cleanFilesPeriodically</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756588.png" alt="image.png"><br>代码：**<em>DefaultMessageStore#deleteExpiredFiles</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041756015.png" alt="image.png"><br>删除文件操作的条件 </p>
<ol>
<li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认凌晨4点 </li>
<li>磁盘空间如果不充足，删除过期文件 </li>
<li>预留，手工触发。</li>
</ol>
<p>代码：**_CleanCommitLogService#isSpaceToDelete _**<br>当磁盘空间不足时执行删除过期文件<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041755493.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041755942.png" alt="image.png"></p>
<p>代码：**_MappedFileQueue#deleteExpiredFileByTime _**<br>执行文件销毁和删除<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041755326.png" alt="image.png"></p>
<h2 id="4-9-小结"><a href="#4-9-小结" class="headerlink" title="4.9 小结"></a>4.9 小结</h2><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、 Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。 RocketMQ组织文件以文件的起始偏移量来命名文件，这样根据偏移量能快速定位到真实的物理文件。 RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。 </p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。 </p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h1 id="5-Consumer"><a href="#5-Consumer" class="headerlink" title="5. Consumer"></a>5. Consumer</h1><h2 id="5-1-消息消费概述"><a href="#5-1-消息消费概述" class="headerlink" title="5.1 消息消费概述"></a>5.1 消息消费概述</h2><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题， 消费组内消费者之间有集群模式和广播模式两种消费模式。 </p>
<p>集群模式，主题下的同一条消息只允许被其中一个消费者消费。<br>广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。 </p>
<p>消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。<br>所谓的拉模式，是消费端主动拉起拉消息请求， 而推模式是消息达到消息服务器后，推送给消息消费者。<br>RocketMQ消息推模式的实现<strong>基于拉模式</strong>，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。 </p>
<p>集群模式下，多个消费者如何对消息队列进行负载呢？<br>消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。 </p>
<p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。<br><strong>不支持消息全局顺序消费</strong>，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为 1，牺牲高可用性。</p>
<h2 id="5-2-消息消费初探"><a href="#5-2-消息消费初探" class="headerlink" title="5.2 消息消费初探"></a>5.2 消息消费初探</h2><p><strong>消息推送模式</strong><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041755263.png" alt="image.png"><br><strong>消息消费重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认 </span></span><br><span class="line"><span class="function">Set&lt;MessageQueue&gt; <span class="title">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>： 注册顺序消息事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息， 并指定队列选择器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span></span><br></pre></td></tr></table></figure>
<p><strong>DefaultMQPushConsumer</strong><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041755709.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者组 </span></span><br><span class="line"><span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息消费模式 </span></span><br><span class="line"><span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING; </span><br><span class="line"></span><br><span class="line"><span class="comment">//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费</span></span><br><span class="line"><span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"><span class="comment">//集群模式下的消息队列负载策略</span></span><br><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy; </span><br><span class="line"><span class="comment">//订阅信息 </span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//消息业务监听器</span></span><br><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line"><span class="comment">//消息消费进度存储器 </span></span><br><span class="line"><span class="keyword">private</span> OffsetStore offsetStore; </span><br><span class="line"><span class="comment">//消费者最小线程数量 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//消费者最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//并发消息消费时处理队列最大跨度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//每1000次流控后打印流控日志 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//推模式下任务间隔时间 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//推模式下任务拉取的条数,默认32条</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>; </span><br><span class="line"><span class="comment">//每次传入MessageListener#consumerMessage中消息的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//是否每次拉取消息都订阅消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//消息重试次数,-1代表16次 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>; </span><br><span class="line"><span class="comment">//消息消费超时时间 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-消费者启动流程"><a href="#5-3-消费者启动流程" class="headerlink" title="5.3 消费者启动流程"></a>5.3 消费者启动流程</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754564.png" alt="image.png"><br>代码：**<em>DefaultMQPushConsumerImpl#start</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754238.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754882.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754637.png" alt="image.png"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754492.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754962.png" alt="image.png"><br>​</p>
<h2 id="5-4-消息拉取"><a href="#5-4-消息拉取" class="headerlink" title="5.4 消息拉取"></a>5.4 消息拉取</h2><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解<strong>集群模式</strong>。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。<br>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。    </p>
<h3 id="5-4-1-PullMessageService实现机制"><a href="#5-4-1-PullMessageService实现机制" class="headerlink" title="5.4.1 PullMessageService实现机制"></a>5.4.1 PullMessageService实现机制</h3><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754819.png" alt="image.png"><br>代码：**<em>PullMessageService#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754350.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754711.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup; <span class="comment">//消费者组 </span></span><br><span class="line"><span class="keyword">private</span> MessageQueue messageQueue; <span class="comment">//待拉取消息队列</span></span><br><span class="line"><span class="keyword">private</span> ProcessQueue processQueue; <span class="comment">//消息处理队列 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextOffset; <span class="comment">//待拉取的MessageQueue偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>; <span class="comment">//是否被锁定</span></span><br></pre></td></tr></table></figure>
<p>代码：**<em>PullMessageService#pullMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041754358.png" alt="image.png"></p>
<h3 id="5-4-2-ProcessQueue实现机制"><a href="#5-4-2-ProcessQueue实现机制" class="headerlink" title="5.4.2 ProcessQueue实现机制"></a>5.4.2 ProcessQueue实现机制</h3><p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753367.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753571.png" alt="image.png"><br>方法：<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753962.png" alt="image.png"><br>​</p>
<h3 id="5-4-3-消息拉取基本流程"><a href="#5-4-3-消息拉取基本流程" class="headerlink" title="5.4.3 消息拉取基本流程"></a>5.4.3 消息拉取基本流程</h3><h4 id="5-4-3-1-客户端发起拉取请求"><a href="#5-4-3-1-客户端发起拉取请求" class="headerlink" title="5.4.3.1 客户端发起拉取请求"></a>5.4.3.1 客户端发起拉取请求</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753072.png" alt="image.png"><br>代码：**<em>DefaultMQPushConsumerImpl#pullMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753019.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753357.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753609.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041753249.png" alt="image.png"></p>
<h4 id="5-4-3-2-消息服务端Broker组装消息"><a href="#5-4-3-2-消息服务端Broker组装消息" class="headerlink" title="5.4.3.2.消息服务端Broker组装消息"></a>5.4.3.2.消息服务端Broker组装消息</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752754.png" alt="image.png"><br>代码：**<em>PullMessageProcessor#processRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752432.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752265.png" alt="image.png"><br>​</p>
<p>代码：**<em>DefaultMessageStore#getMessage</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752580.png" alt="image.png"><br>​</p>
<p>代码：**<em>PullMessageProcessor#processRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752114.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752624.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752894.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752615.png" alt="image.png"><br>​</p>
<h4 id="5-4-3-3-消息拉取客户端处理消息"><a href="#5-4-3-3-消息拉取客户端处理消息" class="headerlink" title="5.4.3.3.消息拉取客户端处理消息"></a>5.4.3.3.消息拉取客户端处理消息</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752528.png" alt="image.png"><br>​</p>
<p>代码：**<em>MQClientAPIImpl#processPullResponse</em>**<br>​</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752483.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752529.png" alt="image.png"><br>​</p>
<p><strong>PullResult类 **<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041752210.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751794.png" alt="image.png"><br>代码：</strong><em>DefaultMQPushConsumerImpl$PullCallback#OnSuccess</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751663.png" alt="image.png"><br>​</p>
<h4 id="5-4-3-4-消息拉取总结"><a href="#5-4-3-4-消息拉取总结" class="headerlink" title="5.4.3.4.消息拉取总结"></a>5.4.3.4.消息拉取总结</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751006.png" alt="image.png"></p>
<h3 id="5-4-4-消息拉取长轮询机制分析"><a href="#5-4-4-消息拉取长轮询机制分析" class="headerlink" title="5.4.4 消息拉取长轮询机制分析"></a>5.4.4 消息拉取长轮询机制分析</h3><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。<br>​</p>
<p>代码：**<em>PullMessageProcessor#processRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751536.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041751962.png" alt="image.png"></p>
<p><strong>PullRequestHoldService方式实现长轮询</strong><br>代码：**<em>PullRequestHoldService#suspendPullRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041745036.png" alt="image.png"><br>代码：**<em>PullRequestHoldService#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041745125.png" alt="image.png"><br>代码：**<em>PullRequestHoldService#checkHoldRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041745542.png" alt="image.png"><br>代码：**<em>PullRequestHoldService#notifyMessageArriving</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041745737.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041745401.png" alt="image.png"><br>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。<br><strong>DefaultMessageStore$ReputMessageService机制</strong><br>代码：**<em>DefaultMessageStore#start</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长轮询入口 </span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>
<p>代码：**<em>DefaultMessageStore$ReputMessageService#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744373.png" alt="image.png"><br>代码：**<em>DefaultMessageStore$ReputMessageService#deReput</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744297.png" alt="image.png"><br>代码：**<em>NotifyMessageArrivingListener#arriving</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744003.png" alt="image.png"><br>​</p>
<h2 id="5-5-消息队列负载与重新分布机制"><a href="#5-5-消息队列负载与重新分布机制" class="headerlink" title="5.5 消息队列负载与重新分布机制"></a>5.5 消息队列负载与重新分布机制</h2><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个<br>RebalanceService实现，并随着MQClientInstance的启动而启动。<br>代码：**<em>RebalanceService#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744143.png" alt="image.png"><br>​</p>
<p>代码：**<em>MQClientInstance#doRebalance</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744991.png" alt="image.png"><br>代码：**<em>RebalanceImpl#rebalanceByTopic</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744552.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744995.png" alt="image.png"><br>​</p>
<p>RocketMQ默认提供5中负载均衡分配算法<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744569.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041744796.png" alt="image.png"><br>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p>
<h2 id="5-6-消息消费过程"><a href="#5-6-消息消费过程" class="headerlink" title="5.6 消息消费过程"></a>5.6 消息消费过程</h2><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743781.png" alt="image.png"><br><strong>并发消息消费</strong><br>代码：**<em>ConsumeMessageConcurrentlyService#submitConsumeRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743953.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743293.png" alt="image.png"><br>代码：**<em>ConsumeMessageConcurrentlyService$ConsumeRequest#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743958.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743337.png" alt="image.png"></p>
<p><strong>5.7 定时消息机制</strong><br>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel=1表示延迟消息1s,delayLevel=2表示延迟5s,依次类推。<br>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。<br>通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。<br>代码：**<em>ScheduleMessageService#load</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743033.png" alt="image.png"><br>代码：**<em>ScheduleMessageService#start</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743002.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743957.png" alt="image.png"><br><strong>调度机制</strong><br>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup<br>代码：**<em>ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743442.png" alt="image.png"><br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041743358.png" alt="image.png"></p>
<h2 id="5-8-顺序消息"><a href="#5-8-顺序消息" class="headerlink" title="5.8 顺序消息"></a>5.8 顺序消息</h2><p>顺序消息实现类是<br>org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService<br>代码：**<em>ConsumeMessageOrderlyService#start</em>**</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742468.png" alt="image.png"><br>​</p>
<p>代码：**<em>ConsumeMessageOrderlyService#submitConsumeRequest</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742179.png" alt="image.png"><br>代码：**<em>ConsumeMessageOrderlyService$ConsumeRequest#run</em>**<br><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201041742034.png" alt="image.png"></p>
<h2 id="5-9-小结"><a href="#5-9-小结" class="headerlink" title="5.9 小结"></a>5.9 小结</h2><p>RocketMQ消息消费方式分别为集群模式、广播模式。<br>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。<br>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。<br>并发消息消费指消费线程池中的线程可以并发对同一个消​息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。<br>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。<br>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxueyangtiger.github.io/post/a2a0d8af.html">https://lvxueyangtiger.github.io/post/a2a0d8af.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxueyangtiger.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/24e2a555.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082319.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMQ高级实战</div></div></a></div><div class="next-post pull-right"><a href="/post/75960fb2.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RocketMQ高级特性及原理(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/b443baad.html" title="RocketMQ架构与实战"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RocketMQ架构与实战</div></div></a></div><div><a href="/post/a79e00d0.html" title="RockeqMQ的简单使用"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212104.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RockeqMQ的简单使用</div></div></a></div><div><a href="/post/f7c58321.html" title="RocketMQ集群与运维"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RocketMQ集群与运维</div></div></a></div><div><a href="/post/6b84bdfb.html" title="RocketMQ的简单案例-模拟下单和支付"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RocketMQ的简单案例-模拟下单和支付</div></div></a></div><div><a href="/post/24e2a555.html" title="RocketMQ高级实战"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082319.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RocketMQ高级实战</div></div></a></div><div><a href="/post/75960fb2.html" title="RocketMQ高级特性及原理(下)"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165211.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-07</div><div class="title">RocketMQ高级特性及原理(下)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 源码拉取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AF%BC%E5%85%A5IDEA"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 导入IDEA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%90%AF%E5%8A%A8NameServer"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 启动NameServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E5%90%AF%E5%8A%A8Broker"><span class="toc-number">1.5.</span> <span class="toc-text">1.5启动Broker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.</span> <span class="toc-text">1.6发送消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.7.</span> <span class="toc-text">1.7消费消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-NameServer"><span class="toc-number">2.</span> <span class="toc-text">2. NameServer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 路由管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 路由元信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 路由注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E8%B7%AF%E7%94%B1%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 路由删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E8%B7%AF%E7%94%B1%E5%8F%91%E7%8E%B0"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 路由发现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Producer"><span class="toc-number">3.</span> <span class="toc-text">3. Producer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 方法和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1主要方法介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 属性介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 消息发送</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E9%AA%8C%E8%AF%81%E6%B6%88%E6%81%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 验证消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 查找路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 选择队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4 发送消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 批量消息发送</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">4.</span> <span class="toc-text">4. 消息存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 消息存储核心类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 消息存储流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 存储文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 存储文件内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-MappedFileQueue"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 MappedFileQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-MappedFile"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 MappedFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-TransientStorePool"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3 TransientStorePool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 实时更新消息消费队列与索引文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E8%BD%AC%E5%8F%91%E5%88%B0ConsumerQueue"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 转发到ConsumerQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E8%BD%AC%E5%8F%91%E5%88%B0Index"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2 转发到Index</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 消息队列和索引文件恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1 存储文件加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%AD%A3%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2 正常恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.3 异常恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 刷盘机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1 同步刷盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E8%BF%87%E6%9C%9F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 过期文件删除机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Consumer"><span class="toc-number">5.</span> <span class="toc-text">5. Consumer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 消息消费概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%88%9D%E6%8E%A2"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 消息消费初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 消费者启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 消息拉取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-PullMessageService%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 PullMessageService实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-ProcessQueue%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 ProcessQueue实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 消息拉取基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">5.4.3.1 客户端发起拉取请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-2-%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%AB%AFBroker%E7%BB%84%E8%A3%85%E6%B6%88%E6%81%AF"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">5.4.3.2.消息服务端Broker组装消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-3-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">5.4.3.3.消息拉取客户端处理消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-4-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">5.4.3.4.消息拉取总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4 消息拉取长轮询机制分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B4%9F%E8%BD%BD%E4%B8%8E%E9%87%8D%E6%96%B0%E5%88%86%E5%B8%83%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 消息队列负载与重新分布机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 消息消费过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">5.7.</span> <span class="toc-text">5.8 顺序消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%B0%8F%E7%BB%93"><span class="toc-number">5.8.</span> <span class="toc-text">5.9 小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>