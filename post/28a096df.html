<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Gradle笔记 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="构建工具,gradle"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述Gradle是一个基于 JVM 的富有突破性构建工具，Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。 Gradle最重要的是Project和Task：  任何一个Gradle项目都是由一个或多个projects组成的，projects其实就是Idea、AndroidStudio中的Module； tasks是任务，它是Gradle中的原子性操作，如编译、打包">
<meta property="og:type" content="article">
<meta property="og:title" content="Gradle笔记">
<meta property="og:url" content="http://lvxueyang.vip/post/28a096df.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="概述Gradle是一个基于 JVM 的富有突破性构建工具，Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。 Gradle最重要的是Project和Task：  任何一个Gradle项目都是由一个或多个projects组成的，projects其实就是Idea、AndroidStudio中的Module； tasks是任务，它是Gradle中的原子性操作，如编译、打包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.225Z">
<meta property="article:modified_time" content="2022-11-27T09:16:31.406Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="构建工具">
<meta property="article:tag" content="gradle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="http://lvxueyang.vip/post/28a096df"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Gradle笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Gradle笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.225Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:31.406Z" title="更新于 2022-11-27 17:16:31">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/gradle/">gradle</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Gradle笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gradle是一个基于 JVM 的富有突破性构建工具，Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。</p>
<p>Gradle最重要的是Project和Task：</p>
<ul>
<li>任何一个Gradle项目都是由一个或多个projects组成的，projects其实就是Idea、AndroidStudio中的Module；</li>
<li>tasks是任务，它是Gradle中的原子性操作，如编译、打包、生成javadoc等，一个project中会有多个tasks；</li>
</ul>
<p>可以通过<code>gradle tasks</code>查看当前可执行的tasks。</p>
<p>需要注意的一些地方：</p>
<ul>
<li>Gradle设计之初就是一个通用的构建工具，它允许你用它来构建任何应用，唯一的限制是Gradle的远程依赖管理目前仅支持Maven和Ivy的仓库；</li>
<li>Gradle的构建模块是基于task的，Gradle要做的就是按照task之间的依赖关系来组织task按照合适的顺序运行；</li>
<li>Gradle评估(evaluate)和指定构建脚本时有三个固定步骤：<ol>
<li>初始化(Initialization): 初始化构建所需的运行环境，并检查哪些projects参与构建</li>
<li>配置(Configuration): 将tasks组织起来，决定它们按何种顺序执行</li>
<li>执行(Execution): 执行tasks</li>
</ol>
</li>
<li>Gradle提供了集中方式以扩展：<ul>
<li>自定义task types</li>
<li>自定义task actions</li>
<li>在projects和tasks中指定额外的属性</li>
<li>自定义conventions</li>
<li>custon model</li>
</ul>
</li>
</ul>
<p>可以通过在命令行运行gradle命令来执行构建，gradle 命令会从当前目录下寻找build.gradle文件来执行构建。称 build.gradle 文件为构建脚本，严格来说这其实是一个构建配置脚本。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>gradle -q hello</code>（<code>-q</code> 参数的目的是：用来控制 gradle 的日志级别，可以保证只输出我们需要的内容）</p>
<h1 id="构建基础"><a href="#构建基础" class="headerlink" title="构建基础"></a>构建基础</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>使用<code>gradle init</code>可创建一个新工程。</p>
<h2 id="Gradle-图形用户界面"><a href="#Gradle-图形用户界面" class="headerlink" title="Gradle 图形用户界面"></a>Gradle 图形用户界面</h2><p>可以通过gradle –gui 参数来启动GUI界面，通过gradle –gui&amp; 让它作为后台任务运行。</p>
<h2 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions"></a>Conventions</h2><p>Conventions：声明式，约定式。Gradle吸收了Maven的声明式的特点，所谓声明式直接的体现就是我们将特定的文件（如代码、资源文件）放在特定的目录下，Gradle会自动地在相应的目录下找到对应的文件，减少了需要自定义的构建脚本。</p>
<p>项目创建完成之后，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.gradle/    # 存放Gradle的缓存，缓存可用于加快构建速度</span><br><span class="line">.idea/      # Idea生成的，与Gradle无关</span><br><span class="line">gradle/     # gradle文件夹中只含有wrapper文件夹，用于存放GradleWraper的jar包以及配置文件</span><br><span class="line">module1/    # module</span><br><span class="line">module2/    # module</span><br><span class="line">build.gradle        # 根目录下的build.gradle文件，是项目的构建脚本</span><br><span class="line">gradle.properties   # 配置文件</span><br><span class="line">gradlew             # Gradle Wrapper的执行脚本</span><br><span class="line">gradlew.bat         # Gradle Wrapper的执行脚本</span><br><span class="line">settings.gradle     # 项目的设置文件，最重要的作用是用于设置Multi-Project构建时哪些project参与构建</span><br></pre></td></tr></table></figure>

<h2 id="Project-API"><a href="#Project-API" class="headerlink" title="Project API"></a>Project API</h2><p>在 Gradle 中构建脚本定义了一个项目（project）。在构建的每一个项目中，Gradle 创建了一个 Project 类型的实例，并在构建脚本中关联此 Project 对象。当构建脚本执行时，它会配置此 Project 对象：</p>
<ul>
<li>在构建脚本中，你所调用的任何一个方法，如果在构建脚本中未定义，它将被委托给 Project 对象。</li>
<li>在构建脚本中，你所访问的任何一个属性，如果在构建脚本里未定义，它也会被委托给 Project 对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">println name</span><br><span class="line">println project.name  </span><br><span class="line"></span><br><span class="line">&gt; gradle -q check</span><br><span class="line">projectApi</span><br><span class="line">projectApi</span><br></pre></td></tr></table></figure>

<p>这两个 println 语句打印出相同的属性。在生成脚本中未定义的属性，第一次使用时自动委托到 Project 对象。其他语句使用了在任何构建脚本中可以访问的 project 属性，则返回关联的 Project 对象。只有当定义的属性或方法是 Project 对象的一个成员相同名字时，才需要使用 project 属性。</p>
<p>Project对象提供了一些在构建脚本中可用的标准的属性。下表列出了常用的几个属性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>project</td>
<td>Project</td>
<td>Project实例</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>项目目录的名称。</td>
</tr>
<tr>
<td>path</td>
<td>String</td>
<td>项目的绝对路径。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>项目的描述。</td>
</tr>
<tr>
<td>projectDir</td>
<td>File</td>
<td>包含生成脚本的目录。</td>
</tr>
<tr>
<td>buildDir</td>
<td>File</td>
<td>projectDir/build</td>
</tr>
<tr>
<td>group</td>
<td>Object</td>
<td>未指定</td>
</tr>
<tr>
<td>version</td>
<td>Object</td>
<td>未指定</td>
</tr>
<tr>
<td>ant</td>
<td>AntBuilder</td>
<td>AntBuilder实例</td>
</tr>
</tbody></table>
<h2 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h2><p>Gradle提供了许多种配置属性的方式：</p>
<ol>
<li>Gradle安装目录下的gradle.properties文件</li>
<li>项目根目录下的gradle.properties文件</li>
<li>环境变量GRADLE_USER_HOME所指向目录的gradle.properties文件</li>
<li>通过命令行设定的系统属性，从Gradle启动的JVM，可以使用-D命令行选项向它传入一个系统属性。</li>
</ol>
<p>除了在声明时可以定义属性之外，Gradle还提供了一个叫 “额外属性” 的东西来添加一些自定义属性，在Groovy中使用ext命名空间来声明额外属性。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println <span class="string">&quot;Greetings from the $hello.name task.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以为一个任务添加额外的属性。例如，新增一个叫做 myProperty 的属性，用 ext.myProperty 的方式给他一个初始值。这样便增加了一个自定义属性。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    ext.myProperty = <span class="string">&quot;myValue&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printTaskProperties &lt;&lt; &#123;</span><br><span class="line">    println myTask.myProperty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果构建脚本依赖于一些可选属性，而这些属性用户可能在比如 gradle.properties 文件中设置，这时可以通过使用方法<code>hasProperty(&#39;propertyName&#39;)</code>来进行检查，它返回true或false。</p>
<p>比如可以在gradle.properties中配置代理：</p>
<ul>
<li><p>配置 HTTP 代理服务器</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemProp.http.proxyHost=www.somehost.org</span><br><span class="line">systemProp.http.proxyPort=8080</span><br><span class="line">systemProp.http.proxyUser=userid</span><br><span class="line">systemProp.http.proxyPassword=password</span><br><span class="line">systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost</span><br></pre></td></tr></table></figure></li>
<li><p>配置 HTTPS 代理服务器</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemProp.https.proxyHost=www.somehost.org</span><br><span class="line">systemProp.https.proxyPort=8080</span><br><span class="line">systemProp.https.proxyUser=userid</span><br><span class="line">systemProp.https.proxyPassword=password</span><br><span class="line">systemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置与执行阶段"><a href="#配置与执行阶段" class="headerlink" title="配置与执行阶段"></a>配置与执行阶段</h2><p>Gradle运行构建脚本时有配置(Configuration)阶段和执行(Execution)阶段，先配置后执行。</p>
<p>当配置阶段执行完了之后，Gradle就知道哪些tasks将要被执行，Gradle给我们提供了一个hook的能力，在两个阶段之间执行一些操作。</p>
<p>下面的demo将根据release这个task是否将会被执行做出不同操作，这个demo具有实际意义，代表我们在开发时debug和release的两种情况。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">task distribution &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;We build the zip with version=$version&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task release &#123;</span><br><span class="line">    dependsOn <span class="string">&#x27;distribution&#x27;</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;We release now&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.whenReady &#123; taskGraph -&gt;</span><br><span class="line">    <span class="keyword">if</span> (taskGraph.hasTask(<span class="string">&quot;:release&quot;</span>)) &#123;</span><br><span class="line">        version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        version = <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q distribution</span><br><span class="line">We build the zip with version=<span class="number">1.0</span>-SNAPSHOT</span><br><span class="line">&gt; gradle -q release</span><br><span class="line">We build the zip with version=<span class="number">1.0</span></span><br><span class="line">We release now</span><br></pre></td></tr></table></figure>

<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>如果你的构建脚本需要使用一些外部的依赖，比如说需要一些开源库来执行某些操作时，可以将它们的classpath添加至脚本中，使用buildscript方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="attr">group:</span> <span class="string">&#x27;commons-codec&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;commons-codec&#x27;</span>, <span class="attr">version:</span><span class="string">&#x27;1.2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task encode &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="keyword">def</span> <span class="keyword">byte</span>[] encodedString = <span class="keyword">new</span> Base64().encode(<span class="string">&#x27;hello world\n&#x27;</span>).getBytes()</span><br><span class="line">        println <span class="keyword">new</span> String(encodedString)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q encode</span><br><span class="line">aGVsbG8gd29ybGQK</span><br></pre></td></tr></table></figure>

<p>注意：implementation和api等都是Java插件提供的！</p>
<h2 id="外部构建脚本"><a href="#外部构建脚本" class="headerlink" title="外部构建脚本"></a>外部构建脚本</h2><p>可以使用外部构建脚本来配置当前项目，Gradle构建语言的所有内容在外部脚本中也可以使用。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other.gradle</span></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            test()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test() &#123;</span><br><span class="line">    println <span class="string">&quot;other: method&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task other &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;other: task&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在build.gradle中引用它：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;other.gradle&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span> <span class="comment">// Enables code shrinking for the release build type.</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">other.doLast &#123;</span><br><span class="line">    println <span class="string">&quot;build: task&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式引用了other.gradle后，可以在build.gradle中使用other task，通过其release的buildTypes还会执行test()函数。</p>
<h2 id="守护进程-Daemon"><a href="#守护进程-Daemon" class="headerlink" title="守护进程(Daemon)"></a>守护进程(Daemon)</h2><p>Gradle运行在JVM上，它会一些额外的类库，但这些类库在初始化时会花费一些时间，这会导致在某些时候，Gradle在启动的时候有些慢。解决办法是使用Gradle守护进程：它是一个长期在后台运行的进程，可以更快速的执行一些构建任务。</p>
<p>它的实现方式是避免昂贵的启动过程和使用缓存，将项目的相关数据保存在内存当中。使用守护进程运行构建和以普通方式运行构建没有区别，只需要简单的配置，所有这些操作对于使用者来是透明的。</p>
<p>Gradle不使用已经运行的守护进程而创建一个新的守护进程有几个原因。基本规则是:如果没有可用的空闲或兼容的守护进程，Gradle将启动一个新的守护进程。Gradle会杀死已经闲置3个小时以上的守护进程，所以你不必担心手动清理它们。</p>
<p>从Gradle 3.0开始，默认情况下启用守护程序，但如果您使用的是旧版本，则应该在本地开发人员计算机上启用它。在旧版本上启动守护进程的方式：</p>
<ol>
<li>通过命令传递参数：<code>-Dorg.gradle.daemon=true</code></li>
<li>在gradle配置文件（<code>GRADLE_USER_HOME/gradle.properties</code>）中配置：<code>org.gradle.daemon=true</code></li>
</ol>
<p>守护进程是运行在后台的进程，如果连续3个小时，守护进程都没有被激活（运行Gradle的任务），那么守护进程就会停掉。当然，如果你想要手动关掉守护进程，可以执行：<code>gradle --stop</code></p>
<p>默认情况下，Gradle将为您的构建保留1GB的堆空间，这对于大多数项目来说是足够的，一些非常大的构建可能需要更多内存来保存Gradle的模型和缓存。如果是这种情况，您可以在gradle.properties文件中检入更大的内存要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// gradle.properties</span><br><span class="line">org.gradle.jvmargs=-Xmx2048M</span><br></pre></td></tr></table></figure>

<h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><h2 id="创建task"><a href="#创建task" class="headerlink" title="创建task"></a>创建task</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面三种定义也一模一样</span></span><br><span class="line">task myTask &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;after execute myTask&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project.task(<span class="string">&#x27;myTask&#x27;</span>).doLast &#123;</span><br><span class="line">    println <span class="string">&quot;after execute myTask&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">project.tasks.create(<span class="string">&#x27;myTask&#x27;</span>).doLast &#123;</span><br><span class="line">    println <span class="string">&quot;after execute myTask&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种创建Task的方式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">void</span> action() &#123;</span><br><span class="line">        println <span class="string">&quot;action1+++++&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 hello3 task</span></span><br><span class="line">task hello3 (<span class="attr">type:</span> MyTask) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">       println <span class="string">&quot;action2+++++&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;gradle hello3</span><br><span class="line">action1+++++</span><br><span class="line">action2+++++</span><br></pre></td></tr></table></figure>

<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>一个项目可以有多个Project、每个Project中又有多个Task，Task是原子性的操作，一个Task又由多个Action组成，多个Action组成一个Action List，按顺序执行。</p>
<p>doLast函数就是往Task的Action List的末端插入一个Action，相应的还有doFirst函数——往Action List的前端插入一个Action。doLast、doFirst都可以被调用多次。</p>
<p>创建Action的相关API：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Action 队列头部添加Action</span></span><br><span class="line">Task doFirst(Action&lt;? super Task&gt; action);</span><br><span class="line">Task doFirst(Closure action);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Action 队列尾部添加Action</span></span><br><span class="line">Task doLast(Action&lt;? super Task&gt; action);</span><br><span class="line">Task doLast(Closure action);</span><br><span class="line"></span><br><span class="line"><span class="comment">//已经过时了，建议用 doLast 代替</span></span><br><span class="line">Task leftShift(Closure action);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有的Action</span></span><br><span class="line">Task deleteAllActions();</span><br></pre></td></tr></table></figure>

<h2 id="Groovy与Kotlin"><a href="#Groovy与Kotlin" class="headerlink" title="Groovy与Kotlin"></a>Groovy与Kotlin</h2><p>Gradle的构建脚本完全支持Groovy和Kotlin两种语言，当用Groovy书写构建脚本时，文件名为build.gradle；用kotlin书写时，文件名为build.gradle.kts。</p>
<p>以下是两个例子，分别用两种语言实现同一个功能：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">task upper &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        String someString = <span class="string">&#x27;mY_nAmE&#x27;</span></span><br><span class="line">        println <span class="string">&quot;Original: $someString&quot;</span></span><br><span class="line">        println <span class="string">&quot;Upper case: $&#123;someString.toUpperCase()&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//build.gradle.kts</span></span><br><span class="line">tasks.register(<span class="string">&quot;upper&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        val someString = <span class="string">&quot;mY_nAmE&quot;</span></span><br><span class="line">        println(<span class="string">&quot;Original: $someString&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Upper case: $&#123;someString.toUpperCase()&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>task的名字</td>
<td>不能为空，必须指定</td>
</tr>
<tr>
<td>type</td>
<td>task的“父类”</td>
<td>DefaultTask</td>
</tr>
<tr>
<td>overwrite</td>
<td>是否替换已经存在的task</td>
<td>false</td>
</tr>
<tr>
<td>dependsOn</td>
<td>task依赖的task的集合</td>
<td>[]</td>
</tr>
<tr>
<td>group</td>
<td>task属于哪个组</td>
<td>null</td>
</tr>
<tr>
<td>description</td>
<td>task的描述</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="task依赖"><a href="#task依赖" class="headerlink" title="task依赖"></a>task依赖</h2><p>有些任务之间可能会有先后关系，这时候就可以用tasks之间的依赖关系来，依赖关系使用dependsOn方法来表示，比如下面的demo就表示taskX的运行依赖于taskY的运行：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">task taskX &#123;</span><br><span class="line">    dependsOn <span class="string">&#x27;taskY&#x27;</span></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;taskX&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task taskY &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;taskY&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q taskX</span><br><span class="line">taskY</span><br><span class="line">taskX</span><br></pre></td></tr></table></figure>

<h2 id="动态创建task"><a href="#动态创建task" class="headerlink" title="动态创建task"></a>动态创建task</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line"><span class="number">4.</span>times &#123; counter -&gt;</span><br><span class="line">    task <span class="string">&quot;task$counter&quot;</span> &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            println <span class="string">&quot;I&#x27;m task number $counter&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q task1</span><br><span class="line">I<span class="string">&#x27;m task number 1</span></span><br></pre></td></tr></table></figure>

<h2 id="Task操纵"><a href="#Task操纵" class="headerlink" title="Task操纵"></a>Task操纵</h2><p>一旦任务被创建后，任务之间可以通过 API 进行相互访问。</p>
<h3 id="增加依赖"><a href="#增加依赖" class="headerlink" title="增加依赖"></a>增加依赖</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span>times &#123; counter -&gt;</span><br><span class="line">    task <span class="string">&quot;task$counter&quot;</span> &lt;&lt; &#123;</span><br><span class="line">        println <span class="string">&quot;I&#x27;m task number $counter&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task0.dependsOn task2, task3</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">Output of gradle -q task0</span><br><span class="line">\&gt; gradle -q task0</span><br><span class="line">I<span class="string">&#x27;m task number 2</span></span><br><span class="line"><span class="string">I&#x27;</span>m task number <span class="number">3</span></span><br><span class="line">I<span class="string">&#x27;m task number 0</span></span><br></pre></td></tr></table></figure>

<h3 id="增加任务行为"><a href="#增加任务行为" class="headerlink" title="增加任务行为"></a>增加任务行为</h3><p>doFirst 和 doLast 可以进行多次调用。他们分别被添加在任务的开头和结尾。当任务开始执行时这些动作会按照既定顺序进行。其中 &lt;&lt; 操作符 是 doLast 的简写方式（弃用）。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello Earth&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doFirst &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello Venus&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello Mars&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello Jupiter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task hello1</span><br><span class="line"></span><br><span class="line">hello1.doLast &#123;</span><br><span class="line">    println <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello1.doFirst &#123;</span><br><span class="line">    println(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q hello</span><br><span class="line">Hello Venus</span><br><span class="line">Hello Earth</span><br><span class="line">Hello Mars</span><br><span class="line">Hello Jupiter</span><br></pre></td></tr></table></figure>

<h2 id="定义默认任务"><a href="#定义默认任务" class="headerlink" title="定义默认任务"></a>定义默认任务</h2><p>Gradle允许添加默认Task，当执行gradle命令而不指定task时就会执行这些默认的Tasks，当gradle命令指定了task时，默认的Task除非被依赖，否则不会执行。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">defaultTasks <span class="string">&#x27;clean&#x27;</span>, <span class="string">&#x27;run&#x27;</span></span><br><span class="line">task clean &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Default Cleaning!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task run &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Default Running!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task other &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&quot;I&#x27;m not a default task!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; gradle -q</span><br><span class="line">Default Cleaning!</span><br><span class="line">Default Running!</span><br><span class="line">&gt; gradle -q other</span><br><span class="line">I<span class="string">&#x27;m not a default task!</span></span><br></pre></td></tr></table></figure>

<p>执行gradle -q 与直接调用<code>gradle clean run</code>效果是一样的。在多项目构建中，每个子项目都可以指定单独的默认任务。如果子项目未进行指定将会调用父项目指定的的默认任务。</p>
<h1 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h1><p>在Gradle插件中可以通过自定义的Extension，实现在build脚本中增加类似于Android插件中<code>android&#123;&#125;</code>命名空间的配置，gradle可以读取这些配置，然后在自定义的插件中做处理。</p>
<h2 id="ExtensionContainer"><a href="#ExtensionContainer" class="headerlink" title="ExtensionContainer"></a>ExtensionContainer</h2><p>这个类与 TaskContainer 命名有点类似，TaskContainer 是用来创建并管理 Task 的，而 ExtensionContainer 则是用来创建并管理 Extension 的。通过 Project 的以下 API 可以获取到 ExtensionContainer 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExtensionContainer getExtensions()</span><br></pre></td></tr></table></figure>

<p><strong>简单示例：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个普通的java类，包含2个属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line">    String username</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = $&#123;username&#125;, age = $&#123;age&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个名为 foo 的Extension</span></span><br><span class="line">getExtensions().create(<span class="string">&quot;foo&quot;</span>, Foo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置Extension</span></span><br><span class="line">foo &#123;</span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line">    username = <span class="string">&quot;hjy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testExt &lt;&lt; &#123;</span><br><span class="line">    <span class="comment">//能直接通过 project 获取到自定义的 Extension</span></span><br><span class="line">    println project.foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建Extension的方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Extension名称, 实现类, 参数</span><br><span class="line">&lt;T&gt; T create(String var1, Class&lt;T&gt; var2, Object... var3);</span><br></pre></td></tr></table></figure>

<p>前面的 create() 方法会创建并返回一个 Extension 对象，与之相似的还有一个 add() 方法，唯一的差别是它并不会返回一个 Extension 对象。</p>
<p><strong>查找Extension的方法：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Object findByName(String name)</span><br><span class="line">&lt;T&gt; T findByType(Class&lt;T&gt; type)</span><br><span class="line">Object getByName(String name)</span><br><span class="line">&lt;T&gt; T getByType(Class&lt;T&gt; type)</span><br></pre></td></tr></table></figure>

<p><strong>创建嵌套Extension：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterExt</span> &#123;</span></span><br><span class="line">    String outerName</span><br><span class="line">    String msg</span><br><span class="line">    InnerExt innerExt = <span class="keyword">new</span> InnerExt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> outerName(String name) &#123;</span><br><span class="line">        outerName = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> msg(String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建内部Extension，名称为方法名 inner</span></span><br><span class="line">    <span class="keyword">void</span> inner(Action&lt;InnerExt&gt; action) &#123;</span><br><span class="line">        action.execute(inner)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建内部Extension，名称为方法名 inner</span></span><br><span class="line">    <span class="keyword">void</span> inner(Closure c) &#123;</span><br><span class="line">        org.gradle.util.ConfigureUtil.configure(c, innerExt) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OuterExt[ name = $&#123;outerName&#125;, msg = $&#123;msg&#125;] &quot;</span> + innerExt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerExt</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    String innerName</span><br><span class="line">    String msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> innerName(String name) &#123;</span><br><span class="line">        innerName = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> msg(String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InnerExt[ name = $&#123;innerName&#125;, msg = $&#123;msg&#125;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> outExt = getExtensions().create(<span class="string">&quot;outer&quot;</span>, OuterExt)</span><br><span class="line"></span><br><span class="line">outer &#123;</span><br><span class="line">    outerName <span class="string">&quot;outer&quot;</span></span><br><span class="line">    msg <span class="string">&quot;this is a outer message.&quot;</span></span><br><span class="line">    inner &#123;</span><br><span class="line">        innerName <span class="string">&quot;inner&quot;</span></span><br><span class="line">        msg <span class="string">&quot;This is a inner message.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testExt &lt;&lt; &#123;</span><br><span class="line">    println outExt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键点在于下面这2个方法的定义，只需要定义任意一个即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inner(Action&lt;InnerExt&gt; action)</span><br><span class="line">void inner(Closure c)</span><br></pre></td></tr></table></figure>

<h2 id="NamedDomainObjectContainer"><a href="#NamedDomainObjectContainer" class="headerlink" title="NamedDomainObjectContainer"></a>NamedDomainObjectContainer</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">            signingConfig signingConfigs.hmiou</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            signingConfig signingConfigs.hmiou</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的release和debug可以修改成任意名字，且可以新增其它name，这是通过NamedDomainObjectContainer实现的。</p>
<p><strong>创建NamedDomainObjectContainer：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Project.container</span><br><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(Class&lt;T&gt; type)</span><br><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(Class&lt;T&gt; type, NamedDomainObjectFactory&lt;T&gt; factory)</span><br><span class="line">&lt;T&gt; NamedDomainObjectContainer&lt;T&gt; container(java.lang.Class&lt;T&gt; type, Closure factoryClosure</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是领域对象类型定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDomainObj</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须定义一个 name 属性，并且这个属性值初始化以后不要修改</span></span><br><span class="line">    String name</span><br><span class="line"></span><br><span class="line">    String msg</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数必须有一个 name 参数</span></span><br><span class="line">    <span class="keyword">public</span> TestDomainObj(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> msg(String msg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = $&#123;name&#125;, msg = $&#123;msg&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestExtension</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个 NamedDomainObjectContainer 属性</span></span><br><span class="line">    NamedDomainObjectContainer&lt;TestDomainObj&gt; testDomains</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TestExtension(Project project) &#123;</span><br><span class="line">        <span class="comment">//通过 project.container(...) 方法创建 NamedDomainObjectContainer </span></span><br><span class="line">        NamedDomainObjectContainer&lt;TestDomainObj&gt; domainObjs = project.container(TestDomainObj)</span><br><span class="line">        testDomains = domainObjs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让其支持 Gradle DSL 语法</span></span><br><span class="line">    <span class="keyword">void</span> testDomain(Action&lt;NamedDomainObjectContainer&lt;TestDomainObj&gt;&gt; action) &#123;</span><br><span class="line">        action.execute(testDomains)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> test() &#123;</span><br><span class="line">        <span class="comment">//遍历命名领域对象容器，打印出所有的领域对象值</span></span><br><span class="line">        testDomains.all &#123; data -&gt;</span><br><span class="line">            println data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个名为 test 的 Extension</span></span><br><span class="line"><span class="keyword">def</span> testExt = getExtensions().create(<span class="string">&quot;test&quot;</span>, TestExtension, project)</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    testDomain &#123;</span><br><span class="line">        domain2 &#123;</span><br><span class="line">            msg <span class="string">&quot;This is domain2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        domain1 &#123;</span><br><span class="line">            msg <span class="string">&quot;This is domain1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        domain3 &#123;</span><br><span class="line">            msg <span class="string">&quot;This is domain3&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task myTask &lt;&lt; &#123;</span><br><span class="line">    testExt.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找和遍历：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">void</span> all(Closure action)</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">&lt;T&gt; T getByName(String name)</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">&lt;T&gt; T findByName(String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名字查找</span></span><br><span class="line">TestDomainObj testData = testDomains.getByName(<span class="string">&quot;domain2&quot;</span>)</span><br><span class="line">println <span class="string">&quot;getByName: $&#123;testData&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历命名领域对象容器，打印出所有的领域对象值</span></span><br><span class="line">testDomains.all &#123; data -&gt;</span><br><span class="line">    println data        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Gradle 中有很多容器类的迭代遍历方法有 each(Closure action)、all(Closure action)，但是一般我们都会用 all(…) 来进行容器的迭代。all(…) 迭代方法的特别之处是，不管是容器内已存在的元素，还是后续任何时刻加进去的元素，都会进行遍历。</p>
<h1 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>项目结构如下：</p>
<ul>
<li>mult_demo/<ul>
<li>part1</li>
<li>part2</li>
</ul>
</li>
</ul>
<p>定义一个多项目构建工程需要在根目录创建一个setting 配置文件来指明构建包含哪些项目。并且这个文件必需叫 settings.gradle。本例的配置文件如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rootProject.name = &#x27;mult_demo&#x27;</span><br><span class="line">include &#x27;part1&#x27;</span><br><span class="line">include &#x27;part2&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h2><p>根项目就像一个容器，子项目会迭代访问它的配置并注入到自己的配置中。这样我们就可以简单的为所有工程定义主配置单了。</p>
<p>allprojects和subprojects的区别：allprojects是对所有project的配置，包括Root Project。而subprojects是对所有Child Project的配置。</p>
<p>新建一个工程test，其下有两个submodule：app和lib。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;:app&#x27;</span>,<span class="string">&#x27;:lib&#x27;</span></span><br><span class="line"><span class="comment">// test: build.gradle</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    tasks.create(<span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">        doLast &#123; task -&gt;</span><br><span class="line">            print <span class="string">&quot;project name is $task.project.name \n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    hello &lt;&lt; &#123;</span><br><span class="line">        print <span class="string">&quot;here is subprojects \n&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;output</span><br><span class="line">$ gradle -q hello</span><br><span class="line">project name is test_gradle </span><br><span class="line"></span><br><span class="line">project name is app </span><br><span class="line">here is subprojects </span><br><span class="line"></span><br><span class="line">project name is lib </span><br><span class="line">here is subprojects</span><br></pre></td></tr></table></figure>

<p>在rootProject下的build.gradle中：buildscript的repositories和allprojects的repositories的区别：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&#x27;https://maven.google.com/&#x27;</span></span><br><span class="line">            name <span class="string">&#x27;Google&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:2.3.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;http://maven.xxxxxxxx/xxxxx&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>buildscript里是gradle脚本执行所需依赖，分别是对应的maven库和插件</li>
<li>allprojects里是项目本身需要的依赖，比如代码中某个类是打包到maven私有库中的，那么在allprojects—&gt;repositories中需要配置maven私有库，而不是buildscript中，不然找不到。</li>
</ol>
<h2 id="工程依赖"><a href="#工程依赖" class="headerlink" title="工程依赖"></a>工程依赖</h2><p>Gradle在构建api之前总是会先构建shared工程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(&#x27;:shared&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>一个项目可以采用多个库。Gradle 会按照顺序从各个库里寻找所需的依赖文件，并且一旦找到第一个便停止搜索。</p>
<p><strong>Maven中央仓库：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Maven远程仓库：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&quot;http://repo.mycompany.com/maven2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>远程Ivy仓库：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url <span class="string">&quot;http://repo.mycompany.com/repo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本地Ivy目录：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url <span class="string">&quot;/home/hearing/WorkSpace/gradle/repo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&quot;com.hearing:part1:1.0-SNAPSHOT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p><strong>发布到Ivy仓库：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ivy &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">&quot;username&quot;</span></span><br><span class="line">                password <span class="string">&quot;pw&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            url <span class="string">&quot;http://repo.mycompany.com&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ivy &#123;</span><br><span class="line">            url <span class="string">&quot;/home/hearing/WorkSpace/gradle/repo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 gradle uploadArchives，Gradle 便会构建并上传你的 jar 包，同时会生成一个 ivy.xml 一起上传到目标仓库。</p>
<p><strong>发布到Maven仓库：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="attr">url:</span> <span class="string">&quot;file://localhost/tmp/myRepo/&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发布到Jcenter：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.novoda.bintray-release&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties()</span><br><span class="line">properties.load(project.rootProject.file(<span class="string">&#x27;local.properties&#x27;</span>)</span><br><span class="line">        .newDataInputStream())</span><br><span class="line"></span><br><span class="line"><span class="comment">// publish to bintray</span></span><br><span class="line">publish &#123;</span><br><span class="line">    userOrg = <span class="string">&#x27;ljd1997&#x27;</span></span><br><span class="line">    groupId = <span class="string">&#x27;com.hearing.gradle&#x27;</span></span><br><span class="line">    artifactId = <span class="string">&#x27;ipcbridge&#x27;</span></span><br><span class="line">    uploadName = <span class="string">&#x27;com.hearing.gradle:ipcbridge&#x27;</span></span><br><span class="line">    publishVersion = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">    desc = <span class="string">&#x27;IpcBridge for Android&#x27;</span></span><br><span class="line">    website = <span class="string">&#x27;https://github.com/ljd1996/IpcBridge&#x27;</span></span><br><span class="line">    bintrayUser = <span class="string">&quot;$&#123;properties.get(&#x27;bintray.user&#x27;)&#125;&quot;</span></span><br><span class="line">    bintrayKey = <span class="string">&quot;$&#123;properties.get(&#x27;bintray.apikey&#x27;)&#125;&quot;</span></span><br><span class="line">    dryRun = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// publish to local</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            pom.groupId = <span class="string">&#x27;com.hearing.gradle&#x27;</span></span><br><span class="line">            pom.artifactId = <span class="string">&#x27;ipcbridge&#x27;</span></span><br><span class="line">            pom.version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">            repository(<span class="attr">url:</span> uri(<span class="string">&#x27;../maven&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体使用见：<a target="_blank" rel="noopener" href="https://github.com/HailouWang/bintray-release/wiki">bintray-release-wiki</a>。</p>
<h1 id="Gradle生命周期"><a href="#Gradle生命周期" class="headerlink" title="Gradle生命周期"></a>Gradle生命周期</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>生命周期阶段：</p>
<ol>
<li>初始化阶段</li>
<li>配置阶段</li>
<li>执行阶段</li>
</ol>
<p>在<strong>初始化阶段</strong>，Gradle 根据 settings.gradle 文件的配置为项目创建了 Project 实例。在给定的构建脚本中只定义了一个项目。在多项目构建中，这个构建阶段变得更加重要。根据你正在执行的项目，Gradle 找出哪些项目需要参与到构建中。实质为执行 settings.gradle 脚本。注意，在这个阶段当前已有的构建脚本代码都不会被执行。</p>
<p>用户可以在 settings.gradle 文件中调用 Settings 类的各种方法配置项目，最常用的就是 include 方法，它可以将用户新建的module加入项目中。</p>
<p>在<strong>配置阶段</strong>，Gradle 构造了一个模型来表示任务，并参与到构建中来。增量式构建特性决定了模型中的 task 是否需要运行。配置阶段完成后，整个 build 的 project 以及内部的 Task 关系就确定了。这个阶段非常适合于为项目或指定 task 设置所需的配置。配置阶段的实质为解析每个被加入构建项目的 build.gradle 脚本，比如通过 apply 方法引入插件，为插件扩展属性进行的配置等等。</p>
<p>注意，项目的每一次构建的任何配置代码都可以被执行–即使你只执行 gradle tasks。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./gradlew testPluginTask1</span><br><span class="line">&gt; Configure project :app</span><br><span class="line">** Test This is my first gradle plugin **</span><br><span class="line">## hello</span><br><span class="line">before apply CustomPlugin</span><br><span class="line">** This is my first gradle plugin. msg = null</span><br><span class="line">after apply CustomPlugin</span><br><span class="line">&gt; Task :app:testPluginTask1</span><br><span class="line">## This is my first gradle plugin in testPlugin task. msg = testMSG</span><br></pre></td></tr></table></figure>

<p>比如这里是执行 task，但是仍然经历了配置阶段。</p>
<p>在<strong>执行阶段</strong>，所有的 task 都应该以正确的顺序被执行。执行顺序时由它们的依赖决定的。如果任务被认为没有被修改过，将被跳过。</p>
<p>Gradle 的增量式的构建特性紧紧地与生命周期相结合。</p>
<h2 id="生命周期监听"><a href="#生命周期监听" class="headerlink" title="生命周期监听"></a>生命周期监听</h2><p>有两种方式可以编写回调声明周期事件：在闭包中，或者是通过 Gradle API 所提供的监听器接口实现。</p>
<p>Projet 提供的一些生命周期回调方法：</p>
<ul>
<li>afterEvaluate(closure)，afterEvaluate(action)</li>
<li>beforeEvaluate(closure)，beforeEvaluate(action)</li>
</ul>
<p>Gradle 提供的一些生命周期回调方法：</p>
<ul>
<li>afterProject(closure)，afterProject(action)</li>
<li>beforeProject(closure)，beforeProject(action)</li>
<li>buildFinished(closure)，buildFinished(action)</li>
<li>projectsEvaluated(closure)，projectsEvaluated(action)</li>
<li>projectsLoaded(closure)，projectsLoaded(action)</li>
<li>settingsEvaluated(closure)，settingsEvaluated(action)</li>
<li>addBuildListener(buildListener)</li>
<li>addListener(listener)</li>
<li>addProjectEvaluationListener(listener)</li>
</ul>
<p>可以看到，每个方法都有两个不同参数的方法，一个接收闭包作为回调，另外一个接受 Action 作为回调。</p>
<p>注意：一些声明周期事件只有在适当的位置上声明才会发生。</p>
<h3 id="beforeEvaluate"><a href="#beforeEvaluate" class="headerlink" title="beforeEvaluate"></a>beforeEvaluate</h3><p>beforeEvaluate()是在 project 开始配置前调用，当前的 project 作为参数传递给闭包。</p>
<p>这个方法很容易误用，你要是直接当前子模块的 build.gradle 中使用是肯定不会调用到的，因为Project都没配置好所以也就没它什么事情，这个代码块的添加只能放在父工程的 build.gradle 中，如此才可以调用的到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.project.subprojects &#123; sub -&gt;</span><br><span class="line">    sub.beforeEvaluate &#123; project</span><br><span class="line">        println &quot;#### Evaluate before of &quot;+project.path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Action 作为参数的方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.project.subprojects &#123; sub -&gt;</span><br><span class="line">    sub.beforeEvaluate(<span class="keyword">new</span> Action&lt;Project&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">void</span> execute(Project project) &#123;</span><br><span class="line">            println <span class="string">&quot;#### Evaluate before of &quot;</span>+project.path</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterEvaluate"><a href="#afterEvaluate" class="headerlink" title="afterEvaluate"></a>afterEvaluate</h3><p>afterEvaluate 是一般比较常见的一个配置参数的回调方式，只要 project 配置成功均会调用，不论是在父模块还是子模块。参数类型以及写法与afterEvaluate相同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project.afterEvaluate &#123; pro -&gt;</span><br><span class="line">    println(&quot;#### Evaluate after of &quot; + pro.path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterProject"><a href="#afterProject" class="headerlink" title="afterProject"></a>afterProject</h3><p>设置一个 project 配置完毕后立即执行的闭包或者回调方法。</p>
<p>afterProject 在配置参数失败后会传入两个参数，前者是当前 project，后者显示失败信息。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getGradle().afterProject &#123; project,projectState -&gt;</span><br><span class="line">    <span class="keyword">if</span>(projectState.failure)&#123;</span><br><span class="line">        println <span class="string">&quot;Evaluation afterProject of &quot;</span>+project+<span class="string">&quot; FAILED&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">&quot;Evaluation afterProject of &quot;</span>+project+<span class="string">&quot; succeeded&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beforeProject"><a href="#beforeProject" class="headerlink" title="beforeProject"></a>beforeProject</h3><p>设置一个 project 配置前执行的闭包或者回调方法，当前 project 作为参数传递给闭包。</p>
<p>子模块的该方法声明在 root project 中回调才会执行，root project 的该方法声明在 settings.gradle 中才会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.beforeProject &#123; p -&gt;</span><br><span class="line">    println(&quot;Evaluation beforeProject&quot;+p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="buildFinished"><a href="#buildFinished" class="headerlink" title="buildFinished"></a>buildFinished</h3><p>构建结束时的回调，此时所有的任务都已经执行，一个构建结果的对象 BuildResult 作为参数传递给闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.buildFinished &#123; r -&gt;</span><br><span class="line">    println(&quot;buildFinished &quot;+r.failure)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="projectsEvaluated"><a href="#projectsEvaluated" class="headerlink" title="projectsEvaluated"></a>projectsEvaluated</h3><p>所有的 project 都配置完成后的回调，此时，所有的project都已经配置完毕，准备开始生成 task 图。gradle 对象会作为参数传递给闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.projectsEvaluated &#123;gradle -&gt;</span><br><span class="line">    println(&quot;projectsEvaluated&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="projectsLoaded"><a href="#projectsLoaded" class="headerlink" title="projectsLoaded"></a>projectsLoaded</h3><p>当 setting 中的所有project 都创建好时执行闭包回调。gradle 对象会作为参数传递给闭包。</p>
<p>这个方法也比较特殊，只有声明在适当的位置上才会发生，如果将这个声明周期挂接闭包声明在 build.gradle 文件中，那么将不会发生这个事件，因为项目创建发生在初始化阶段。</p>
<p>放在 settings.gradle 中是可以执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.projectsLoaded &#123;gradle -&gt;</span><br><span class="line">    println(&quot;@@@@@@@ projectsLoaded&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="settingsEvaluated"><a href="#settingsEvaluated" class="headerlink" title="settingsEvaluated"></a>settingsEvaluated</h3><p>当 settings.gradle 加载并配置完毕后执行闭包回调，setting对象已经配置好并且准备开始加载构建 project。</p>
<p>这个回调在 build.gradle 中声明也是不起作用的，在 settings.gradle 中声明是可以的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.settingsEvaluated &#123;</span><br><span class="line">    println(<span class="string">&quot;@@@@@@@ settingsEvaluated&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们说过，设置监听回调还有另外一种方法，通过设置接口监听添加回调来实现。作用的对象均是所有的 project 实现。</p>
<h3 id="addProjectEvaluationListener"><a href="#addProjectEvaluationListener" class="headerlink" title="addProjectEvaluationListener"></a>addProjectEvaluationListener</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.addProjectEvaluationListener(<span class="keyword">new</span> ProjectEvaluationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> beforeEvaluate(Project project) &#123;</span><br><span class="line">        println <span class="string">&quot; add project evaluation lister beforeEvaluate,project path is: &quot;</span>+project</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> afterEvaluate(Project project, ProjectState state) &#123;</span><br><span class="line">        println <span class="string">&quot; add project evaluation lister afterProject,project path is:&quot;</span>+project</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h3><p>添加一个实现来 listener 接口的对象到 build。</p>
<h3 id="addBuildListener"><a href="#addBuildListener" class="headerlink" title="addBuildListener"></a>addBuildListener</h3><p>添加一个 BuildListener 对象到 Build 。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.addBuildListener(<span class="keyword">new</span> BuildListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> buildStarted(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### buildStarted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> settingsEvaluated(Settings settings) &#123;</span><br><span class="line">        println(<span class="string">&quot;### settingsEvaluated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> projectsLoaded(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### projectsLoaded&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### projectsEvaluated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> buildFinished(BuildResult result) &#123;</span><br><span class="line">        println(<span class="string">&quot;### buildFinished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="TaskExecutionGraph"><a href="#TaskExecutionGraph" class="headerlink" title="TaskExecutionGraph"></a>TaskExecutionGraph</h2><p>在配置时，Gradle 决定了在执行阶段要运行的 task 的顺序，他们的依赖关系的内部结构被建模为一个有向无环图，我们可以称之为 taks 执行图，它可以用 TaskExecutionGraph 来表示。可以通过 gradle.taskGraph 来获取。</p>
<p>在 TaskExecutionGraph 中也可以设置一些 Task 生命周期的回调：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">addTaskExecutionGraphListener(TaskExecutionGraphListener listener)</span><br><span class="line">addTaskExecutionListener(TaskExecutionListener listener)</span><br><span class="line">afterTask(Action action)，afterTask(Closure closure)</span><br><span class="line">beforeTask(Action action)，beforeTask(Closure closure)</span><br><span class="line">whenReady(Action action)，whenReady(Closure closure)</span><br></pre></td></tr></table></figure>

<h3 id="addTaskExecutionGraphListener"><a href="#addTaskExecutionGraphListener" class="headerlink" title="addTaskExecutionGraphListener"></a>addTaskExecutionGraphListener</h3><p>添加 task 执行图的监听器，当执行图配置好会执行通知。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(<span class="keyword">new</span> TaskExecutionGraphListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> graphPopulated(TaskExecutionGraph graph) &#123;</span><br><span class="line">        println(<span class="string">&quot;@@@ gradle.taskGraph.graphPopulated &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="addTaskExecutionListener"><a href="#addTaskExecutionListener" class="headerlink" title="addTaskExecutionListener"></a>addTaskExecutionListener</h3><p>添加 task 执行监听器，当 task 执行前或者执行完毕会执行回调发出通知。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.addTaskExecutionListener(<span class="keyword">new</span> TaskExecutionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> beforeExecute(Task task) &#123;</span><br><span class="line">        println(<span class="string">&quot;@@@ gradle.taskGraph.beforeTask &quot;</span>+task)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> afterExecute(Task task, TaskState state) &#123;</span><br><span class="line">        println(<span class="string">&quot;@@@ gradle.taskGraph.afterTask &quot;</span>+task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="afterTask"><a href="#afterTask" class="headerlink" title="afterTask"></a>afterTask</h3><p>设置一个 task 执行完毕的闭包或者回调方法。该 task 作为参数传递给闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.afterTask &#123; task -&gt;</span><br><span class="line">    println(<span class="string">&quot;### gradle.taskGraph.afterTask &quot;</span>+task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="beforeTask"><a href="#beforeTask" class="headerlink" title="beforeTask"></a>beforeTask</h3><p>设置一个 task 执行前的闭包或者回调方法。该 task 作为参数传递给闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.beforeTask &#123; task -&gt;</span><br><span class="line">    println(<span class="string">&quot;### gradle.taskGraph.beforeTask &quot;</span>+task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="whenReady"><a href="#whenReady" class="headerlink" title="whenReady"></a>whenReady</h3><p>设置一个 task 执行图准备好后的闭包或者回调方法。该 taskGrahp 作为参数传递给闭包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.taskGraph.whenReady &#123; taskGrahp -&gt;</span><br><span class="line">    println(<span class="string">&quot;@@@ gradle.taskGraph.whenReady &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期顺序"><a href="#生命周期顺序" class="headerlink" title="生命周期顺序"></a>生命周期顺序</h2><p>我们通过在生命周期回调中添加打印的方法来看一下他们的执行顺序。为了看一下配置 task 的时机，我们在 app 模块中创建来一个 taks：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">&#x27;*** task hello doFirst&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;*** task hello doLast&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println <span class="string">&#x27;*** config task hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证生命周期的各个回调方法都被执行，我们在 settings.gradle 中添加各个回调方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradle.addBuildListener(<span class="keyword">new</span> BuildListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> buildStarted(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### gradle.buildStarted&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> settingsEvaluated(Settings settings) &#123;</span><br><span class="line">        println(<span class="string">&quot;### gradle.settingsEvaluated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> projectsLoaded(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### gradle.projectsLoaded&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line">        println(<span class="string">&quot;### gradle.projectsEvaluated&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> buildFinished(BuildResult result) &#123;</span><br><span class="line">        println(<span class="string">&quot;### gradle.buildFinished&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">gradle.afterProject &#123; project,projectState -&gt;</span><br><span class="line">    <span class="keyword">if</span>(projectState.failure)&#123;</span><br><span class="line">        println <span class="string">&quot;### gradld.afterProject &quot;</span>+project+<span class="string">&quot; FAILED&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">&quot;### gradle.afterProject &quot;</span>+project+<span class="string">&quot; succeeded&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">gradle.beforeProject &#123; p -&gt;</span><br><span class="line">    println(<span class="string">&quot;### gradle.beforeProject &quot;</span>+p)</span><br><span class="line">&#125;</span><br><span class="line">gradle.allprojects(<span class="keyword">new</span> Action&lt;Project&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> execute(Project project) &#123;</span><br><span class="line">        project.beforeEvaluate &#123; project</span><br><span class="line">            println <span class="string">&quot;### project.beforeEvaluate &quot;</span>+project</span><br><span class="line">        &#125;</span><br><span class="line">        project.afterEvaluate &#123; pro -&gt;</span><br><span class="line">            println(<span class="string">&quot;### project.afterEvaluate &quot;</span> + pro)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">gradle.taskGraph.addTaskExecutionListener(<span class="keyword">new</span> TaskExecutionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> beforeExecute(Task task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.name.equals(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">            println(<span class="string">&quot;@@@ gradle.taskGraph.beforeTask &quot;</span>+task)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> afterExecute(Task task, TaskState state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.name.equals(<span class="string">&quot;hello&quot;</span>))&#123;</span><br><span class="line">            println(<span class="string">&quot;@@@ gradle.taskGraph.afterTask &quot;</span>+task)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(<span class="keyword">new</span> TaskExecutionGraphListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> graphPopulated(TaskExecutionGraph graph) &#123;</span><br><span class="line">        println(<span class="string">&quot;@@@ gradle.taskGraph.graphPopulated &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">gradle.taskGraph.whenReady &#123; taskGrahp -&gt;</span><br><span class="line">    println(<span class="string">&quot;@@@ gradle.taskGraph.whenReady &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 task hello：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew hello</span><br><span class="line">### gradle.settingsEvaluated</span><br><span class="line">### gradle.projectsLoaded</span><br><span class="line">&gt; Configure project : </span><br><span class="line">### gradle.beforeProject root project &#x27;TestSomething&#x27;</span><br><span class="line">### project.beforeEvaluate root project &#x27;TestSomething&#x27;</span><br><span class="line">### gradle.afterProject root project &#x27;TestSomething&#x27; succeeded</span><br><span class="line">### project.afterEvaluate root project &#x27;TestSomething&#x27;</span><br><span class="line">&gt; Configure project :app </span><br><span class="line">### gradle.beforeProject project &#x27;:app&#x27;</span><br><span class="line">### project.beforeEvaluate project &#x27;:app&#x27;</span><br><span class="line">*** config task hello</span><br><span class="line">### gradle.afterProject project &#x27;:app&#x27; succeeded</span><br><span class="line">### project.afterEvaluate project &#x27;:app&#x27;</span><br><span class="line">&gt; Configure project :common </span><br><span class="line">### gradle.beforeProject project &#x27;:common&#x27;</span><br><span class="line">### project.beforeEvaluate project &#x27;:common&#x27;</span><br><span class="line">### gradle.afterProject project &#x27;:common&#x27; succeeded</span><br><span class="line">### project.afterEvaluate project &#x27;:common&#x27;</span><br><span class="line">### gradle.projectsEvaluated</span><br><span class="line">@@@ gradle.taskGraph.graphPopulated </span><br><span class="line">@@@ gradle.taskGraph.whenReady </span><br><span class="line">&gt; Task :app:hello </span><br><span class="line">@@@ gradle.taskGraph.beforeTask task &#x27;:app:hello&#x27;</span><br><span class="line">*** task hello doFirst</span><br><span class="line">*** task hello doLast</span><br><span class="line">@@@ gradle.taskGraph.afterTask task &#x27;:app:hello&#x27;</span><br><span class="line">BUILD SUCCESSFUL in 1s</span><br><span class="line">1 actionable task: 1 executed</span><br><span class="line">### gradle.buildFinished</span><br></pre></td></tr></table></figure>

<p>因此，生命周期回调的执行顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle.settingsEvaluated-&gt;</span><br><span class="line">gradle.projectsLoaded-&gt;</span><br><span class="line">gradle.beforeProject-&gt;</span><br><span class="line">project.beforeEvaluate-&gt;</span><br><span class="line">gradle.afterProject-&gt;</span><br><span class="line">project.afterEvaluate-&gt;</span><br><span class="line">gradle.projectsEvaluated-&gt;</span><br><span class="line">gradle.taskGraph.graphPopulated-&gt;</span><br><span class="line">gradle.taskGraph.whenReady-&gt;</span><br><span class="line">gradle.buildFinished</span><br></pre></td></tr></table></figure>

<h1 id="Gradle命令行"><a href="#Gradle命令行" class="headerlink" title="Gradle命令行"></a>Gradle命令行</h1><h2 id="多任务调用"><a href="#多任务调用" class="headerlink" title="多任务调用"></a>多任务调用</h2><p>可以以列表的形式在命令行中一次调用多个任务。例如 gradle compile test 命令会依次调用，并且每个任务仅会被调用一次。compile 和 test 任务以及它们的依赖任务，无论它们是否被包含在脚本中：即无论是以命令行的形式定义的任务还是依赖于其它任务都会被调用执行。</p>
<p>下面定义了四个任务。dist 和 test 都依赖于 compile，只用当 compile 被调用之后才会调用 gradle dist test 任务。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task compile &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;compiling source&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">task compileTest(<span class="attr">dependsOn:</span> compile) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;compiling unit tests&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">task test(<span class="attr">dependsOn:</span> [compile, compileTest]) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;running unit tests&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">task dist(<span class="attr">dependsOn:</span> [compile, test]) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&#x27;building the distribution&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\&gt; gradle dist test</span><br><span class="line">:compile</span><br><span class="line">compiling source</span><br><span class="line">:compileTest</span><br><span class="line">compiling unit tests</span><br><span class="line">:test</span><br><span class="line">running unit tests</span><br><span class="line">:dist</span><br><span class="line">building the distribution</span><br></pre></td></tr></table></figure>

<p>由于每个任务仅会被调用一次，所以调用 gradle test test 与调用 gradle test 效果是相同的。</p>
<p>使用gradle dist -x test可排除test任务。</p>
<p>默认情况下只要有任务调用失败 Gradle 就是中断执行。这可能会使调用过程更快，但那些后面隐藏的错误不会被发现。所以你可以使用–continue 在一次调用中尽可能多的发现所有问题。采用了–continue 选项，Gralde会调用每一个任务以及它们依赖的任务。而不是一旦出现错误就会中断执行。所有错误信息都会在最后被列出来。</p>
<h2 id="简化任务名"><a href="#简化任务名" class="headerlink" title="简化任务名"></a>简化任务名</h2><p>当试图调用某个任务的时候，无需输入任务的全名。只需提供足够的可以唯一区分出该任务的字符即可。例如，上面的例子也可以这么写。用 gradle di 来直接调用 dist 任务。</p>
<p>也可以用驼峰命名的任务中每个单词的首字母进行调用。例如，可以执行 gradle compTest或gradle cT 来调用 compileTest 任务。</p>
<p>简化后仍然可以使用 -x 参数。</p>
<h2 id="选择构建位置"><a href="#选择构建位置" class="headerlink" title="选择构建位置"></a>选择构建位置</h2><p>调用 gradle 时，默认情况下总是会构建当前目录下的文件，可以使用-b 参数选择构建的文件，当使用此参数时settings.gradle 将不会生效</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// subdir/myproject.gradle</span></span><br><span class="line"></span><br><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">&quot;using build file &#x27;$buildFile.name&#x27; in &#x27;$buildFile.parentFile.name&#x27;.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\&gt; gradle -q -b subdir/myproject.gradle hello</span><br><span class="line">using build file <span class="string">&#x27;myproject.gradle&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;subdir&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>另外，可以使用 -p 参数来指定构建的目录，例如在多项目构建中可以用 -p 来替代 -b 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&gt; gradle -q -p subdir hello</span><br><span class="line">using build file &#x27;build.gradle&#x27; in &#x27;subdir&#x27;.</span><br></pre></td></tr></table></figure>

<h2 id="获取项目信息"><a href="#获取项目信息" class="headerlink" title="获取项目信息"></a>获取项目信息</h2><ul>
<li>执行 gradle projects 会列出子项目名称列表。</li>
<li>在项目中可以用description属性来指定这些描述信息：</li>
<li>执行 gradle tasks 会列出项目中所有任务，这会显示项目中所有的默认任务以及每个任务的描述。默认情况下，这只会显示那些被分组的任务。可以通过为任务设置 group 属性和 description 来把这些信息展示到结果中。</li>
<li>可以用–all 参数来收集更多任务信息。这会列出项目中所有任务以及任务之间的依赖关系。</li>
</ul>
<h2 id="获取依赖列表"><a href="#获取依赖列表" class="headerlink" title="获取依赖列表"></a>获取依赖列表</h2><p>执行 gradle dependencies 会列出项目的依赖列表，所有依赖会根据任务区分，以树型结构展示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&gt; gradle -q dependencies api:dependencies webapp:dependencies</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">No configurations</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">compile</span><br><span class="line">\--- org.codehaus.groovy:groovy-all:2.2.0</span><br><span class="line">testCompile</span><br><span class="line">\--- junit:junit:4.11</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">Project :webapp - The Web application implementation</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">compile</span><br><span class="line">+--- project :api</span><br><span class="line">|    \--- org.codehaus.groovy:groovy-all:2.2.0</span><br><span class="line">\--- commons-io:commons-io:1.2</span><br><span class="line">testCompile</span><br><span class="line">No dependencies</span><br></pre></td></tr></table></figure>

<h2 id="过滤依赖信息"><a href="#过滤依赖信息" class="headerlink" title="过滤依赖信息"></a>过滤依赖信息</h2><p>可以通过–configuration 参数来查看指定构建任务的依赖情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&gt; gradle -q api:dependencies --configuration testCompile</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">testCompile</span><br><span class="line">\--- junit:junit:4.11</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br></pre></td></tr></table></figure>

<h2 id="查看特定依赖"><a href="#查看特定依赖" class="headerlink" title="查看特定依赖"></a>查看特定依赖</h2><p>执行 Running gradle dependencyInsight 可以查看指定的依赖情况。如下例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&gt; gradle -q webapp:dependencyInsight --dependency groovy --configuration compile</span><br><span class="line">org.codehaus.groovy:groovy-all:2.2.0</span><br><span class="line">\--- project :api</span><br><span class="line">     \--- compile</span><br></pre></td></tr></table></figure>

<p>dependencyInsight 任务是’Help’任务组中的一个。这项任务需要进行配置才可以。如果用了 Java 相关的插件，那么 dependencyInsight 任务已经预先被配置到’Compile’下了。只需要通过’–dependency’参数来制定所需查看的依赖即可。如果不想用默认配置的参数项可以通过 ‘–configuration’ 参数来进行指定。</p>
<h2 id="获取项目属性列表"><a href="#获取项目属性列表" class="headerlink" title="获取项目属性列表"></a>获取项目属性列表</h2><p>执行 gradle properties 可以获取项目所有属性列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&gt; gradle -q api:properties</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">\------------------------------------------------------------</span><br><span class="line">allprojects: [project &#x27;:api&#x27;]</span><br><span class="line">ant: org.gradle.api.internal.project.DefaultAntBuilder@12345</span><br><span class="line">antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345</span><br><span class="line">artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler@12345</span><br><span class="line">asDynamicObject: org.gradle.api.internal.ExtensibleDynamicObject@12345</span><br><span class="line">buildDir: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build</span><br><span class="line">buildFile: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build.gradle</span><br></pre></td></tr></table></figure>

<h2 id="构建日志"><a href="#构建日志" class="headerlink" title="构建日志"></a>构建日志</h2><p>–profile 参数可以收集一些构建期间的信息并保存到 build/reports/profile 目录下并且以构建时间命名这些文件。</p>
<p>如果采用了 buildSrc，那么在 buildSrc/build 下同时也会生成一份日志记录记录。</p>
<h2 id="Try-Run"><a href="#Try-Run" class="headerlink" title="Try Run"></a>Try Run</h2><p>有时可能只想知道某个任务在一个任务集中按顺序执行的结果，但并不想实际执行这些任务。那么可以用-m 参数。例如 gradle -m clean compile 会调用 clean 和 compile，这与 tasks 可以形成互补，让你知道哪些任务可以用于执行。</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>Gradle本身只是一个框架，它的核心部分在构建过程中起的作用实际上很小。真正起作用的步骤来自于插件，比如编译Java代码的功能就是由“java”插件提供。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Gradle的插件分为两种类型：脚本插件(script plugins)和二进制插件(binary plugins)。</p>
<ul>
<li>脚本插件就是额外的构建脚本，脚本插件通常用来对构建过程进行深度配置，同样遵循声明式的思想。脚本插件常常作为另一个脚本文件（即*.gradle）文件被放置在项目目录中，以本地文件的形式应用插件。虽然脚本插件也可以放置在云端，比如说共享仓库jcenter，但不常用，一般共享的插件都是二进制插件。</li>
<li>二进制插件就是实现了Plugin接口的类，可以用java、kotlin和groovy编写，更容易进行测试，还可以被打包成jar包共享出去。</li>
</ul>
<p>一个插件项目最开始写的时候通常都是以脚本插件的形式，因为它们更容易编写，当项目变得更有价值之后再被迁移成二进制插件，这样更容易测试以及共享。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 脚本插件</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;other.gradle&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> pluginName</span><br></pre></td></tr></table></figure>

<p>Gradle的插件根据是否内置又分为核心插件和社区插件，核心插件是Gradle必要的插件（如java插件），核心插件随着Gradle安装已经解析好了，只需要应用即可；社区插件是共享在社区上的插件，在需要时才被解析到本地。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li>脚本插件：可以直接在build.gradle中编写一个实现了org.gradle.api.plugins接口的类，这个类就是一个插件</li>
<li>buildSrc：Gradle提供了一种在现有项目中编写二进制插件的方法，依旧遵循声明式的思想。二进制插件可以用Java、Kotlin、Groovy多种语言编写，例如使用的是Groovy语言，那么就创建目录<code>rootProjectDir/buildSrc/src/main/groovy</code>，如果是kotlin则为<code>.../kotlin</code>。Gradle会自动编译这些目录下的插件，并且将它们解析，使得在项目的所有构建脚本中都可以应用这些目录下的插件。</li>
<li>独立项目：可以为插件单独建立一个项目，这个项目可以被打包成一个jar包，可以实现更好的复用，还可以分享到在线仓库成为社区插件，给别的项目使用。</li>
</ol>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><h3 id="传统apply语法"><a href="#传统apply语法" class="headerlink" title="传统apply语法"></a>传统apply语法</h3><p>每个插件都有一个id，可以通过指定插件的id的方式来应用插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//build.gradle</span><br><span class="line">apply plugin: &#x27;java&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以直接指定插件的实现类的类名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//build.gradle</span><br><span class="line">apply plugin: JavaPlugin</span><br></pre></td></tr></table></figure>

<p>对于内置插件，我们可以直接通过上述的apply语法应用插件，指定类名时也不需要前缀(org.gradle.api.plugins)以及.class后缀。</p>
<p>但对于社区插件，我们还需要先解析插件。解析插件使用的是buildscript{}语法块，语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//build.gradle</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &#x27;com.jfrog.bintray&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>repositories{}语法块，用于指定仓库，有以下常用选项：<ul>
<li>mavenLocal()：本地Maven仓库（ ${user.home}/.m2/repository ）</li>
<li>mavenCentral()：中央Maven仓库（ <a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> ）</li>
<li>maven { url ‘https://…’ }：可用于Maven私服、镜像服务器等</li>
<li>ivy {url “../local-repo”}：本地的ivy仓库</li>
<li>ivy {url “<a target="_blank" rel="noopener" href="http://repo.mycompany.com/repo&quot;%7D%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%9A%84ivy%E4%BB%93%E5%BA%93">http://repo.mycompany.com/repo&quot;}：远程的ivy仓库</a></li>
<li>google()：google仓库（<a target="_blank" rel="noopener" href="https://maven.google.com/">https://maven.google.com）</a>/)</li>
</ul>
</li>
<li>dependencies{}语法块，用于指定要使用的插件，由classpath关键字指定，格式为：classpath ‘group:name:version’</li>
</ul>
<h3 id="plugins-DSL语法"><a href="#plugins-DSL语法" class="headerlink" title="plugins DSL语法"></a>plugins DSL语法</h3><p>核心插件只需要指定插件名：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//build.gradle.kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>社区插件还需要指定版本：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.jfrog.bintray&#x27;</span> version <span class="string">&#x27;0.4.1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//build.gradle.kts</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.jfrog.bintray&quot;</span>) version <span class="string">&quot;0.4.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pluginManagement"><a href="#pluginManagement" class="headerlink" title="pluginManagement"></a>pluginManagement</h2><p>pluginManagement语法块是专门用于管理整个项目插件的，只能出现在settings.gradle文件或”初始化脚本“中，并且在settings.gradle文件中pluginManagement必须是文件中的第一个块。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">pluginManagement &#123;</span><br><span class="line">    <span class="comment">// 用于统一指定整个项目使用的某个插件的版本</span></span><br><span class="line">    plugins &#123;</span><br><span class="line">        id <span class="string">&#x27;org.gradle.sample.hello&#x27;</span> version <span class="string">&quot;$&#123;helloPluginVersion&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&#x27;../maven-repo&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">        ivy &#123;</span><br><span class="line">            url <span class="string">&#x27;../ivy-repo&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init.gradle</span></span><br><span class="line">settingsEvaluated &#123; settings -&gt;</span><br><span class="line">    settings.pluginManagement &#123;</span><br><span class="line">        plugins &#123;</span><br><span class="line">        &#125;	</span><br><span class="line">        resolutionStrategy &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        repositories &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在根目录下的settings.gradle指定了插件的版本后，在build.gradle中只需要指定插件的id即可，插件版本配置在gradle.properties中。</p>
<h1 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h1><h2 id="方法一：build-gradle"><a href="#方法一：build-gradle" class="headerlink" title="方法一：build.gradle"></a>方法一：build.gradle</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> CustomPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义插件：实现Plugin类接口，重写apply方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        project.task(<span class="string">&#x27;CustomPluginTask&#x27;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">&quot;大家好,我是一个自定义插件，在这里写下你的具体功能&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：buildSrc"><a href="#方法二：buildSrc" class="headerlink" title="方法二：buildSrc"></a>方法二：buildSrc</h2><p>在现有项目下新建buildSrc目录，其中目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  main/</span><br><span class="line">    groovy/</span><br><span class="line">build.gradle</span><br></pre></td></tr></table></figure>

<p>在groovy/目录下新建一个包(<code>com.hearing.plugin</code>)，包内新建一个groovy文件，这里起名为PluginImpl.groovy，内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PluginImpl.groovy</span></span><br><span class="line"><span class="keyword">package</span> com.hearing.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluginImpl</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        project.task(<span class="string">&#x27;testTask&#x27;</span>) &lt;&lt; &#123;</span><br><span class="line">            println <span class="string">&quot;Hello gradle plugin&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>build.gradle内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>apply plugin: com.hearing.plugin.PluginImpl</code>即可引用该插件。</p>
<h2 id="方法三：独立项目"><a href="#方法三：独立项目" class="headerlink" title="方法三：独立项目"></a>方法三：独立项目</h2><p>如果想要分享给其他人或者自己用，可以在一个独立的项目中编写插件，这个项目会生成一个包含插件类的JAR文件。</p>
<p>新建一个项目，在项目内部新建一个module(module_plugin)，其目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">  main/</span><br><span class="line">    groovy/</span><br><span class="line">    resources/</span><br><span class="line">build.gradle</span><br></pre></td></tr></table></figure>

<ul>
<li>在groovy/目录下新建一个包(<code>com.hearing.plugin</code>)，包内新建一个groovy文件，这里起名为PluginImpl.groovy。</li>
<li>在resources目录下新建一个META-INF文件夹，在META-INF文件夹下新建一个gradle-plugins文件夹，在gradle-plugins里创建一个.properties文件，文件名是上步骤里的那个包名<code>com.hearing.plugin.properties</code>（也可以取其它名，该properties文件的文件名是就是插件名）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// com.hearing.plugin.properties</span><br><span class="line">implementation-class=com.hearing.plugin.PluginImpl</span><br></pre></td></tr></table></figure>

<p>build.gradle内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//设置插件的GAV参数</span></span><br><span class="line">            pom.groupId = <span class="string">&#x27;com.hearing.plugin&#x27;</span> <span class="comment">//你的包名</span></span><br><span class="line">            pom.artifactId = <span class="string">&#x27;myPlugin&#x27;</span></span><br><span class="line">            pom.version = <span class="string">&#x27;1.1.9&#x27;</span>   <span class="comment">//版本号</span></span><br><span class="line">            repository(<span class="attr">url:</span> uri(<span class="string">&#x27;../repo&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行uploadArchives可以得到jar包，在其它项目里可以引用它：</p>
<ol>
<li><p>项目build.gradle文件</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123;<span class="comment">//本地Maven仓库地址</span></span><br><span class="line">            url uri(<span class="string">&#x27;../repo&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">        classpath <span class="string">&#x27;com.hearing.plugin:myPlugin:1.1.9&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>module的build.gradle文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.hearing.plugin&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Groovy插件"><a href="#Groovy插件" class="headerlink" title="Groovy插件"></a>Groovy插件</h1><p>添加groovy插件后可以在项目中同时包含java和groovy源文件，源码包含在<code>src/main/groovy</code>目录下。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementtation <span class="string">&#x27;org.codehaus.groovy:groovy-all:2.2.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 gradle build 将会对项目进行编译，测试和打成 jar 包。</p>
<h1 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;java&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="项目布局"><a href="#项目布局" class="headerlink" title="项目布局"></a>项目布局</h2><p>默认项目布局：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>src/main/java</td>
<td>产品的Java源代码</td>
</tr>
<tr>
<td>src/main/resources</td>
<td>产品的资源</td>
</tr>
<tr>
<td>src/test/java</td>
<td>Java 测试源代码</td>
</tr>
<tr>
<td>src/test/resources</td>
<td>测试资源</td>
</tr>
<tr>
<td>sourceSet/java</td>
<td>给定的源集的Java源代码</td>
</tr>
<tr>
<td>sourceSet/resources</td>
<td>给定的源集的资源</td>
</tr>
</tbody></table>
<p>更改项目布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java &#123;</span><br><span class="line">            srcDir &#x27;src/java&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir &#x27;src/resources&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><ul>
<li>build：当执行 gradle build 时，Gralde 会编译并执行单元测试，并且将 src/main/* 下面 class 和资源文件打包。</li>
<li>clean：删除 build 目录以及所有构建完成的文件。</li>
<li>assemble：编译并打包 jar 文件，但不会执行单元测试。一些其他插件可能会增强这个任务的功能。例如，如果采用了 War 插件，这个任务便会为你的项目打出 War 包。</li>
<li>check：编译并测试代码。一些其他插件也可能会增强这个任务的功能。例如，如果采用了 Code-quality 插件，这个任务会额外执行 Checkstyle。</li>
</ul>
<h2 id="外部依赖-1"><a href="#外部依赖-1" class="headerlink" title="外部依赖"></a>外部依赖</h2><ul>
<li>implementation：会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk等），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。</li>
<li>api：会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现。</li>
<li>compileOnly：Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。</li>
<li>runtimeOnly：gradle添加依赖只打包到APK/Jar/aar，运行时使用，但不会添加到编译路径。</li>
<li>annotationProcessor：用于注解处理器的依赖配置。</li>
<li>testImplementation</li>
<li>debugImplementation</li>
<li>releaseImplementation</li>
</ul>
<p>classpath、implementation、api 的区别：</p>
<ul>
<li>classpath：一般是添加buildscript本身需要运行的东西，buildScript是用来加载gradle脚本自身需要使用的资源，可以声明的资源包括依赖项、第三方插件、maven仓库地址等。某种意义上来说，classpath声明的依赖，不会编译到最终的apk里面。</li>
<li>implementation、api ：在模块中的build.gradle中，给dependencies中添加的使应用程序所需要的依赖包，也就是项目运行所需要的东西。</li>
</ul>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;java&#x27;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation group: &#x27;org.hibernate&#x27;, name: &#x27;hibernate-core&#x27;, version: &#x27;3.6.7.Final&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源集"><a href="#源集" class="headerlink" title="源集"></a>源集</h2><p>可以使用sourceSets属性访问项目的源集，另外还有一个<code>sourceSets&#123;&#125;</code>的脚本块，可以传入一个闭包来配置源集容器：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Various ways to access the main source set</span></span><br><span class="line">println sourceSets.main.output.classesDir</span><br><span class="line">println sourceSets[<span class="string">&#x27;main&#x27;</span>].output.classesDir</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    println main.output.classesDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        println output.classesDir</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over the source sets</span></span><br><span class="line">sourceSets.all &#123;</span><br><span class="line">    println name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以创建一个名为api的source set来存放程序中的接口类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">   api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上配置也可以与main放在一起。在默认情况下，该api所对应的Java源文件目录被Gradle设置为<code>$&#123;path-to-project&#125;/src/api/java</code>，而资源文件目录则被设置成了<code>$&#123;path-to-project&#125;/src/api/resources</code>。</p>
<p>源集中的属性如下图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202208131028454.png" alt="源集属性"></p>
<h2 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h2><h3 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h3><p>缺省时jar.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">    baseName = ‘myProjectName’</span><br><span class="line">    version   =  ‘2.0’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="war"><a href="#war" class="headerlink" title="war"></a>war</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &quot;war&quot;</span><br><span class="line"></span><br><span class="line">war &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可执行jar"><a href="#可执行jar" class="headerlink" title="可执行jar"></a>可执行jar</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;java&#x27;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes &#x27;Main-Class&#x27;: &#x27;com.hearing.Hello&#x27;</span><br><span class="line">        attributes &#x27;Class-Path&#x27;: &#x27;my-lib.jar&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种打包方式不会将依赖的jar包打包到一起.</p>
<h3 id="完整构建脚本"><a href="#完整构建脚本" class="headerlink" title="完整构建脚本"></a>完整构建脚本</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.5</span></span><br><span class="line">version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">&#x27;Implementation-Title&#x27;</span>: <span class="string">&#x27;Gradle Quickstart&#x27;</span>, <span class="string">&#x27;Implementation-Version&#x27;</span>: version</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="attr">group:</span> <span class="string">&#x27;commons-collections&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;commons-collections&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    systemProperties <span class="string">&#x27;property&#x27;</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">       flatDir &#123;</span><br><span class="line">           dirs <span class="string">&#x27;repos&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lvxueyang.vip/post/28a096df.html">http://lvxueyang.vip/post/28a096df.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lvxueyang.vip" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/">构建工具</a><a class="post-meta__tags" href="/tags/gradle/">gradle</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/50ff5478.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Groovy</div></div></a></div><div class="next-post pull-right"><a href="/post/b0f534d5.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ElasticSearch基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/50ff5478.html" title="Groovy"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Groovy</div></div></a></div><div><a href="/post/7273cdc.html" title="Maven"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Maven</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">构建基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">创建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gradle-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">Gradle 图形用户界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conventions"><span class="toc-number">2.3.</span> <span class="toc-text">Conventions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-API"><span class="toc-number">2.4.</span> <span class="toc-text">Project API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.</span> <span class="toc-text">属性配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">2.6.</span> <span class="toc-text">配置与执行阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">2.7.</span> <span class="toc-text">外部依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC"><span class="toc-number">2.8.</span> <span class="toc-text">外部构建脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-Daemon"><span class="toc-number">2.9.</span> <span class="toc-text">守护进程(Daemon)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Task"><span class="toc-number">3.</span> <span class="toc-text">Task</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAtask"><span class="toc-number">3.1.</span> <span class="toc-text">创建task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Action"><span class="toc-number">3.2.</span> <span class="toc-text">Action</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Groovy%E4%B8%8EKotlin"><span class="toc-number">3.3.</span> <span class="toc-text">Groovy与Kotlin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task%E4%BE%9D%E8%B5%96"><span class="toc-number">3.5.</span> <span class="toc-text">task依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAtask"><span class="toc-number">3.6.</span> <span class="toc-text">动态创建task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task%E6%93%8D%E7%BA%B5"><span class="toc-number">3.7.</span> <span class="toc-text">Task操纵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">3.7.1.</span> <span class="toc-text">增加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BB%BB%E5%8A%A1%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.7.2.</span> <span class="toc-text">增加任务行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">定义默认任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Extension"><span class="toc-number">4.</span> <span class="toc-text">Extension</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ExtensionContainer"><span class="toc-number">4.1.</span> <span class="toc-text">ExtensionContainer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NamedDomainObjectContainer"><span class="toc-number">4.2.</span> <span class="toc-text">NamedDomainObjectContainer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA"><span class="toc-number">5.</span> <span class="toc-text">多项目构建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">公共配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96"><span class="toc-number">5.3.</span> <span class="toc-text">工程依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%93%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83"><span class="toc-number">7.</span> <span class="toc-text">打包发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gradle%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">8.</span> <span class="toc-text">Gradle生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E5%90%AC"><span class="toc-number">8.2.</span> <span class="toc-text">生命周期监听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeEvaluate"><span class="toc-number">8.2.1.</span> <span class="toc-text">beforeEvaluate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterEvaluate"><span class="toc-number">8.2.2.</span> <span class="toc-text">afterEvaluate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterProject"><span class="toc-number">8.2.3.</span> <span class="toc-text">afterProject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeProject"><span class="toc-number">8.2.4.</span> <span class="toc-text">beforeProject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buildFinished"><span class="toc-number">8.2.5.</span> <span class="toc-text">buildFinished</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#projectsEvaluated"><span class="toc-number">8.2.6.</span> <span class="toc-text">projectsEvaluated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#projectsLoaded"><span class="toc-number">8.2.7.</span> <span class="toc-text">projectsLoaded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settingsEvaluated"><span class="toc-number">8.2.8.</span> <span class="toc-text">settingsEvaluated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addProjectEvaluationListener"><span class="toc-number">8.2.9.</span> <span class="toc-text">addProjectEvaluationListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addListener"><span class="toc-number">8.2.10.</span> <span class="toc-text">addListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addBuildListener"><span class="toc-number">8.2.11.</span> <span class="toc-text">addBuildListener</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskExecutionGraph"><span class="toc-number">8.3.</span> <span class="toc-text">TaskExecutionGraph</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addTaskExecutionGraphListener"><span class="toc-number">8.3.1.</span> <span class="toc-text">addTaskExecutionGraphListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addTaskExecutionListener"><span class="toc-number">8.3.2.</span> <span class="toc-text">addTaskExecutionListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afterTask"><span class="toc-number">8.3.3.</span> <span class="toc-text">afterTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeTask"><span class="toc-number">8.3.4.</span> <span class="toc-text">beforeTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#whenReady"><span class="toc-number">8.3.5.</span> <span class="toc-text">whenReady</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">生命周期顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gradle%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">9.</span> <span class="toc-text">Gradle命令行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">多任务调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E4%BB%BB%E5%8A%A1%E5%90%8D"><span class="toc-number">9.2.</span> <span class="toc-text">简化任务名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%9E%84%E5%BB%BA%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.3.</span> <span class="toc-text">选择构建位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">9.4.</span> <span class="toc-text">获取项目信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96%E5%88%97%E8%A1%A8"><span class="toc-number">9.5.</span> <span class="toc-text">获取依赖列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF"><span class="toc-number">9.6.</span> <span class="toc-text">过滤依赖信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E4%BE%9D%E8%B5%96"><span class="toc-number">9.7.</span> <span class="toc-text">查看特定依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8"><span class="toc-number">9.8.</span> <span class="toc-text">获取项目属性列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%97%A5%E5%BF%97"><span class="toc-number">9.9.</span> <span class="toc-text">构建日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Try-Run"><span class="toc-number">9.10.</span> <span class="toc-text">Try Run</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.3.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply"><span class="toc-number">10.4.</span> <span class="toc-text">apply</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Fapply%E8%AF%AD%E6%B3%95"><span class="toc-number">10.4.1.</span> <span class="toc-text">传统apply语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#plugins-DSL%E8%AF%AD%E6%B3%95"><span class="toc-number">10.4.2.</span> <span class="toc-text">plugins DSL语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pluginManagement"><span class="toc-number">10.5.</span> <span class="toc-text">pluginManagement</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">自定义插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9Abuild-gradle"><span class="toc-number">11.1.</span> <span class="toc-text">方法一：build.gradle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AbuildSrc"><span class="toc-number">11.2.</span> <span class="toc-text">方法二：buildSrc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E7%8B%AC%E7%AB%8B%E9%A1%B9%E7%9B%AE"><span class="toc-number">11.3.</span> <span class="toc-text">方法三：独立项目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Groovy%E6%8F%92%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">Groovy插件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%8F%92%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">Java插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80"><span class="toc-number">13.1.</span> <span class="toc-text">项目布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tasks"><span class="toc-number">13.2.</span> <span class="toc-text">Tasks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96-1"><span class="toc-number">13.3.</span> <span class="toc-text">外部依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E9%9B%86"><span class="toc-number">13.4.</span> <span class="toc-text">源集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85"><span class="toc-number">13.5.</span> <span class="toc-text">项目打包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jar"><span class="toc-number">13.5.1.</span> <span class="toc-text">jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#war"><span class="toc-number">13.5.2.</span> <span class="toc-text">war</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8Cjar"><span class="toc-number">13.5.3.</span> <span class="toc-text">可执行jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC"><span class="toc-number">13.5.4.</span> <span class="toc-text">完整构建脚本</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>