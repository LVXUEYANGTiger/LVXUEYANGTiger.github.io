<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dubbo基础知识点 | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Dubbo"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Dubbo 架构简介下图展示了 Dubbo 核心架构：  Dubbo 核心架构图  Registry：注册中心。 负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时 与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册 中心会立即推送相关事件通知 Consumer。 Provider：服务提供者。 在它启动的">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo基础知识点">
<meta property="og:url" content="https://lvxueyangtiger.github.io/post/51a6cf8f.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="Dubbo 架构简介下图展示了 Dubbo 核心架构：  Dubbo 核心架构图  Registry：注册中心。 负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时 与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册 中心会立即推送相关事件通知 Consumer。 Provider：服务提供者。 在它启动的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.205Z">
<meta property="article:modified_time" content="2022-11-27T09:16:30.838Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://lvxueyangtiger.github.io/post/51a6cf8f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dubbo基础知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Dubbo基础知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.205Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:30.838Z" title="更新于 2022-11-27 17:16:30">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RPC/">RPC</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RPC/Dubbo/">Dubbo</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Dubbo基础知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Dubbo-架构简介"><a href="#Dubbo-架构简介" class="headerlink" title="Dubbo 架构简介"></a>Dubbo 架构简介</h2><p>下图展示了 Dubbo 核心架构：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050817575.png" alt="image-20220305081752515"></p>
<p>Dubbo 核心架构图</p>
<ul>
<li>Registry：注册中心。 负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时 与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册 中心会立即推送相关事件通知 Consumer。</li>
<li>Provider：服务提供者。 在它启动的时候，会向 Registry 进行注册操作，将自己服务的地址和相 关配置信息封装成 URL 添加到 ZooKeeper 中。 </li>
<li>Consumer：服务消费者。 在它启动的时候，会向 Registry 进行订阅操作。订阅操作会从 ZooKeeper 中获取 Provider 注册的 URL，并在 ZooKeeper 中添加相应的监听器。获取到 Provider URL 之后，Consumer 会根据负载均衡算法从多个 Provider 中选择一个 Provider 并与 其建立连接，最后发起对 Provider 的 RPC 调用。 如果 Provider URL 发生变更，Consumer 将会 通过之前订阅过程中在注册中心添加的监听器，获取到最新的 Provider URL 信息，进行相应的调 整，比如断开与宕机 Provider 的连接，并与新的 Provider 建立连接。Consumer 与 Provider 建 立的是长连接，且 Consumer 会缓存 Provider 信息，所以一旦连接建立，即使注册中心宕机，也 不会影响已运行的 Provider 和 Consumer。</li>
<li>Monitor：监控中心。 用于统计服务的调用次数和调用时间。Provider 和 Consumer 在运行过程 中，会在内存中统计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。监控中心在 上面的架构图中并不是必要角色，监控中心宕机不会影响 Provider、Consumer 以及 Registry 的 功能，只会丢失监控数据而已。</li>
</ul>
<h2 id="搭建-Dubbo-源码环境"><a href="#搭建-Dubbo-源码环境" class="headerlink" title="搭建 Dubbo 源码环境"></a>搭建 Dubbo 源码环境</h2><p><a target="_blank" rel="noopener" href="https://github.com/apache/dubboFork">https://github.com/apache/dubboFork</a> 到自己的仓库，直接执行下面的命令去下载代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xxxxxxxx/dubbo.git</span><br></pre></td></tr></table></figure>

<p>然后切换分支，因为目前最新的是 Dubbo 2.7.7 版本，所以这里我们就用这个新版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b dubbo-2.7.7 dubbo-2.7.7</span><br></pre></td></tr></table></figure>

<p>接下来，执行 mvn 命令进行编译：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>最后，执行下面的命令转换成 IDEA 项目： 然后，在 IDEA 中导入源码，因为这个导入过程中会下载所需的依赖包，所以会耗费点时间。</p>
<h2 id="Dubbo-源码核心模块"><a href="#Dubbo-源码核心模块" class="headerlink" title="Dubbo 源码核心模块"></a>Dubbo 源码核心模块</h2><p>在 IDEA 成功导入 Dubbo 源码之后，你看到的项目结构如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050820253.png" alt="image-20220305082035196"></p>
<p>下面我们就来简单介绍一下这些核心模块的功能</p>
<ul>
<li><p>dubbo-common 模块： Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，例如 Dubbo SPI 实现、时间轮实现、动态编译器等。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050837501.png" alt="image-20220305083728437"></p>
</li>
<li><p>dubbo-remoting 模块： Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通 信。在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件 进行实现，例如，dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050837469.png" alt="image-20220305083757431"></p>
</li>
<li><p>dubbo-rpc 模块： Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具 体协议的实现，例如，dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubboremoting-netty4 等 dubbo-remoting 子模块。 dubbo-rpc 模块的实现中只包含一对一的调用， 不关心集群的相关内容。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050838648.png" alt="image-20220305083816604"></p>
</li>
<li><p>dubbo-cluster 模块： Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集 群相关的功能，最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调 用一个 Provider 那样调用 Provider 集群了。</p>
</li>
<li><p>dubbo-registry 模块： Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能 力。其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的 具体实现，例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050838345.png" alt="image-20220305083858316"></p>
</li>
<li><p>dubbo-monitor 模块： Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调 用链跟踪的服务。</p>
</li>
<li><p>dubbo-config 模块： Dubbo对外暴露的配置都是由该模块进行解析的。例如，dubbo-config-api 子模块负责处理 API 方式使用时的相关配置，dubbo-config-spring 子模块负责处理与 Spring集成使用时的相关配置方式。有了 dubbo-config模块，用户只需要了解Dubbo配置的规则即可，无须了解Dubbo 内部的细节。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050840326.png" alt="image-20220305084017281"></p>
</li>
<li><p>dubbo-metadata 模块： Dubbo 的元数据模块 dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实 现。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050839931.png" alt="image-20220305083954883"></p>
</li>
<li><p>dubbo-configcenter 模块： Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的 存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。</p>
<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050839812.png"></p>
</li>
</ul>
<h2 id="Dubbo-源码中的-Demo-示例"><a href="#Dubbo-源码中的-Demo-示例" class="headerlink" title="Dubbo 源码中的 Demo 示例"></a>Dubbo 源码中的 Demo 示例</h2><p>在 Dubbo 源码中我们可以看到一个 dubbo-demo 模块，共包括三个非常基础 的 Dubbo 示例项目，分 别是： 使用 XML 配置的 Demo 示例、使用注解配置的 Demo 示例 以及 直接使用 API 的 Demo 示例 。下面我们将从这三个示例的角度，简单介绍 Dubbo 的基本使用。同时，这三个项目也将作为后续 Debug Dubbo 源码的入口，我们会根据需要在其之上进行修改 。不过在这儿之前，你需要先启动 ZooKeeper 作为注册中心，然后编写一个业务接口作为 Provider 和 Consumer 的公约。</p>
<h3 id="启动-ZooKeeper"><a href="#启动-ZooKeeper" class="headerlink" title="启动 ZooKeeper"></a>启动 ZooKeeper</h3><p>在前面 Dubbo 的架构图中，你可以看到 Provider 的地址以及配置信息是通过注册中心传递给 Consumer 的。 Dubbo 支持的注册中心尽管有很多， 但在生产环境中， 基本都是用 ZooKeeper 作为 注册中心 。因此，在调试 Dubbo 源码时，自然需要在本地启动 ZooKeeper。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050845023.png" alt="image-20220305084515953"></p>
<h3 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h3><p>在使用 Dubbo 之前，你还需要一个业务接口，这个业务接口可以认为是 Dubbo Provider 和 Dubbo Consumer 的公约，反映出很多信息： </p>
<ul>
<li>Provider ，如何提供服务、提供的服务名称是什么、需要接收什么参数、需要返回什么响应； </li>
<li>Consumer ，如何使用服务、使用的服务名称是什么、需要传入什么参数、会得到什么响应。 </li>
</ul>
<p>dubbo-demo-interface 模块就是定义业务接口的地方，如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050847561.png" alt="image-20220305084707516"></p>
<p>其中，DemoService 接口中定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Demo-1：基于-XML-配置"><a href="#Demo-1：基于-XML-配置" class="headerlink" title="Demo 1：基于 XML 配置"></a>Demo 1：基于 XML 配置</h3><p>在 dubbo-demo 模块下的 dubbo-demo-xml 模块，提供了基于 Spring XML 的 Provider 和 Consumer。 我们先来看 dubbo-demo-xml-provider 模块，其结构如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050849680.png" alt="image-20220305084945633"></p>
<p>在其 pom.xml 中除了一堆 dubbo 的依赖之外，还有依赖了 DemoService 这个公共接口：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-demo-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DemoServiceImpl 实现了 DemoService 接口，sayHello() 方法直接返回一个字符串，sayHelloAsync() 方法返回一个 CompletableFuture 对象。 在 dubbo-provider.xml 配置文件中，会将 DemoServiceImpl 配置成一个 Spring Bean，并作为 DemoService 服务暴露出去：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.dubbo.demo.provider.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/</span></span><br></pre></td></tr></table></figure>

<p>还有就是指定注册中心地址（就是前面 ZooKeeper 的地址），这样 Dubbo 才能把暴露的 DemoService 服务注册到 ZooKeeper 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，在 Application 中写个 main() 方法，指定 Spring 配置文件并启动 ClassPathXmlApplicationContext 即可。 接下来再看 dubbo-demo-xml-consumer 模块，结构如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050854529.png" alt="image-20220305085412487"></p>
<p>在 pom.xml 中同样依赖了 dubbo-demo-interface 这个公共模块。</p>
<p>在 dubbo-consumer.xml 配置文件中，会指定注册中心地址（就是前面 ZooKeeper 的地址），这样 Dubbo 才能从 ZooKeeper 中拉取到 Provider 暴露的服务列表信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>还会使用 dubbo:reference 引入 DemoService 服务，后面可以作为 Spring Bean 使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;org.apache.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，在 Application 中写个 main() 方法，指定 Spring 配置文件并启动 ClassPathXmlApplicationContext 之后，就可以远程调用 Provider 端的 DemoService 的 sayHello() 方法了。</p>
<h3 id="Demo-2：基于注解配置"><a href="#Demo-2：基于注解配置" class="headerlink" title="Demo 2：基于注解配置"></a>Demo 2：基于注解配置</h3><p>dubbo-demo-annotation 模块是基于 Spring 注解配置的示例，无非就是将 XML 的那些配置信息转移 到了注解上。 </p>
<p>我们先来看 dubbo-demo-annotation-provider 这个示例模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration.class);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.demo.provider&quot;)</span></span><br><span class="line">    <span class="meta">@PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">            registryConfig.setAddress(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> registryConfig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，同样会有一个 DemoServiceImpl 实现了 DemoService 接口，并且在 org.apache.dubbo.demo.provider 目录下，能被扫描到，暴露成 Dubbo 服务。 </p>
<p>接着再来看 dubbo-demo-annotation-consumer 模块，其中 Application 中也是通过 AnnotationConfigApplicationContext 初始化 Spring 容器，也会扫描指定目录下的 Bean，会扫到 DemoServiceComponent 这个 Bean，其中就通过 @Reference 注解注入 Dubbo 服务相关的 Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;demoServiceComponent&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceComponent</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Demo-3：基于-API-配置"><a href="#Demo-3：基于-API-配置" class="headerlink" title="Demo 3：基于 API 配置"></a>Demo 3：基于 API 配置</h3><p>在有的场景中，不能依赖于 Spring 框架，只能使用 API 来构建 Dubbo Provider 和 Consumer，比较 典型的一种场景就是在写 SDK 的时候。 先来看 dubbo-demo-api-provider 模块，其中 Application.main() 方法是入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClassic(args)) &#123;</span><br><span class="line">            startWithExport();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startWithBootstrap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isClassic</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.length &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;classic&quot;</span>.equalsIgnoreCase(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startWithBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceConfig&lt;DemoServiceImpl&gt; service = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">        service.setInterface(DemoService.class);</span><br><span class="line">        service.setRef(<span class="keyword">new</span> DemoServiceImpl());</span><br><span class="line"></span><br><span class="line">        DubboBootstrap bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.application(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-provider&quot;</span>))</span><br><span class="line">                .registry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>))</span><br><span class="line">                .service(service)</span><br><span class="line">                .start()</span><br><span class="line">                .await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startWithExport</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ServiceConfig&lt;DemoServiceImpl&gt; service = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">        service.setInterface(DemoService.class);</span><br><span class="line">        service.setRef(<span class="keyword">new</span> DemoServiceImpl());</span><br><span class="line">        service.setApplication(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-provider&quot;</span>));</span><br><span class="line">        service.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">        service.export();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;dubbo service started&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，同样会有一个 DemoServiceImpl 实现了 DemoService 接口，并且在 org.apache.dubbo.demo.provider 目录下，能被扫描到，暴露成 Dubbo 服务。 再来看 dubbo-demo-api-consumer 模块，其中 Application 中包含一个普通的 main() 方法入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClassic(args)) &#123;</span><br><span class="line">            runWithRefer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runWithBootstrap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isClassic</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.length &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;classic&quot;</span>.equalsIgnoreCase(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceConfig&lt;DemoService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">        reference.setInterface(DemoService.class);</span><br><span class="line">        reference.setGeneric(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DubboBootstrap bootstrap = DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.application(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-consumer&quot;</span>))</span><br><span class="line">                .registry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>))</span><br><span class="line">                .reference(reference)</span><br><span class="line">                .start();</span><br><span class="line"></span><br><span class="line">        DemoService demoService = ReferenceConfigCache.getCache().get(reference);</span><br><span class="line">        String message = demoService.sayHello(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        System.out.println(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// generic invoke</span></span><br><span class="line">        GenericService genericService = (GenericService) demoService;</span><br><span class="line">        Object genericInvokeResult = genericService.$invoke(<span class="string">&quot;sayHello&quot;</span>, <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;dubbo generic invoke&quot;</span> &#125;);</span><br><span class="line">        System.out.println(genericInvokeResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithRefer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceConfig&lt;DemoService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">        reference.setApplication(<span class="keyword">new</span> ApplicationConfig(<span class="string">&quot;dubbo-demo-api-consumer&quot;</span>));</span><br><span class="line">        reference.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">        reference.setInterface(DemoService.class);</span><br><span class="line">        DemoService service = reference.get();</span><br><span class="line">        String message = service.sayHello(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在互联网领域，每个信息资源都有统一的且在网上唯一的地址，该地址就叫 URL（Uniform Resource Locator，统一资源定位符），它是互联网的统一资源定位标志，也就是指网络地址。 </p>
<p>URL 本质上就是一个特殊格式的字符串。一个标准的 URL 格式可以包含如下的几个部分：</p>
<ul>
<li> protocol：URL 的协议。我们常见的就是 HTTP 协议和 HTTPS 协议，当然，还有其他协议，如 FTP 协议、SMTP 协议等。</li>
<li>username/password：用户名 / 密码。 HTTP Basic Authentication 中多会使用在 URL 的协议 之后直接携带用户名和密码的方式。 </li>
<li>host/port：主机 / 端口。在实践中一般会使用域名，而不是使用具体的 host 和 port。 </li>
<li>path：请求的路径。 </li>
<li>parameters：参数键值对。一般在 GET 请求中会将参数放到 URL 中，POST 请求会将参数放到 请求体中。 </li>
</ul>
<p>URL 是整个 Dubbo 中非常基础，也是非常核心的一个组件，阅读源码的过程中你会发现很多方法都是 以 URL 作为参数的，在方法内部解析传入的 URL 得到有用的参数，所以有人将 URL 称为 Dubbo 的配 置总线。</p>
</blockquote>
<h2 id="Dubbo-中的-URL"><a href="#Dubbo-中的-URL" class="headerlink" title="Dubbo 中的 URL"></a>Dubbo 中的 URL</h2><p>Dubbo 中任意的一个实现都可以抽象为一个 URL，Dubbo 使用 URL 来统一描述了所有对象和配置信 息，并贯穿在整个 Dubbo 框架之中。这里我们来看 Dubbo 中一个典型 URL 的示例，如下： </p>
<p>这个 Demo Provider 注册到 ZooKeeper 上的 URL 信息，简单解析一下这个 URL 的各个部分：</p>
<ul>
<li>protocol：dubbo 协议。 </li>
<li>username/password：没有用户名和密码。 </li>
<li>host/port：172.17.32.91:20880。 </li>
<li>path：org.apache.dubbo.demo.DemoService。 </li>
<li>parameters：参数键值对，这里是问号后面的参数。</li>
</ul>
<p>下面是 URL 的构造方法，你可以看到其核心字段与前文分析的 URL 基本一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">               String username,</span></span></span><br><span class="line"><span class="params"><span class="function">               String password,</span></span></span><br><span class="line"><span class="params"><span class="function">               String host,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">               String path,</span></span></span><br><span class="line"><span class="params"><span class="function">               Map&lt;String, String&gt; parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">               Map&lt;String, Map&lt;String, String&gt;&gt; methodParameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(username)</span><br><span class="line">                &amp;&amp; StringUtils.isNotEmpty(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid url, password without username!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = Math.max(port, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = getAddress(<span class="keyword">this</span>.host, <span class="keyword">this</span>.port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trim the beginning &quot;/&quot;</span></span><br><span class="line">        <span class="keyword">while</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            path = path.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parameters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parameters = <span class="keyword">new</span> HashMap&lt;&gt;(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parameters = Collections.unmodifiableMap(parameters);</span><br><span class="line">        <span class="keyword">this</span>.methodParameters = Collections.unmodifiableMap(methodParameters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>另外，在 dubbo-common 包中还提供了 URL 的辅助类： </p>
<ul>
<li>URLBuilder， 辅助构造 URL； </li>
<li>URLStrParser， 将字符串解析成 URL 对象。</li>
</ul>
<h2 id="契约的力量"><a href="#契约的力量" class="headerlink" title="契约的力量"></a>契约的力量</h2><p>对于 Dubbo 中的 URL，很多人称之为 “配置总线”，也有人称之为 “统一配置模型”。虽然说法不同，但 都是在表达一个意思，URL 在 Dubbo 中被当作是 “公共的契约”。一个 URL 可以包含非常多的扩展点参 数，URL 作为上下文信息贯穿整个扩展点设计体系。 </p>
<p>其实，一个优秀的开源产品都有一套灵活清晰的扩展契约，不仅是第三方可以按照这个契约进行扩展， 其自身的内核也可以按照这个契约进行搭建。如果没有一个公共的契约，只是针对每个接口或方法进行 约定，就会导致不同的接口甚至同一接口中的不同方法，以不同的参数类型进行传参，一会儿传递 Map，一会儿传递字符串，而且字符串的格式也不确定，需要你自己进行解析，这就多了一层没有明确 表现出来的隐含的约定。 </p>
<p>所以说，在 Dubbo 中使用 URL 的好处多多，增加了便捷性： </p>
<ul>
<li>使用 URL 这种公共契约进行上下文信息传递，最重要的就是代码更加易读、易懂，不用花大量时 间去揣测传递数据的格式和含义，进而形成一个统一的规范，使得代码易写、易读。 </li>
<li>使用 URL 作为方法的入参（相当于一个 Key/Value 都是 String 的 Map)，它所表达的含义比单个 参数更丰富，当代码需要扩展的时候，可以将新的参数以 Key/Value 的形式追加到 URL 之中，而 不需要改变入参或是返回值的结构。 </li>
<li>使用 URL 这种 “公共的契约” 可以简化沟通，人与人之间的沟通消耗是非常大的，信息传递的效率 非常低，使用统一的契约、术语、词汇范围，可以省去很多沟通成本，尽可能地提高沟通效率。</li>
</ul>
<h2 id="Dubbo-中的-URL-示例"><a href="#Dubbo-中的-URL-示例" class="headerlink" title="Dubbo 中的 URL 示例"></a>Dubbo 中的 URL 示例</h2><h3 id="URL-在-SPI-中的应用"><a href="#URL-在-SPI-中的应用" class="headerlink" title="URL 在 SPI 中的应用"></a>URL 在 SPI 中的应用</h3><p>Dubbo SPI 中有一个依赖 URL 的重要场景——适配器方法，是被 @Adaptive 注解标注的， URL 一个 很重要的作用就是与 @Adaptive 注解一起选择合适的扩展实现类。 </p>
<p>例如，在 dubbo-registry-api 模块中我们可以看到 RegistryFactory 这个接口，其中的 getRegistry() 方 法上有<code> @Adaptive(&#123;&quot;protocol&quot;&#125;)</code> 注解，说明这是一个适配器方法，Dubbo 在运行时会为其动态生成相 应的 <code>“$Adaptive” </code>类型，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryFactory</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(org.apache.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = (url.getProtocol() == <span class="keyword">null</span> ? <span class="string">&quot;dubbo&quot;</span> :url.getProtocol());</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        RegistryFactory extension = (RegistryFactory) ExtensionLoader</span><br><span class="line">            .getExtensionLoader(RegistryFactory.class)</span><br><span class="line">            .getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会看到，在生成的 <code>RegistryFactory$Adaptive </code>类中会自动实现 <code>getRegistry()</code> 方法，其中会根据 URL 的 Protocol 确定扩展名称，从而确定使用的具体扩展实现类。我们可以找到 <code>RegistryProtocol </code>这 个类，并在其 getRegistry() 方法中打一个断点， Debug 启动任意一个 Demo 示例中的 Provider，得到如下图所示的内容：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050944996.png" alt="image-20220305094445916"></p>
<p>这里传入的 registryUrl 值为： 那么在 RegistryFactory$Adaptive 中得到的扩展名称为 zookeeper，此次使用的 Registry 扩展实现类 就是 ZookeeperRegistryFactory。</p>
<h3 id="URL-在服务暴露中的应用"><a href="#URL-在服务暴露中的应用" class="headerlink" title="URL 在服务暴露中的应用"></a>URL 在服务暴露中的应用</h3><p>Provider 在启 动时，会将自身暴露的服务注册到 ZooKeeper 上，具体是注册哪些信息到 ZooKeeper 上呢？我们来看 ZookeeperRegistry.doRegister() 方法，在其中打个断点，然后 Debug 启动 Provider，会得到下图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203050953320.png" alt="image-20220305095340231"></p>
<p>传入的 URL 中包含了 Provider 的地址（172.25.48.1:20880）、暴露的接口 （org.apache.dubbo.demo.DemoService）等信息， toUrlPath() 方法会根据传入的 URL 参数确定在 ZooKeeper 上创建的节点路径，还会通过 URL 中的 dynamic 参数值确定创建的 ZNode 是临时节点还是持久节点。</p>
<h3 id="URL-在服务订阅中的应用"><a href="#URL-在服务订阅中的应用" class="headerlink" title="URL 在服务订阅中的应用"></a>URL 在服务订阅中的应用</h3><p>Consumer 启动后会向注册中心进行订阅操作，并监听自己关注的 Provider。那 Consumer 是如何告 诉注册中心自己关注哪些 Provider 呢？ </p>
<p>我们来看 ZookeeperRegistry 这个实现类，它是由上面的 ZookeeperRegistryFactory 工厂类创建的 Registry 接口实现，其中的 doSubscribe() 方法是订阅操作的核心实现，在第 175 行打一个断点，并 Debug 启动 Demo 中 Consumer，会得到下图所示的内容：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051011113.png" alt="image-20220305101144007"></p>
<p>我们看到传入的 URL 参数如下： 其中 Protocol 为 consumer ，表示是 Consumer 的订阅协议，其中的 category 参数表示要订阅的分 类，这里要订阅 providers、configurators 以及 routers 三个分类；interface 参数表示订阅哪个服务 接口，这里要订阅的是暴露 org.apache.dubbo.demo.DemoService 实现的 Provider。 通过 URL 中的上述参数，ZookeeperRegistry 会在 toCategoriesPath() 方法中将其整理成一个 ZooKeeper 路径，然后调用 zkClient 在其上添加监听。</p>
<p>Dubbo 为了更好地达到 OCP 原则（即 “对扩展开放，对修改封闭” 的原则），采用了“微内核 + 插件” 的 架构。那什么是微内核架构呢？</p>
<blockquote>
<p>微内核架构也被称为插件化架构（Plug-in Architecture），这是一种面向功能进行拆分的可扩展性架构。内核功能是比较稳定的，只负责管理插件的生命周期，不会因为系统功能的扩展而不断进行修改。功能上的扩展全部封装到插件之中，插件模块是独立存在的模块，包含特 定的功能，能拓展内核系统的功能。 微内核架构中，内核通常采用 Factory、IoC、OSGi 等方式管理插件生命周期，Dubbo 最终决定采用 SPI 机制来加载插件，Dubbo SPI 参考 JDK 原生的 SPI 机制，进行了性能优化以及功能增强。因此，在 讲解 Dubbo SPI 之前，我们有必要先来介绍一下 JDK SPI 的工作原理。</p>
</blockquote>
<h2 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h2><p>SPI（Service Provider Interface）主要是被框架开发人员使用的一种技术。例如，使用 Java 语言访问 数据库时我们会使用到 java.sql.Driver 接口，不同数据库产品底层的协议不同，提供的 java.sql.Driver 实现也不同，在开发 java.sql.Driver 接口时，开发人员并不清楚用户最终会使用哪个数据库，在这种情 况下就可以使用 Java SPI 机制在实际运行过程中，为 java.sql.Driver 接口寻找具体的实现。</p>
<h3 id="JDK-SPI-机制"><a href="#JDK-SPI-机制" class="headerlink" title="JDK SPI 机制"></a>JDK SPI 机制</h3><p>当服务的提供者提供了一种接口的实现之后，需要在 Classpath 下的 <code>META-INF/services/</code> 目录里创建 一个以服务接口命名的文件，此文件记录了该 jar 包提供的服务接口的具体实现类。当某个应用引入了 该 jar 包且需要使用该服务时，JDK SPI 机制就可以通过查找这个 jar 包的<code>META-INF/services/</code>中的配 置文件来获得具体的实现类名，进行实现类的加载和实例化，最终使用该实现类完成业务功能。</p>
<p>下面我们通过一个简单的示例演示下 JDK SPI 的基本使用方式：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051038910.png" alt="image-20220305103834854"></p>
<p>首先我们需要创建一个 Log 接口，来模拟日志打印的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来提供两个实现—— Logback 和 Log4j，分别代表两个不同日志框架的实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log4j:&quot;</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logback</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback:&quot;</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的<code> resources/META-INF/services</code> 目录下添加一个名为 yang.org.Log 的文件，这是 JDK SPI 需要 读取的配置文件，具体内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yang.org.impl.Log4j</span><br><span class="line">yang.org.impl.Logback</span><br></pre></td></tr></table></figure>

<p>最后创建 main() 方法，其中会加载上述配置文件，创建全部 Log 接口实现的实例，并执行其 log() 方 法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Log&gt; serviceLoader = ServiceLoader.load(Log.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Log log : serviceLoader) &#123;</span><br><span class="line">            log.log(<span class="string">&quot;JDK SPI&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK-SPI-源码分析"><a href="#JDK-SPI-源码分析" class="headerlink" title="JDK SPI 源码分析"></a>JDK SPI 源码分析</h3><p>过上述示例，我们可以看到 JDK SPI 的入口方法是 ServiceLoader.load() 方法，接下来我们就对其具 体实现进行深入分析。 在 ServiceLoader.load() 方法中，首先会尝试获取当前使用的 ClassLoader（获取当前线程绑定的 ClassLoader，查找失败后使用 SystemClassLoader），然后调用 reload() 方法，调用关系如下图所 示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051044481.png" alt="image-20220305104418422"></p>
<p>在 reload() 方法中，首先会清理 providers 缓存（LinkedHashMap 类型的集合），该缓存用来记录 ServiceLoader 创建的实现对象，其中 Key 为实现类的完整类名，Value 为实现类的对象。之后创建 LazyIterator 迭代器，用于读取 SPI 配置文件并实例化实现类对象。 </p>
<p>ServiceLoader.reload() 方法的具体实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，main() 方法中使用的迭代器底层就是调用了 ServiceLoader.LazyIterator 实现的。 Iterator 接口有两个关键方法：hasNext() 方法和 next() 方法。这里的 LazyIterator 中的 next() 方法最 终调用的是其 nextService() 方法，hasNext() 方法最终调用的是 hasNextService() 方法，调用关系如 下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> hasNextService();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">             <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> nextService();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看 LazyIterator.hasNextService() 方法，该方法主要负责查找 <code>META-INF/services</code> 目录下的 SPI 配置文件，并进行遍历，大致实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">String nextName = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在 hasNextService() 方法中完成 SPI 配置文件的解析之后，再来看 LazyIterator.nextService() 方法， 该方法负责实例化 hasNextService() 方法读取到的实现类，其中会将实例化的对象放到 providers 集 合中缓存起来，核心实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>以上就是在 main() 方法中使用的迭代器的底层实现。最后，我们再来看一下 main() 方法中使用 ServiceLoader.iterator() 方法拿到的迭代器是如何实现的，这个迭代器是依赖 LazyIterator 实现的一个 匿名内部类，核心实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="JDK-SPI-在-JDBC-中的应用"><a href="#JDK-SPI-在-JDBC-中的应用" class="headerlink" title="JDK SPI 在 JDBC 中的应用"></a>JDK SPI 在 JDBC 中的应用</h3><p>了解了 JDK SPI 实现的原理之后，我们再来看实践中 JDBC 是如何使用 JDK SPI 机制加载不同数据库厂 商的实现类。 JDK 中只定义了一个 java.sql.Driver 接口，具体的实现是由不同数据库厂商来提供的。这里我们就以 MySQL 提供的 JDBC 实现包为例进行分析。 在 <code>mysql-connector-java-*.jar </code>包中的<code>META-INF/services</code>目录下，有一个<code>java.sql.Driver</code>文件中只有 一行内容，如下所示： 在使用 <code>mysql-connector-java-*.jar</code> 包连接 MySQL 数据库的时候，我们会用到如下语句创建数据库连 接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;jdbc:xxx://xxx:xxx/xxx&quot;</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, username, pwd);</span><br></pre></td></tr></table></figure>

<p><strong>DriverManager 是 JDK 提供的数据库驱动管理器</strong>，其中的代码片段，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 getConnection() 方法的时候，DriverManager 类会被 Java 虚拟机加载、解析并触发 static 代 码块的执行；在 loadInitialDrivers() 方法中通过 JDK SPI 扫描 Classpath 下 java.sql.Driver 接口实现类 并实例化，核心实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers = System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>)</span><br><span class="line">    ServiceLoader&lt;Driver&gt; loadedDrivers =</span><br><span class="line">    ServiceLoader.load(Driver.class);</span><br><span class="line">    Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    	driversIterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化Driver实现类</span></span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123; </span><br><span class="line">        Class.forName(aDriver, <span class="keyword">true</span>,ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 提供的 <code>com.mysql.cj.jdbc.Driver </code>实现类中，同样有一段 static 静态代码块，这段代码会创建一个 <code>com.mysql.cj.jdbc.Driver</code> 对象并注册到 <code>DriverManager.registeredDrivers </code>集合中 （CopyOnWriteArrayList 类型），如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>getConnection()</code> 方法中，<code>DriverManager</code> 从该 <code>registeredDrivers </code>集合中获取对应的 Driver 对象创 建 Connection，核心实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, java.util.Properties info,</span></span></span><br><span class="line"><span class="params"><span class="function">Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><p>在开始介绍 Dubbo SPI 实现之前，我们先来统一下面两个概念。</p>
<ul>
<li> 扩展点：通过 SPI 机制查找并加载实现的接口（又称 “扩展接口”）。前文示例中介绍的 Log 接口、com.mysql.cj.jdbc.Driver 接口，都是扩展点。 </li>
<li>扩展点实现：实现了扩展接口的实现类。</li>
</ul>
<p>通过前面的分析可以发现，JDK SPI 在查找扩展实现类的过程中，需要遍历 SPI 配置文件中定义的所有 实现类，该过程中会将这些实现类全部实例化。如果 SPI 配置文件中定义了多个实现类，而我们只需要 使用其中一个实现类时，就会生成不必要的对象。例如，org.apache.dubbo.rpc.Protocol 接口有 InjvmProtocol、DubboProtocol、RmiProtocol、HttpProtocol、HessianProtocol、ThriftProtocol 等多个实现，如果使用 JDK SPI，就会加载全部实现类，导致资源的浪费。</p>
<p>Dubbo SPI 不仅解决了上述资源浪费的问题，还对 SPI 配置文件扩展和修改。 </p>
<p>首先，Dubbo 按照 SPI 配置文件的用途，将其分成了三类目录。</p>
<ul>
<li><code>META-INF/services/</code> 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。</li>
<li><code>META-INF/dubbo/ </code>目录：该目录用于存放用户自定义 SPI 配置文件。</li>
<li><code>META-INF/dubbo/internal/ </code>目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。</li>
</ul>
<p>然后，Dubbo 将 SPI 配置文件改成了 KV 格式，例如</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br></pre></td></tr></table></figure>

<p>其中 key 被称为扩展名（也就是 ExtensionName），当我们在为一个接口查找具体实现类时，可以指 定扩展名来选择相应的扩展实现。例如，这里指定扩展名为 dubbo，Dubbo SPI 就知道我们要使用： <code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol </code>这个扩展实现类，只实例化这一个扩展实现 即可，无须实例化 SPI 配置文件中的其他扩展实现类。 </p>
<p>使用 KV 格式的 SPI 配置文件的另一个好处是：让我们更容易定位到问题。假设我们使用的一个扩展实 现类所在的 jar 包没有引入到项目中，那么 Dubbo SPI 在抛出异常的时候，会携带该扩展名信息，而不 是简单地提示扩展实现类无法加载。这些更加准确的异常信息降低了排查问题的难度，提高了排查问题的效率。 </p>
<p>下面我们正式进入 Dubbo SPI 核心实现的介绍。</p>
<h3 id="SPI-注解"><a href="#SPI-注解" class="headerlink" title="@SPI 注解"></a>@SPI 注解</h3><p>Dubbo 中某个接口被 @SPI 注解修饰时，就表示该接口是扩展接口，前文示例中的 <code>org.apache.dubbo.rpc.Protocol </code>接口就是一个扩展接口：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051416280.png" alt="image-20220305141613219"></p>
<p>@SPI 注解的 value 值指定了默认的扩展名称，例如，在通过 Dubbo SPI 加载 Protocol 接口实现时， 如果没有明确指定扩展名，则默认会将 @SPI 注解的 value 值作为扩展名，即加载 dubbo 这个扩展名 对应的 <code>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</code> 这个扩展实现类，相关的 SPI 配置文 件在 dubbo-rpc-dubbo 模块中，如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051420542.png" alt="image-20220305142007480"></p>
<p>那 ExtensionLoader 是如何处理 @SPI 注解的呢？ ExtensionLoader 位于 dubbo-common 模块中的 extension 包中，功能类似于 JDK SPI 中的 java.util.ServiceLoader。Dubbo SPI 的核心逻辑几乎都封装在 ExtensionLoader 之中（其中就包括 @SPI 注解的处理逻辑），其使用方式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader</span><br><span class="line">.getExtensionLoader(Protocol.class).getExtension(<span class="string">&quot;dubbo&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先来了解一下 ExtensionLoader 中三个核心的静态字段。</p>
<ul>
<li><p>strategies（LoadingStrategy[] 类型）: LoadingStrategy 接口有三个实现（通过 JDK SPI 方式 加载的），如下图所示，分别对应前面介绍的三个 Dubbo SPI 配置文件所在的目录，且都继承了 Prioritized 这个优先级接口，默认优先级是</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DubboInternalLoadingStrategy &gt; DubboLoadingStrategy &gt; ServicesLoadingStrateg</span><br></pre></td></tr></table></figure>

<p>  <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051425661.png" alt="image-20220305142546598"></p>
</li>
<li><p>EXTENSION_LOADERS（ConcurrentMap 类型） ：Dubbo 中一个扩展接口对应一个 ExtensionLoader 实例，该集合缓存了全部 ExtensionLoader 实例，其中的 Key 为扩展接口，Value 为加载其扩展实现的 ExtensionLoader 实例。</p>
</li>
</ul>
<p>下面我们再来关注一下 ExtensionLoader 的实例字段。</p>
<ul>
<li>type（Class 类型）：当前 ExtensionLoader 实例负责加载扩展接口。 </li>
<li>cachedDefaultName（String 类型）：记录了 type 这个扩展接口上 @SPI 注解的 value 值，也就是默认扩展名。 </li>
<li>cachedNames（ConcurrentMap, String &gt; 类型）：缓存了该 ExtensionLoader 加 载的扩展实现类与扩展名之间的映射关系。 </li>
<li>cachedClasses（Holder&gt;&gt; 类型）：缓存了该 ExtensionLoader 加载 的扩展名与扩展实现类之间的映射关系。cachedNames 集合的反向关系缓存。 </li>
<li>cachedInstances（ConcurrentMap &gt; 类型）：缓存了该 ExtensionLoader 加载的扩展名与扩展实现对象之间的映射关系。</li>
</ul>
<p>ExtensionLoader.getExtensionLoader() 方法会根据扩展接口从 EXTENSION_LOADERS 缓存中查找相 应的 ExtensionLoader 实例，核心实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type (&quot;</span> + type + <span class="string">&quot;) is not an interface!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                    <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到接口对应的 ExtensionLoader 对象之后会调用其 getExtension() 方法，根据传入的扩展名称从 cachedInstances 缓存中查找扩展实现的实例，最终将其实例化后返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">        Object instance = holder.get();</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">                instance = holder.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = createExtension(name);</span><br><span class="line">                    holder.set(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createExtension() 方法中完成了 SPI 配置文件的查找以及相应扩展实现类的实例化，同时还实现了 自动装配以及自动 Wrapper 包装等功能。其核心流程是这样的：</p>
<ol>
<li>获取 cachedClasses 缓存，根据扩展名从 cachedClasses 缓存中获取扩展实现类。如果 cachedClasses 未初始化，则会扫描前面介绍的三个 SPI 目录获取查找相应的 SPI 配置文件，然后 加载其中的扩展实现类，最后将扩展名和扩展实现类的映射关系记录到 cachedClasses 缓存中。 这部分逻辑在 loadExtensionClasses() 和 loadDirectory() 方法中。 </li>
<li>根据扩展实现类从 EXTENSION_INSTANCES 缓存中查找相应的实例。如果查找失败，会通过反射 创建扩展实现对象。 </li>
<li>自动装配扩展实现对象中的属性（即调用其 setter）。</li>
<li>自动包装扩展实现对象。</li>
<li>如果扩展实现类实现了 Lifecycle 接口，在 initExtension() 方法中会调用 initialize() 方法进行初始 化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> findException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">                instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            injectExtension(instance);</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            initExtension(instance);</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                    type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Adaptive-注解与适配器"><a href="#Adaptive-注解与适配器" class="headerlink" title="@Adaptive 注解与适配器"></a>@Adaptive 注解与适配器</h3><p>@Adaptive 注解用来实现 Dubbo 的适配器功能，那什么是适配器呢？这里我们通过一个示例进行说 明。Dubbo 中的 ExtensionFactory 接口有三个实现类，如下图所示，ExtensionFactory 接口上有 @SPI 注解，AdaptiveExtensionFactory 实现类上有 @Adaptive 注解。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051457264.png" alt="image-20220305145715187"></p>
<p>AdaptiveExtensionFactory 不实现任何具体的功能，而是用来适配 ExtensionFactory 的 SpiExtensionFactory 和 SpringExtensionFactory 这两种实现。AdaptiveExtensionFactory 会根据运 行时的一些状态来选择具体调用 ExtensionFactory 的哪个实现。 </p>
<p>@Adaptive 注解还可以加到接口方法之上，Dubbo 会动态生成适配器类。例如，Transporter 接口有 两个被 @Adaptive 注解修饰的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bind a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    <span class="function">RemotingServer <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 会生成一个 Transporter$Adaptive 适配器类，该类继承了 Transporter 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.dubbo.remoting.<span class="function">Client <span class="title">connect</span><span class="params">(URL arg0, ChannelHandler arg1)</span></span></span><br><span class="line"><span class="function">   	 <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;client&quot;</span>,</span><br><span class="line">        url.getParameter(<span class="string">&quot;transporter&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        Transporter extension = (Transporter) ExtensionLoader</span><br><span class="line">        	.getExtensionLoader(Transporter.class)</span><br><span class="line">        	.getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.connect(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成 Transporter$Adaptive 这个类的逻辑位于 ExtensionLoader.createAdaptiveExtensionClass() 方 法，若感兴趣你可以看一下相关代码，其中涉及的 javassist 等方面的知识。</p>
<p>明确了 @Adaptive 注解的作用之后，我们回到 ExtensionLoader.createExtension() 方法，其中在扫描 SPI 配置文件的时候，会调用 loadClass() 方法加载 SPI 配置文件中指定的类，如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203051502217.png" alt="image-20220305150207159"></p>
<p>loadClass() 方法中会识别加载扩展实现类上的 @Adaptive 注解，将该扩展实现的类型缓存到 cachedAdaptiveClass 这个实例字段上（volatile 修饰）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="comment">// 缓存到cachedAdaptiveClass字段</span></span><br><span class="line">        cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">    &#125; <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 ExtensionLoader.getAdaptiveExtension() 方法获取适配器实例，并将该实例缓存到 cachedAdaptiveInstance 字段（Holder 类型）中，核心流程如下：</p>
<ul>
<li>首先，检查 cachedAdaptiveInstance 字段中是否已缓存了适配器实例，如果已缓存，则直接返回 该实例即可。 </li>
<li>然后，调用 getExtensionClasses() 方法，其中就会触发前文介绍的 loadClass() 方法，完成 cachedAdaptiveClass 字段的填充。 </li>
<li>如果存在 @Adaptive 注解修饰的扩展实现类，该类就是适配器类，通过 newInstance() 将其实例 化即可。如果不存在 @Adaptive 注解修饰的扩展实现类，就需要通过 createAdaptiveExtensionClass() 方法扫描扩展接口中方法上的 @Adaptive 注解，动态生成适配 器类，然后实例化。 </li>
<li>接下来，调用 injectExtension() 方法进行自动装配，就能得到一个完整的适配器实例。 </li>
<li>最后，将适配器实例缓存到 cachedAdaptiveInstance 字段，然后返回适配器实例。</li>
</ul>
<p>此外，我们还可以通过 API 方式（addExtension() 方法）设置 cachedAdaptiveClass 这个字段，指定 适配器类型（这个方法你知道即可）。 总之，适配器什么实际工作都不用做，就是根据参数和状态选择其他实现来完成工作。</p>
<h3 id="自动包装特性"><a href="#自动包装特性" class="headerlink" title="自动包装特性"></a>自动包装特性</h3><p>Dubbo 中的一个扩展接口可能有多个扩展实现类，这些扩展实现类可能会包含一些相同的逻辑，如果在每个实现类中都写一遍，那么这些重复代码就会变得很难维护。Dubbo 提供的自动包装特性，就可 以解决这个问题。 Dubbo 将多个扩展实现类的公共逻辑，抽象到 Wrapper 类中，Wrapper 类与普通 的扩展实现类一样，也实现了扩展接口，在获取真正的扩展实现对象时，在其外面包装一层 Wrapper 对象，你可以理解成一层装饰器。</p>
<p>了解了 Wrapper 类的基本功能，我们回到 ExtensionLoader.loadClass() 方法中，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">    cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 isWrapperClass() 方法中，会判断该扩展实现类是否包含拷贝构造函数（即构造函数只有一个参数且为扩展接口类型），如果包含，则为Wrapper类，这就是判断 Wrapper类的标准。 </li>
<li>将 Wrapper 类记录到 cachedWrapperClasses（Set&gt; 类型）这个实例字段中进行缓存。</li>
</ol>
<p>createExtension() 方法时的 4 处，有下面这段代码，其中会遍历全部 Wrapper 类并一层层 包装到真正的扩展实例对象外层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">        instance = injectExtension((T) wrapperClass</span><br><span class="line">        .getConstructor(type).newInstance(instance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动装配特性"><a href="#自动装配特性" class="headerlink" title="自动装配特性"></a>自动装配特性</h3><p>在 createExtension() 方法中我们看到，Dubbo SPI 在拿到扩展实现类的对象（以及 Wrapper 类的对象）之后，还会调用 injectExtension() 方法扫描其全部 setter 方法，并根据 setter 方法的名称以及参 数的类型，加载相应的扩展实现，然后调用相应的 setter 方法填充属性，这就实现了 Dubbo SPI 的自 动装配特性。简单来说，自动装配属性就是在加载一个扩展点的时候，将其依赖的扩展点一并加载，并进行装配。</p>
<p>下面简单看一下 injectExtension() 方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (objectFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String property = getSetterProperty(method);</span><br><span class="line">                    Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                    <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        method.invoke(instance, object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                            + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>injectExtension() 方法实现的自动装配依赖了 ExtensionFactory（即 objectFactory 字段），前面我们 提到过 ExtensionFactory 有 SpringExtensionFactory 和 SpiExtensionFactory 两个真正的实现（还有 一个实现是 AdaptiveExtensionFactory 是适配器）。下面我们分别介绍下这两个真正的实现。</p>
<p>第一个，SpiExtensionFactory。 根据扩展接口获取相应的适配器，没有到属性名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            <span class="comment">// 查找type对应的ExtensionLoader实例</span></span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">            <span class="keyword">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二个，SpringExtensionFactory。 将属性名称作为 Spring Bean 的名称，从 Spring 容器中获取 Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SPI should be get from SpiExtensionFactory</span></span><br><span class="line">        <span class="keyword">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : CONTEXTS) &#123;</span><br><span class="line">            T bean = BeanFactoryUtils.getOptionalBean(context, name, type);</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.warn(<span class="string">&quot;No spring extension (bean) named:&quot;</span> + name + <span class="string">&quot;, try to find an extension (bean) of type &quot;</span> + type.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Activate-注解与自动激活特性"><a href="#Activate-注解与自动激活特性" class="headerlink" title="@Activate 注解与自动激活特性"></a>@Activate 注解与自动激活特性</h3><p>这里以 Dubbo 中的 Filter 为例说明自动激活特性的含义，org.apache.dubbo.rpc.Filter 接口有非常多 的扩展实现类，在一个场景中可能需要某几个 Filter 扩展实现类协同工作，而另一个场景中可能需要另 外几个实现类一起工作。这样，就需要一套配置来指定当前场景中哪些 Filter 实现是可用的，这就是 @Activate 注解要做的事情。 </p>
<p>@Activate 注解标注在扩展实现类上，有 group、value 以及 order 三个属性。 </p>
<ul>
<li>group 属性：修饰的实现类是在 Provider 端被激活还是在 Consumer 端被激活。 </li>
<li>value 属性：修饰的实现类只在 URL 参数中出现指定的 key 时才会被激活。 </li>
<li>order 属性：用来确定扩展实现类的排序。 </li>
</ul>
<p>我们先来看 loadClass() 方法对 @Activate 的扫描，其中会将包含 @Activate 注解的实现类缓存到 cachedActivates 这个实例字段（Map 类型，Key 为扩展名，Value 为 @Activate 注 解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> overridden)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                    type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                    + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            cacheAdaptiveClass(clazz, overridden);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            cacheWrapperClass(clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz.getConstructor();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">                name = findAnnotationName(clazz);</span><br><span class="line">                <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">                cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                    cacheName(clazz, n);</span><br><span class="line">                    saveInExtensionClass(extensionClasses, clazz, n, overridden);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 cachedActivates 这个集合的地方是 getActivateExtension() 方法。首先来关注 getActivateExtension() 方法的参数：url 中包含了配置信息，values 是配置中指定的扩展名，group 为 Provider 或 Consumer。下面是 getActivateExtension() 方法的核心逻辑： </p>
<ol>
<li>首先，获取默认激活的扩展集合。默认激活的扩展实现类有几个条件：①在 cachedActivates 集合 中存在；②@Activate 注解指定的 group 属性与当前 group 匹配；③扩展名没有出现在 values 中 （即未在配置中明确指定，也未在配置中明确指定删除）；④URL 中出现了 @Activate 注解中指 定的 Key。</li>
<li>然后，按照 @Activate 注解中的 order 属性对默认激活的扩展集合进行排序。</li>
<li>最后，按序添加自定义扩展实现类的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; activateExtensions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>) : asList(values);</span><br><span class="line">        <span class="keyword">if</span> (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) &#123;</span><br><span class="line">            getExtensionClasses();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">                String name = entry.getKey();</span><br><span class="line">                Object activate = entry.getValue();</span><br><span class="line"></span><br><span class="line">                String[] activateGroup, activateValue;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> Activate) &#123;</span><br><span class="line">                    activateGroup = ((Activate) activate).group();</span><br><span class="line">                    activateValue = ((Activate) activate).value();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activate <span class="keyword">instanceof</span> com.alibaba.dubbo.common.extension.Activate) &#123;</span><br><span class="line">                    activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();</span><br><span class="line">                    activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isMatchGroup(group, activateGroup)</span><br><span class="line">                        &amp;&amp; !names.contains(name)</span><br><span class="line">                        &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)</span><br><span class="line">                        &amp;&amp; isActive(activateValue, url)) &#123;</span><br><span class="line">                    activateExtensions.add(getExtension(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            activateExtensions.sort(ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; loadedExtensions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">            String name = names.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!name.startsWith(REMOVE_VALUE_PREFIX)</span><br><span class="line">                    &amp;&amp; !names.contains(REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!loadedExtensions.isEmpty()) &#123;</span><br><span class="line">                        activateExtensions.addAll(<span class="number">0</span>, loadedExtensions);</span><br><span class="line">                        loadedExtensions.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    loadedExtensions.add(getExtension(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!loadedExtensions.isEmpty()) &#123;</span><br><span class="line">            activateExtensions.addAll(loadedExtensions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activateExtensions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在很多开源框架中，都需要定时任务的管理功能，例如 ZooKeeper、Netty、Quartz、Kafka 以及 Linux 操作系统。 JDK 提供的 java.util.Timer 和 DelayedQueue 等工具类，可以帮助我们实现简单的定时任务管理，其 底层实现使用的是堆这种数据结构，存取操作的复杂度都是 O(nlog(n))，无法支持大量的定时任务。在 定时任务量比较大、性能要求比较高的场景中，为了将定时任务的存取操作以及取消操作的时间复杂度 降为 O(1)，一般会使用时间轮的方式。</p>
<p>时间轮是一种高效的、批量管理定时任务的调度模型。时间轮一般会实现成一个环形结构，类似一个时 钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；指针周期性地跳动， 跳动到一个槽位，就执行该槽位的定时任务。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203061425283.png" alt="image-20220306142502213"></p>
<p>需要注意的是，单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量 定时任务需要调度的场景，通常会使用多级时间轮以及持久化存储与时间轮结合的方案。</p>
<p>那在 Dubbo 中，时间轮的具体实现方式是怎样的呢？</p>
<p>Dubbo 的时间轮实现 位于 dubbo-common 模块的 org.apache.dubbo.common.timer 包中，下面我们就来分析时间轮涉及 的核心接口和实现。</p>
<h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>在 Dubbo 中，所有的定时任务都要继承 TimerTask 接口。TimerTask 接口非常简单，只定义了一个 run() 方法，该方法的入参是一个 Timeout 接口的对象。Timeout 对象与 TimerTask 对象一一对应，两 者的关系类似于线程池返回的 Future 对象与提交到线程池中的任务对象之间的关系。通过 Timeout 对 象，我们不仅可以查看定时任务的状态，还可以操作定时任务（例如取消关联的定时任务）。Timeout 接口中的方法如下图所示：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203061427222.png" alt="image-20220306142707165"></p>
<p>Timer 接口定义了定时器的基本行为，如下图所示，其核心是 newTimeout() 方法：提交一个定时任务 （TimerTask）并返回关联的 Timeout 对象，这有点类似于向线程池提交任务的感觉。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202203061427202.png" alt="image-20220306142736133"></p>
<h3 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h3><p>HashedWheelTimeout 是 Timeout 接口的唯一实现，是 HashedWheelTimer 的内部类。 HashedWheelTimeout 扮演了两个角色：</p>
<ul>
<li>第一个，时间轮中双向链表的节点，即定时任务 TimerTask 在 HashedWheelTimer 中的容器。</li>
<li>第二个，定时任务 TimerTask 提交到 HashedWheelTimer 之后返回的句柄（Handle），用于在 时间轮外部查看和控制定时任务。</li>
</ul>
<p>HashedWheelTimeout 中的核心字段如下：</p>
<ul>
<li>prev、next（HashedWheelTimeout 类型），分别对应当前定时任务在链表中的前驱节点和后 继节点。 </li>
<li>task（TimerTask 类型），指实际被调度的任务。 </li>
<li>deadline（long 类型），指定时任务执行的时间。这个时间是在创建 HashedWheelTimeout 时 指定的，计算公式是：currentTime（创建 HashedWheelTimeout 的时间） + delay（任务延迟 时间） - startTime（HashedWheelTimer 的启动时间），时间单位为纳秒。 </li>
<li>state（volatile int 类型），指定时任务当前所处状态，可选的有三个，分别是 INIT（0）、 CANCELLED（1）和 EXPIRED（2）。另外，还有一个 STATE_UPDATER 字段 （AtomicIntegerFieldUpdater 类型）实现 state 状态变更的原子性。 </li>
<li>remainingRounds（long 类型），指当前任务剩余的时钟周期数。时间轮所能表示的时间长度是有限的，在任务到期时间与当前时刻的时间差，超过时间轮单圈能表示的时长，就出现了套圈的 情况，需要该字段值表示剩余的时钟周期。</li>
</ul>
<p>HashedWheelTimeout 中的核心方法有：</p>
<ul>
<li>isCancelled()、isExpired() 、state() 方法， 主要用于检查当前 HashedWheelTimeout 状态。</li>
<li>cancel() 方法， 将当前 HashedWheelTimeout 的状态设置为 CANCELLED，并将当前 HashedWheelTimeout 添加到 cancelledTimeouts 队列中等待销毁。 </li>
<li>expire() 方法， 当任务到期时，会调用该方法将当前 HashedWheelTimeout 设置为 EXPIRED 状 态，然后调用其中的 TimerTask 的 run() 方法执行定时任务。 </li>
<li>remove() 方法， 将当前 HashedWheelTimeout 从时间轮中删除。</li>
</ul>
<h3 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h3><p>HashedWheelBucket 是时间轮中的一个槽，时间轮中的槽实际上就是一个用于缓存和管理双向链表的 容器，双向链表中的每一个节点就是一个 HashedWheelTimeout 对象，也就关联了一个 TimerTask 定 时任务。</p>
<p>HashedWheelBucket 持有双向链表的首尾两个节点，分别是 head 和 tail 两个字段，再加上每个 HashedWheelTimeout 节点均持有前驱和后继的引用，这样就可以正向或是逆向遍历整个双向链表 了。 </p>
<p>下面我们来看 HashedWheelBucket 中的核心方法。 </p>
<ul>
<li>addTimeout() 方法：新增 HashedWheelTimeout 到双向链表的尾部。 </li>
<li>pollTimeout() 方法：移除双向链表中的头结点，并将其返回。 </li>
<li>remove() 方法：从双向链表中移除指定的 HashedWheelTimeout 节点。 </li>
<li>clearTimeouts() 方法：循环调用 pollTimeout() 方法处理整个双向链表，并返回所有未超时或者 未被取消的任务。 </li>
<li>expireTimeouts() 方法：遍历双向链表中的全部 HashedWheelTimeout 节点。 在处理到期的定 时任务时，会通过 remove() 方法取出，并调用其 expire() 方法执行；对于已取消的任务，通过 remove() 方法取出后直接丢弃；对于未到期的任务，会将 remainingRounds 字段（剩余时钟周 期数）减一。 </li>
</ul>
<h3 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h3><p>HashedWheelTimer 是 Timer 接口的实现，它通过时间轮算法实现了一个定时器。 </p>
<p>HashedWheelTimer 会根据当前时间轮指针选定对应的槽（HashedWheelBucket），从双向链表的头 部开始迭代，对每个定时任务（HashedWheelTimeout）进行计算，属于当前时钟周期则取出运行， 不属于则将其剩余的时钟周期数减一操作。 </p>
<p>下面我们来看 HashedWheelTimer 的核心属性。 </p>
<ul>
<li>workerState（volatile int 类型）：时间轮当前所处状态，可选值有 init、started、 shutdown。同时，有相应的 AtomicIntegerFieldUpdater 实现 workerState 的原子修改。 </li>
<li>startTime（long 类型）：当前时间轮的启动时间，提交到该时间轮的定时任务的 deadline 字段 值均以该时间戳为起点进行计算。 </li>
<li>wheel（HashedWheelBucket[] 类型）：该数组就是时间轮的环形队列，每一个元素都是一个 槽。当指定时间轮槽数为 n 时，实际上会取大于且最靠近 n 的 2 的幂次方值。 </li>
<li>timeouts、cancelledTimeouts（LinkedBlockingQueue 类型）：timeouts 队列用于缓冲外 部提交时间轮中的定时任务，cancelledTimeouts 队列用于暂存取消的定时任务。 HashedWheelTimer 会在处理 HashedWheelBucket 的双向链表之前，先处理这两个队列中的数 据。 </li>
<li>tick（long 类型）：该字段在 HashedWheelTimer$Worker 中，是时间轮的指针，是一个步长为 1 的单调递增计数器。 </li>
<li>mask（int 类型）：掩码， mask = wheel.length - 1，执行 ticks &amp; mask 便能定位到对应的时钟 槽。 </li>
<li>ticksDuration（long 类型）：时间指针每次加 1 所代表的实际时间，单位为纳秒。 </li>
<li>pendingTimeouts（AtomicLong 类型）：当前时间轮剩余的定时任务总数。 workerThread（Thread 类型）：时间轮内部真正执行定时任务的线程。 </li>
<li>worker（Worker 类型）：真正执行定时任务的逻辑封装这个 Runnable 对象中。 </li>
</ul>
<p>时间轮对外提供了一个 newTimeout() 接口用于提交定时任务，在定时任务进入到 timeouts 队列之前 会先调用 start() 方法启动时间轮，其中会完成下面两个关键步骤： </p>
<ol>
<li>确定时间轮的 startTime 字段； </li>
<li>启动 workerThread 线程，开始执行 worker 任务。 </li>
</ol>
<p>之后根据 startTime 计算该定时任务的 deadline 字段，最后才能将定时任务封装成 HashedWheelTimeout 并添加到 timeouts 队列。 </p>
<p>下面我们来分析时间轮指针一次转动的全流程。</p>
<ol>
<li>时间轮指针转动，时间轮周期开始。 </li>
<li>清理用户主动取消的定时任务，这些定时任务在用户取消时，会记录到 cancelledTimeouts 队列 中。在每次指针转动的时候，时间轮都会清理该队列。 </li>
<li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中。 </li>
<li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务。 </li>
<li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。如果时间轮处于停止状态，则执行下面的步骤获取到未被执行的定时任务并加入 unprocessedTimeouts 队列：遍历时间轮中每个槽位，并调用 clearTimeouts() 方法；对 timeouts 队列中未被加入槽中 循环调用 poll()。 </li>
<li>最后再次清理 cancelledTimeouts 队列中用户主动取消的定时任务。 上述核心逻辑在 HashedWheelTimer$Worker.run() 方法中，若你感兴趣的话，可以翻看一下源码进行分析。</li>
</ol>
<h2 id="Dubbo-中如何使用定时任务"><a href="#Dubbo-中如何使用定时任务" class="headerlink" title="Dubbo 中如何使用定时任务"></a>Dubbo 中如何使用定时任务</h2><p>在 Dubbo 中，时间轮并不直接用于周期性操作，而是只向时间轮提交执行单次的定时任务，在上一次 任务执行完成的时候，调用 newTimeout() 方法再次提交当前任务，这样就会在下个周期执行该任务。 即使在任务执行过程中出现了 GC、I/O 阻塞等情况，导致任务延迟或卡住，也不会有同样的任务源源不 断地提交进来，导致任务堆积。 </p>
<p>Dubbo 中对时间轮的应用主要体现在如下两个方面： </p>
<ul>
<li>失败重试， 例如，Provider 向注册中心进行注册失败时的重试操作，或是 Consumer 向注册中心 订阅时的失败重试等。 </li>
<li>周期性定时任务， 例如，定期发送心跳请求，请求超时的处理，或是网络连接断开后的重连机 制。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxueyangtiger.github.io/post/51a6cf8f.html">https://lvxueyangtiger.github.io/post/51a6cf8f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxueyangtiger.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dubbo/">Dubbo</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/7a4.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212055.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ElasticSearch</div></div></a></div><div class="next-post pull-right"><a href="/post/7dd92c2.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212050.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker镜像操作</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Dubbo 架构简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA-Dubbo-%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83"><span class="toc-number">2.</span> <span class="toc-text">搭建 Dubbo 源码环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E6%BA%90%E7%A0%81%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">Dubbo 源码核心模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84-Demo-%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">Dubbo 源码中的 Demo 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-ZooKeeper"><span class="toc-number">4.1.</span> <span class="toc-text">启动 ZooKeeper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">业务接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-1%EF%BC%9A%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">Demo 1：基于 XML 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-2%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">4.4.</span> <span class="toc-text">Demo 2：基于注解配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-3%EF%BC%9A%E5%9F%BA%E4%BA%8E-API-%E9%85%8D%E7%BD%AE"><span class="toc-number">4.5.</span> <span class="toc-text">Demo 3：基于 API 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E4%B8%AD%E7%9A%84-URL"><span class="toc-number">5.</span> <span class="toc-text">Dubbo 中的 URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%91%E7%BA%A6%E7%9A%84%E5%8A%9B%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">契约的力量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E4%B8%AD%E7%9A%84-URL-%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">Dubbo 中的 URL 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E5%9C%A8-SPI-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">URL 在 SPI 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">URL 在服务暴露中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E8%AE%A2%E9%98%85%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">URL 在服务订阅中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-SPI"><span class="toc-number">8.</span> <span class="toc-text">JDK SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-SPI-%E6%9C%BA%E5%88%B6"><span class="toc-number">8.1.</span> <span class="toc-text">JDK SPI 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-SPI-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">8.2.</span> <span class="toc-text">JDK SPI 源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-SPI-%E5%9C%A8-JDBC-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">JDK SPI 在 JDBC 中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-SPI"><span class="toc-number">9.</span> <span class="toc-text">Dubbo SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI-%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.1.</span> <span class="toc-text">@SPI 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adaptive-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">@Adaptive 注解与适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%85%E8%A3%85%E7%89%B9%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">自动包装特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%89%B9%E6%80%A7"><span class="toc-number">9.4.</span> <span class="toc-text">自动装配特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activate-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB%E7%89%B9%E6%80%A7"><span class="toc-number">9.5.</span> <span class="toc-text">@Activate 注解与自动激活特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">核心接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashedWheelTimeout"><span class="toc-number">10.1.</span> <span class="toc-text">HashedWheelTimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashedWheelBucket"><span class="toc-number">10.2.</span> <span class="toc-text">HashedWheelBucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashedWheelTimer"><span class="toc-number">10.3.</span> <span class="toc-text">HashedWheelTimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">Dubbo 中如何使用定时任务</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>