<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Nginx | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Nginx"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nginx基础回顾  nginx 到底是什么？  Nginx 是⼀个⾼性能的HTTP和反向代理web服务器，核⼼特点是占有内存少，并发能⼒强   Nginx ⼜能做什么事情（应⽤场景）  Http服务器（Web服务器）  性能⾮常⾼，⾮常注重效率，能够经受⾼负载的考验。  ⽀持50000个并发连接数，不仅如此， CPU和内存的占⽤也⾮常的低， 10000个没有活动的连  接才占⽤2.5M的内存。">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx">
<meta property="og:url" content="http://lvxueyang.vip/post/65b69107.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="Nginx基础回顾  nginx 到底是什么？  Nginx 是⼀个⾼性能的HTTP和反向代理web服务器，核⼼特点是占有内存少，并发能⼒强   Nginx ⼜能做什么事情（应⽤场景）  Http服务器（Web服务器）  性能⾮常⾼，⾮常注重效率，能够经受⾼负载的考验。  ⽀持50000个并发连接数，不仅如此， CPU和内存的占⽤也⾮常的低， 10000个没有活动的连  接才占⽤2.5M的内存。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg">
<meta property="article:published_time" content="2021-08-07T08:14:00.000Z">
<meta property="article:modified_time" content="2022-11-27T09:16:38.635Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="http://lvxueyang.vip/post/65b69107"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nginx',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Nginx</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-07T08:14:00.000Z" title="发表于 2021-08-07 16:14:00">2021-08-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:38.635Z" title="更新于 2022-11-27 17:16:38">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Nginx"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Nginx基础回顾"><a href="#Nginx基础回顾" class="headerlink" title="Nginx基础回顾"></a>Nginx基础回顾</h2><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203645.png" alt="img"></p>
<ul>
<li><p><strong>nginx 到底是什么？</strong><br>  Nginx 是⼀个⾼性能的HTTP和反向代理web服务器，核⼼特点是占有内存少，并发能⼒强 </p>
</li>
<li><p><strong>Nginx ⼜能做什么事情（应⽤场景）</strong></p>
</li>
<li><p>Http服务器（Web服务器）<br>  性能⾮常⾼，⾮常注重效率，能够经受⾼负载的考验。<br>  ⽀持50000个并发连接数，不仅如此， CPU和内存的占⽤也⾮常的低， 10000个没有活动的连<br>  接才占⽤2.5M的内存。</p>
</li>
<li><p>反向代理服务器</p>
</li>
<li><p>正向代理 </p>
</li>
</ul>
<p>在浏览器中配置代理服务器的相关信息，通过代理服务器访问⽬标⽹站，代理服务器收<br>到⽬标⽹站的响应之后，会把响应信息返回给我们⾃⼰的浏览器客户端<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203628.png" alt="img"></p>
<ul>
<li>反向代理<br>  浏览器客户端发送请求到反向代理服务器（⽐如Nginx），由反向代理服务器选择原始<br>  服务器提供服务获取结果响应，最终再返回给客户端浏览器 </li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203628.png" alt="img"></p>
<ul>
<li><strong>负载均衡服务器</strong><br>  负载均衡，当⼀个请求到来的时候（结合上图）， Nginx反向代理服务器根据请求去找到⼀个<br>  原始服务器来处理当前请求，那么这叫做反向代理。那么，如果⽬标服务器有多台（⽐如上<br>  图中的tomcat1， tomcat2， tomcat3…），找哪⼀个⽬标服务器来处理当前请求呢，这样⼀<br>  个寻找确定的过程就叫做负载均衡。<br>  ⽣活中也有很多这样的例⼦，⽐如，我们去银⾏，可以处理业务的窗⼝有多个，那么我们会<br>  被分配到哪个窗⼝呢到底，这样的⼀个过程就叫做负载均衡。 </li>
</ul>
<p>负载均衡就是为了解决⾼负载的问题。 </p>
<ul>
<li><p><strong>动静分离</strong><br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203628.png" alt="img"><br>  <strong>Nginx 的特点</strong></p>
</li>
<li><p>跨平台： Nginx可以在⼤多数类unix操作系统上编译运⾏，⽽且也有windows版本</p>
</li>
<li><p>Nginx的上⼿⾮常容易，配置也⽐较简单</p>
</li>
<li><p>⾼并发，性能好</p>
</li>
<li><p>稳定性也特别好，宕机概率很低 </p>
</li>
</ul>
<p><strong>Nginx的安装</strong></p>
<ul>
<li><p>上传nginx安装包到linux服务器， nginx安装包(.tar⽂件)下载地址： <a target="_blank" rel="noopener" href="http://nginx.org/">http://nginx.org</a></p>
</li>
<li><p>安装Nginx依赖， pcre、 openssl、 gcc、 zlib（推荐使⽤yum源⾃动安装）<br>  yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</p>
</li>
<li><p>解包Nginx软件包<br>  tar -xvf nginx-1.17.8.tar</p>
</li>
<li><p>进⼊解压之后的⽬录 nginx-1.17.8<br>  cd nginx-1.17.8</p>
</li>
<li><p>命令⾏执⾏./configure</p>
</li>
<li><p>命令⾏执⾏ make</p>
</li>
<li><p>命令⾏执⾏ make install，完毕之后在/usr/local/下会产⽣⼀个nginx⽬录<br>   <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203628.png" alt="img"></p>
</li>
</ul>
<p>进⼊sbin⽬录中，执⾏启动nginx命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p>然后访问服务器的80端⼝（nginx默认监听80端⼝） </p>
<p> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203628.png" alt="img"></p>
<ul>
<li><p>Nginx主要命令</p>
</li>
<li><p>./nginx 启动nginx</p>
</li>
<li><p>./nginx -s stop 终⽌nginx（当然也可以找到nginx进程号，然后使⽤kill -9 杀掉nginx进程）</p>
</li>
<li><p>./nginx -s reload (重新加载nginx.conf配置⽂件) </p>
</li>
</ul>
<h2 id="Nginx核⼼配置⽂件解读"><a href="#Nginx核⼼配置⽂件解读" class="headerlink" title="Nginx核⼼配置⽂件解读"></a>Nginx核⼼配置⽂件解读</h2><p>Nginx的核⼼配置⽂件conf/nginx.conf包含三块内容：全局块、 events块、 http块<br> <strong>全局块</strong><br>从配置⽂件开始到events块之间的内容，此处的配置影响nginx服务器整体的运⾏，⽐如worker进<br>程的数量、错误⽇志的位置等 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行用户</span><br><span class="line">#user  nobody;</span><br><span class="line"># worker进程数量通常设置为和cpu数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"># 全局错误日志以及pid文件位置</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br></pre></td></tr></table></figure>

<p><strong>events块</strong><br>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个<br>workderprocess⽀持的最⼤连接数为1024 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">   # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    use epoll;</span><br><span class="line">   # 每个进程允许最大并发数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>http块</strong><br>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡<br>等 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  	# 引入mime类型定义文件</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">		# 设置日志格式</span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">		 # Nginx访问日志存放位置</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">		# 设置连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">		# 开启gzip压缩</span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    		# 监听端口</span><br><span class="line">        listen       80;</span><br><span class="line">    		# 定义使用localhost访问</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">				# 默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # 默认的网站根目录</span><br><span class="line">            index  index.html index.htm; # 索引页欢迎页</span><br><span class="line">      			deny 172.168.22.11;   # 禁止访问的ip地址，可以为all</span><br><span class="line">    				allow 172.168.33.44； # 允许访问的ip地址，可以为all</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">    		# 错误提示页面</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx配置语法"><a href="#Nginx配置语法" class="headerlink" title="Nginx配置语法"></a>Nginx配置语法</h2><p>就跟前面文件作用讲解的图所示，Nginx 的主配置文件是 /etc/nginx/nginx.conf，你可以使用 cat -n nginx.conf 来查看配置。</p>
<p>nginx.conf 结构图可以这样概括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main        # 全局配置，对全局生效</span><br><span class="line">├── events  # 配置影响 Nginx 服务器或与用户的网络连接</span><br><span class="line">├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</span><br><span class="line">│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分</span><br><span class="line">│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri</span><br><span class="line">│   │   ├── location</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>

<p>一个 Nginx 配置文件的结构就像 nginx.conf 显示的那样，配置文件的语法规则：</p>
<ol>
<li><p>配置文件由指令与指令块构成；</p>
</li>
<li><p>每条指令以 ; 分号结尾，指令与参数间以空格符号分隔；</p>
</li>
<li><p>指令块以 {} 大括号将多条指令组织在一起；</p>
</li>
<li><p>include 语句允许组合多个配置文件以提升可维护性；</p>
</li>
<li><p>使用 # 符号添加注释，提高可读性；</p>
</li>
<li><p>使用 $ 符号使用变量；</p>
</li>
<li><p>部分指令的参数支持正则表达式；</p>
</li>
</ol>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><table>
<thead>
<tr>
<th><strong>全局变量名</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>$host</td>
<td>请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名，不包含端口</td>
</tr>
<tr>
<td>$request_method</td>
<td>客户端请求类型，如 GET、POST</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>客户端的 IP 地址</td>
</tr>
<tr>
<td>$args</td>
<td>请求中的参数</td>
</tr>
<tr>
<td>$arg_PARAMETER</td>
<td>GET 请求中变量名 PARAMETER 参数的值，例如：$http_user_agent(Uaer-Agent 值), $http_referer</td>
</tr>
<tr>
<td>$content_length</td>
<td>请求头中的 Content-length 字段</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>客户端agent信息</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>客户端cookie信息</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>客户端的IP地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>客户端的端口</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>客户端agent信息</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>请求使用的协议，如 HTTP/1.0、HTTP/1.1</td>
</tr>
<tr>
<td>$server_addr</td>
<td>服务器地址</td>
</tr>
<tr>
<td>$server_name</td>
<td>服务器名称</td>
</tr>
<tr>
<td>$server_port</td>
<td>服务器的端口号</td>
</tr>
<tr>
<td>$scheme</td>
<td>HTTP 方法（如http，https）</td>
</tr>
</tbody></table>
<h2 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h2><p>gzip 是一种常用的网页压缩技术，传输的网页经过 gzip 压缩之后大小通常可以变为原来的一半甚至更小（官网原话），更小的网页体积也就意味着带宽的节约和传输速度的提升，特别是对于访问量巨大大型网站来说，每一个静态资源体积的减小，都会带来可观的流量与带宽的节省。</p>
<p>百度可以找到很多检测站点来查看目标网页有没有开启 gzip 压缩，在下随便找了一个 <a target="_blank" rel="noopener" href="http://tool.chinaz.com/Gzips/Default.aspx?q=juejin.im">&lt;网页GZIP压缩检测&gt;</a> 输入掘金 jd.com 来偷窥下掘金有没有开启 gzip。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203701.png" alt="img"></p>
<p>使用 gzip 不仅需要 Nginx 配置，浏览器端也需要配合，需要在请求消息头中包含 Accept-Encoding: gzip（IE5 之后所有的浏览器都支持了，是现代浏览器的默认设置）。一般在请求 html 和 css 等静态资源的时候，支持的浏览器在 request 请求静态资源的时候，会加上 Accept-Encoding: gzip 这个 header，表示自己支持 gzip 的压缩方式，Nginx 在拿到这个请求的时候，如果有相应配置，就会返回经过 gzip 压缩过的文件给浏览器，并在 response 相应的时候加上 content-encoding: gzip 来告诉浏览器自己采用的压缩方式（因为浏览器在传给服务器的时候一般还告诉服务器自己支持好几种压缩方式），浏览器拿到压缩的文件后，根据自己的解压方式进行解析。</p>
<p>先来看看 Nginx 怎么进行 gzip 配置，和之前的配置一样，为了方便管理，还是在 /etc/nginx/conf.d/ 文件夹中新建配置文件 gzip.conf。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/gzip.conf</span><br><span class="line"></span><br><span class="line">gzip on; # 默认off，是否开启gzip</span><br><span class="line">gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"># 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下</span><br><span class="line">gzip_static on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>gzip_types</strong>：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</p>
</li>
<li><p><strong>gzip_static</strong>：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</p>
</li>
<li><p><strong>gzip_proxied</strong>：默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</p>
</li>
<li><p><strong>gzip_vary</strong>：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</p>
</li>
<li><p><strong>gzip_comp_level</strong>：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</p>
</li>
<li><p><strong>gzip_buffers</strong>：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</p>
</li>
<li><p><strong>gzip_min_length</strong>：允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</p>
</li>
<li><p><strong>gzip_http_version</strong>：默认 1.1，启用 gzip 所需的 HTTP 最低版本；</p>
</li>
</ul>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>主要配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream myserver &#123;</span><br><span class="line">  	# ip_hash;  # ip_hash 方式</span><br><span class="line">    # fair;   # fair 方式</span><br><span class="line">    server 127.0.0.1:8081;  # 负载均衡目的服务地址</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    server 127.0.0.1:8082 weight=10;  # weight 方式，不写默认为 1</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://myserver;</span><br><span class="line">      proxy_connect_timeout 10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 提供了好几种分配方式，默认为<strong>轮询</strong>，就是轮流来。有以下几种分配方式：</p>
<ol>
<li><p><strong>轮询</strong>，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除；</p>
</li>
<li><p><strong>weight</strong>，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况；</p>
</li>
<li><p><strong>ip_hash</strong>，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的；</p>
</li>
<li><p><strong>fair</strong>（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装；</p>
</li>
</ol>
<h2 id="配置动静分离"><a href="#配置动静分离" class="headerlink" title="配置动静分离"></a>配置动静分离</h2><p>动静分离在之前也介绍过了，就是把动态和静态的请求分开。方式主要有两种，一种 是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。另外一种方法就是动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开。</p>
<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location /www/ &#123;</span><br><span class="line">  	root /data/;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location /image/ &#123;</span><br><span class="line">  	root /data/;</span><br><span class="line">    autoindex on;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置二级域名虚拟主机"><a href="#设置二级域名虚拟主机" class="headerlink" title="设置二级域名虚拟主机"></a>设置二级域名虚拟主机</h2><p>在某某云 ☁️ 上购买了域名之后，就可以配置虚拟主机了，一般配置的路径在 域名管理 -&gt; 解析 -&gt; 添加记录 中添加二级域名，配置后某某云会把二级域名也解析到我们配置的服务器 IP 上，然后我们在 Nginx 上配置一下虚拟主机的访问监听，就可以拿到从这个二级域名过来的请求了。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203707.png" alt="img"></p>
<p>现在我自己的服务器上配置了一个 abc 的二级域名，也就是说在外网访问 abc.lvxueyang.vip 的时候，也可以访问到我们的服务器了。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203713.png" alt="img"></p>
<h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><p>反向代理是工作中最常用的服务器功能，经常被用来解决跨域问题，下面简单介绍一下如何实现反向代理。</p>
<p>首先进入 Nginx 的主配置文件：</p>
<p>然后我们去 http 模块的 server 块中的 location /，增加一行将默认网址重定向到最大学习网站 Bilibili 的 proxy_pass 配置  ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen:80;</span><br><span class="line">  server_name:lvxueyang.vip;</span><br><span class="line">  location / &#123;</span><br><span class="line">  	proxy_pass http://www.bilibili.com;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们监听 9001 端口，然后把访问不同路径的请求进行反向代理：</p>
<ol>
<li>把访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9001/edu">http://127.0.0.1:9001/edu</a> 的请求转发到 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></li>
<li>把访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:9001/vod">http://127.0.0.1:9001/vod</a> 的请求转发到 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/">http://127.0.0.1:8081</a></li>
</ol>
<p>这种要怎么配置呢，首先同样打开主配置文件，然后在 http 模块下增加一个 server 块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 9001;</span><br><span class="line">  server_name *.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">  location ~ /edu/ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location ~ /vod/ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8081;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反向代理还有一些其他的指令，可以了解一下：</p>
<ol>
<li><p>proxy_set_header：在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</p>
</li>
<li><p>proxy_connect_timeout：配置Nginx与后端代理服务器尝试建立连接的超时时间。</p>
</li>
<li><p>proxy_read_timeout：配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</p>
</li>
<li><p>proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</p>
</li>
<li><p>proxy_redirect：用于修改后端服务器返回的响应头中的Location和Refresh。</p>
</li>
</ol>
<h2 id="跨域-CORS-配置"><a href="#跨域-CORS-配置" class="headerlink" title="跨域 CORS 配置"></a>跨域 CORS 配置</h2><h4 id="跨域的定义"><a href="#跨域的定义" class="headerlink" title="跨域的定义"></a>跨域的定义</h4><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<h4 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h4><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203719.png" alt="img"></p>
<h3 id="使用反向代理解决跨域"><a href="#使用反向代理解决跨域" class="headerlink" title="使用反向代理解决跨域"></a>使用反向代理解决跨域</h3><p>在前端服务地址为 abc.lvxueyang.vip 的页面请求 def.lvxueyang.vip 的后端服务导致的跨域，可以这样配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 9001;</span><br><span class="line">  server_name abc.lvxueyang.vip;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass def.lvxueyang.vip;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就将对前一个域名 abc.lvxueyang.vip的请求全都代理到了 def.lvxueyang.vip，前端的请求都被我们用服务器代理到了后端地址下，绕过了跨域。</p>
<p>这里对静态文件的请求和后端服务的请求都以 abc.lvxueyang.vip开始，不易区分，所以为了实现对后端服务请求的统一转发，通常我们会约定对后端服务的请求加上 /apis/ 前缀或者其他的 path 来和对静态资源的请求加以区分，此时我们可以这样配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 请求跨域，约定代理后端服务请求path以/apis/开头</span><br><span class="line">location ^~/apis/ &#123;</span><br><span class="line">    # 这里重写了请求，将正则匹配中的第一个分组的path拼接到真正的请求后面，并用break停止后续匹配</span><br><span class="line">    rewrite ^/apis/(.*)$ /$1 break;</span><br><span class="line">    proxy_pass def.lvxueyang.vip;</span><br><span class="line">  </span><br><span class="line">    # 两个域名之间cookie的传递与回写</span><br><span class="line">    proxy_cookie_domain abc.lvxueyang.vip def.lvxueyang.vip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，静态资源我们使用 abc.lvxueyang.vip/xx.html，动态资源我们使用 abc.lvxueyang.vip/apis/getAwo，浏览器页面看起来仍然访问的前端服务器，绕过了浏览器的同源策略，毕竟我们看起来并没有跨域。</p>
<h3 id="配置-header-解决跨域"><a href="#配置-header-解决跨域" class="headerlink" title="配置 header 解决跨域"></a>配置 header 解决跨域</h3><p>当浏览器在访问跨源的服务器时，也可以在跨域的服务器上直接设置 Nginx，从而前端就可以无感地开发，不用把实际上访问后端的地址改成前端服务的地址，这样可适性更高。</p>
<p>比如前端站点是 abc.lvxueyang.vip，这个地址下的前端页面请求def.lvxueyang.vip下的资源，比如前者的 abc.lvxueyang.vip/index.html 内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;welcome fe.sherlocked93.club!!&lt;h1&gt;</span><br><span class="line">    &lt;script type=&#x27;text/javascript&#x27;&gt;</span><br><span class="line">    var xmlhttp = new XMLHttpRequest()</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;, &quot;http://def.lvxueyang.vip/index.html&quot;, true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>很明显这里是跨域请求，在浏览器中直接访问 <a target="_blank" rel="noopener" href="http://abc.lvxueyang.vip/index.html">http://abc.lvxueyang.vip/index.html</a> 是可以访问到的，但是在 def.lvxueyang.vip 的 html 页面访问就会出现跨域。</p>
<p>在 /etc/nginx/conf.d/ 文件夹中新建一个配置文件，对应二级域名 def.lvxueyang.vip ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/def.lvxueyang.vip.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  def.lvxueyang.vip;</span><br><span class="line">  </span><br><span class="line">	add_header &#x27;Access-Control-Allow-Origin&#x27; $http_origin;   # 全局变量获得当前请求origin，带cookie的请求不支持*</span><br><span class="line">	add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;    # 为 true 可带上 cookie</span><br><span class="line">	add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;  # 允许请求方法</span><br><span class="line">	add_header &#x27;Access-Control-Allow-Headers&#x27; $http_access_control_request_headers;  # 允许请求的 header，可以为 *</span><br><span class="line">	add_header &#x27;Access-Control-Expose-Headers&#x27; &#x27;Content-Length,Content-Range&#x27;;</span><br><span class="line">	</span><br><span class="line">  if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">		add_header &#x27;Access-Control-Max-Age&#x27; 1728000;   # OPTIONS 请求的有效期，在有效期内不用发出另一条预检请求</span><br><span class="line">		add_header &#x27;Content-Type&#x27; &#x27;text/plain; charset=utf-8&#x27;;</span><br><span class="line">		add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line">    </span><br><span class="line">		return 204;                  # 200 也可以</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	location / &#123;</span><br><span class="line">		root  /usr/share/nginx/html/def;</span><br><span class="line">		index index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 nginx -s reload 重新加载配置。这时再访问 fe.sherlocked93.club/index.html 结果如下，请求中出现了我们刚刚配置的 Header。</p>
<h2 id="地址重写"><a href="#地址重写" class="headerlink" title="地址重写"></a>地址重写</h2><p>有的时候我们的网站更换了域名，但还有用户在使用老的域名访问，这时可以通过nginx的地址重写来让用户跳转到新的域名进行访问。</p>
<p>比如说原来我们用的<a target="_blank" rel="noopener" href="http://www.lvxueyang.com这个域名不用了,现在改成www.lvxueyang.vip了来访问文档项目了;/">www.lvxueyang.com这个域名不用了，现在改成www.lvxueyang.vip了来访问文档项目了；</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.lvxueyang.com; </span><br><span class="line">    </span><br><span class="line">    rewrite &quot;^/(.*)$&quot; http://www.lvxueyang.vip/$1; #地址重写到新地址</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html/docs; </span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问旧域名<a target="_blank" rel="noopener" href="http://www.lvxueyang.com会直接跳转到www.lvxueyang.vip去./">www.lvxueyang.com会直接跳转到www.lvxueyang.vip去。</a></p>
<h2 id="适配PC或移动设备"><a href="#适配PC或移动设备" class="headerlink" title="适配PC或移动设备"></a>适配PC或移动设备</h2><p>现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。</p>
<p>这样的需求有人说拿自适应就可以搞定，比如我们常说的bootstrap和24格布局法，这些确实是非常好的方案，但是无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式。</p>
<p><strong>$http_user_agent的使用：</strong></p>
<p>Nginx通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx2.jspang.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">         root /usr/share/nginx/pc;</span><br><span class="line">         if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) &#123;</span><br><span class="line">            root /usr/share/nginx/mobile;</span><br><span class="line">         &#125;</span><br><span class="line">         index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置高可用集群（双机热备）"><a href="#配置高可用集群（双机热备）" class="headerlink" title="配置高可用集群（双机热备）"></a>配置高可用集群（双机热备）</h2><p>当主 Nginx 服务器宕机之后，切换到备份 Nginx 服务器</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203728.png" alt="img"></p>
<p>首先安装 keepalived，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>

<p>然后编辑 /etc/keepalived/keepalived.conf 配置文件，并在配置文件中增加 vrrp_script 定义一个外围检测机制，并在 vrrp_instance 中通过定义 track_script 来追踪脚本执行过程，实现节点转移：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        acassen@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30 // 上面都是邮件配置，没卵用</span><br><span class="line">   router_id LVS_DEVEL     // 当前服务器名字，用hostname命令来查看</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_maintainace &#123; // 检测机制的脚本名称为chk_maintainace</span><br><span class="line">    script &quot;[[ -e/etc/keepalived/down ]] &amp;&amp; exit 1 || exit 0&quot; // 可以是脚本路径或脚本命令</span><br><span class="line">    // script &quot;/etc/keepalived/nginx_check.sh&quot;    // 比如这样的脚本路径</span><br><span class="line">    interval 2  // 每隔2秒检测一次</span><br><span class="line">    weight -20  // 当脚本执行成立，那么把当前服务器优先级改为-20</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instanceVI_1 &#123;   // 每一个vrrp_instance就是定义一个虚拟路由器</span><br><span class="line">    state MASTER      // 主机为MASTER，备用机为BACKUP</span><br><span class="line">    interface eth0    // 网卡名字，可以从ifconfig中查找</span><br><span class="line">    virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样</span><br><span class="line">    priority 100      // 优先级，master的优先级比backup的大</span><br><span class="line">    advert_int 1      // 默认心跳间隔</span><br><span class="line">    authentication &#123;  // 认证机制</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111   // 密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  // 虚拟地址vip</span><br><span class="line">       172.16.2.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中检测脚本 nginx_check.sh，这里提供一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">A=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    /usr/sbin/nginx # 尝试重新启动nginx</span><br><span class="line">    sleep 2         # 睡眠2秒</span><br><span class="line">    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>复制一份到备份服务器，备份 Nginx 的配置要将 state 后改为 BACKUP，priority 改为比主机小。</p>
<p>设置完毕后各自 service keepalived start 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 service keepalived stop，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。</p>
<p>再次启动 Master 的 keepalived，此时 vip 又变到了主机上。</p>
<h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><p>下载证书的压缩文件，里面有个 nginx 文件夹，把 xxx.crt 和 xxx.key 文件拷贝到服务器目录，再配置下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server;   # SSL 访问端口号为 443</span><br><span class="line">  server_name lvxueyang.vip;         # 填写绑定证书的域名</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/nginx/https/1_lvxueyang.vip_bundle.crt;   # 证书文件地址</span><br><span class="line">  ssl_certificate_key /etc/nginx/https/2_lvxueyang.vip.key;      # 私钥文件地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;      #请按照以下协议配置</span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完 nginx -t -q 校验一下，没问题就 nginx -s reload，现在去访问 <a href="https://lvxueyang.vip/">https://lvxueyang.vip/</a> 就能访问 HTTPS 版的网站了。</p>
<p>一般还可以加上几个增强安全性的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header X-Frame-Options DENY;           # 减少点击劫持</span><br><span class="line">add_header X-Content-Type-Options nosniff; # 禁止服务器自动解析资源类型</span><br><span class="line">add_header X-Xss-Protection 1;             # 防XSS攻击</span><br></pre></td></tr></table></figure>

<h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  static.lvxueyang.vip;</span><br><span class="line">  charset utf-8;    # 防止中文文件名乱码</span><br><span class="line"></span><br><span class="line">  location /download &#123;</span><br><span class="line">    alias	          /usr/share/nginx/html/static;  # 静态资源目录</span><br><span class="line">    </span><br><span class="line">    autoindex               on;    # 开启静态资源列目录</span><br><span class="line">    autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB</span><br><span class="line">    autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;        </span><br><span class="line">  server_name  *.lvxueyang.vip;</span><br><span class="line">  </span><br><span class="line">  # 图片防盗链</span><br><span class="line">  location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">    valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，感谢 @木法传 的提醒，将百度和谷歌也加入白名单</span><br><span class="line">    if ($invalid_referer)&#123;</span><br><span class="line">      return 403;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 非指定请求全返回 403</span><br><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">  return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  # IP访问限制（只允许IP是 192.168.0.2 机器访问）</span><br><span class="line">  allow 192.168.0.2;</span><br><span class="line">  deny all;</span><br><span class="line">  # 限制用户通过某一个连接向Nginx服务器发起请求的次数</span><br><span class="line">  keepalive_requests 5；</span><br><span class="line">  root   html;</span><br><span class="line">  index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单页面项目-history-路由配置"><a href="#单页面项目-history-路由配置" class="headerlink" title="单页面项目 history 路由配置"></a>单页面项目 history 路由配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  lvxueyang.vip;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root       /usr/share/nginx/html/dist;  # vue 打包后的文件夹</span><br><span class="line">    index      index.html index.htm;</span><br><span class="line">    try_files  $uri $uri/ /index.html @rewrites;  </span><br><span class="line">    </span><br><span class="line">    expires -1;                          # 首页一般没有强制缓存</span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  location @rewrites &#123;</span><br><span class="line">    rewrite ^(.+)$ /index.html break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-请求转发到-HTTPS"><a href="#HTTP-请求转发到-HTTPS" class="headerlink" title="HTTP 请求转发到 HTTPS"></a>HTTP 请求转发到 HTTPS</h2><p>配置完 HTTPS 后，浏览器还是可以访问 HTTP 的地址 <a target="_blank" rel="noopener" href="http://www.lvxueyang.vip/">http://www.lvxueyang.vip/</a> 的，可以做一个 301 跳转，把对应域名的 HTTP 请求重定向到 HTTPS 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name www.lvxueyang.vip;</span><br><span class="line"></span><br><span class="line">    # 单域名重定向</span><br><span class="line">    if ($host = &#x27;lvxueyang.vip&#x27;)&#123;</span><br><span class="line">        return 301 https://www.lvxueyang.vip;</span><br><span class="line">    &#125;</span><br><span class="line">    # 全局非 https 协议时重定向</span><br><span class="line">    if ($scheme != &#x27;https&#x27;) &#123;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 或者全部重定向</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line"></span><br><span class="line">    # 以上配置选择自己需要的即可，不用全部加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛域名路径分离"><a href="#泛域名路径分离" class="headerlink" title="泛域名路径分离"></a>泛域名路径分离</h2><p>这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 Nginx 自动指向对应目录，比如：</p>
<ol>
<li>test1.lvxueyang.vip 自动指向 /usr/share/nginx/html/doc/test1 服务器地址；</li>
<li>test2.lvxueyang.vip 自动指向 /usr/share/nginx/html/doc/test2 服务器地址；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ~^([\w-]+)\.lvxueyang\.vip$;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html/doc/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛域名转发"><a href="#泛域名转发" class="headerlink" title="泛域名转发"></a>泛域名转发</h2><p>和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：</p>
<ul>
<li>test1.lvxueyang.vip/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a ；</li>
<li>test2.lvxueyang.vip/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a ；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name ~^([\w-]+)\.lvxueyang\.vip$;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header        Host $http_host;</span><br><span class="line">        proxy_set_header        X-NginX-Proxy true;</span><br><span class="line">        proxy_pass              http://127.0.0.1:8080/$1$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h2><p> 为了提升网站的整体性能，我们一般会采用缓存，从宏观层面来说，会采用浏览器缓存和后端缓存，Nginx处于Web 网站的服务最外层，而且支持浏览器缓存配置和后端数据缓存，用它来做部分数据缓存，效率更高。 Web缓存是可以自动保存常见文档副本的HTTP 设备。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以 从本地设备而不是服务器中提取这个文 档。  </p>
<h3 id="OpenRestry安装"><a href="#OpenRestry安装" class="headerlink" title="OpenRestry安装"></a>OpenRestry安装</h3><p> OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及 大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、 Web 服务和动态网关。 OpenResty 通过lua脚本扩展 nginx 功能，可提供负载均衡、请求路由、安全认证、服务鉴权、流量控制与日志监 控等服务。 OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地 变成一个强大的通用 Web 应用平台。这样， Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持 的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。  </p>
<p> <strong>安装依赖库</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install wget libtermcap-devel ncurses-devel libevent-devel readline-devel pcre-devel gcc</span><br><span class="line">openssl openssl-devel per</span><br></pre></td></tr></table></figure>

<p> <strong>下载安装包</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://openresty.org/download/openresty-1.11.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p> <strong>解压安装</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xf openresty-1.11.2.5.tar.gz</span><br><span class="line">cd openresty-1.11.2.5</span><br><span class="line">./configure --prefix=/usr/local/openresty --with-luajit --without-http_redis2_module --withhttp_stub_status_module --with-http_v2_module --with-http_gzip_static_module --withhttp_sub_module --add-module=/usr/local/server/ngx_cache_purge-2.3/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p> 安装完成后，在 /usr/local/openrestry/nginx 目录下是安装好的nginx。  </p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p> 客户端侧缓存一般指的是浏览器缓存、app缓存等等，目的就是加速各种静态资源的访问，降低服务器压力。 我们通过配置Nginx设置网页缓存信息，从而降低用户对服务器频繁访问造成的巨大压力。我们先配置一个案例，再 基于案例去讲解Nginx缓存。  </p>
<p> <strong>Nginx Web缓存配置</strong>  </p>
<p> nginx 提供了 expires 、 etag 、 if-modified-since 指令来进行浏览器缓存控制。我们使用 expires 来配置 Nginx对网页的缓存。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法: expires [modified] time;</span><br><span class="line">默认值: expires off;</span><br><span class="line">上下文: http, server, location, if in location</span><br></pre></td></tr></table></figure>

<p> 1)上传html </p>
<p>将1.html上传到服务器的 /usr/local/server/html 目录下。 </p>
<p> 2)配置nginx 修改 /usr/local/openrestry/nginx/conf/nginx.conf 文件，配置如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  location / &#123;</span><br><span class="line">    #静态文件路径</span><br><span class="line">    root /usr/local/server/html;</span><br><span class="line">    #缓存10秒</span><br><span class="line">    expires 10s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第一次请求 <a target="_blank" rel="noopener" href="http://192.168.211.141/1.html">http://192.168.211.141/1.html</a></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203736.png" alt="img"></p>
<p> 第二次请求 <a target="_blank" rel="noopener" href="http://192.168.211.141/1.html">http://192.168.211.141/1.html</a></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203742.png" alt="img"></p>
<p><strong>Http缓存控制头</strong> </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203746.png" alt="img"><br> <strong>参数说明：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP 中最基本的缓存机制，涉及到的 HTTP 头字段，包括 Cache-Control, Last-Modified, </span><br><span class="line">If-ModifiedSince, Etag,If-None-Match 等。</span><br><span class="line"></span><br><span class="line">Last-Modified/If-Modified-Since</span><br><span class="line">Etag是服务端的一个资源的标识，在 HTTP 响应头中将其传送到客户端。所谓的服务端资源可以是一个Web页面，也可以是</span><br><span class="line">JSON或XML等。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端。比如，浏览器第一次请求一</span><br><span class="line">个资源的时候，服务端给予返回，并且返回了ETag: &quot;50b1c1d4f775c61:df3&quot; 这样的字样给浏览器，当浏览器再次请求这</span><br><span class="line">个资源的时候，浏览器会将If-None-Match: W/&quot;50b1c1d4f775c61:df3&quot; 传输给服务端，服务端拿到该ETAG，对比资源</span><br><span class="line">是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。</span><br><span class="line"></span><br><span class="line">Last-Modified ：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</span><br><span class="line">If-Modified-Since ：当资源过期时（使用Cache-Control标识的max-age），发现资源具有 Last-Modified 声明，</span><br><span class="line">则再次向web服务器请求时带上头。</span><br><span class="line"></span><br><span class="line">If-Modified-Since ，表示请求时间。web服务器收到请求后发现有头 If-Modified-Since 则与被请求资源的最后修</span><br><span class="line">改时间进行比对。若最后修改时间较新，说明资源有被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若</span><br><span class="line">最后修改时间较旧，说明资源无新修改，则响应 HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的 cache</span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">Pragma行是为了兼容 HTTP1.0 ，作用与 Cache-Control: no-cache 是一样的</span><br><span class="line">Etag/If-None-Match</span><br><span class="line">Etag ：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定),如果给定URL中的资源修</span><br><span class="line">改，则一定要生成新的Etag值。</span><br><span class="line"></span><br><span class="line">If-None-Match ：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务</span><br><span class="line">器请求时带上头 If-None-Match （Etag的值）。web服务器收到请求后发现有头 If-None-Match 则与被请求资源的相</span><br><span class="line">应校验串进行比对，决定返回200或304。</span><br><span class="line"></span><br><span class="line">Etag：</span><br><span class="line">Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的</span><br><span class="line">修改时间，如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓</span><br><span class="line">存有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 Etag是服务器自动生成或者由开发者</span><br><span class="line">生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 Last-Modified 与 ETag 是可以一起使用的，服务</span><br><span class="line">器会优先验证 ETag ，一致的情况下，才会继续比对 Last-Modified ，最后才决定是否返回304。</span><br></pre></td></tr></table></figure>

<h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>用户如果请求获取的数据不是需要后端服务器处理返回，如果我们需要对数据做缓存来提高服务器的处理能力，我们<br>可以按照如下步骤实现：<br>1、请求Nginx，Nginx将请求路由给后端服务<br>2、后端服务查询Redis或者MySQL，再将返回结果给Nginx<br>3、Nginx将结果存入到Nginx缓存，并将结果返回给用户<br>4、用户下次执行同样请求，直接在Nginx中获取缓存数据 </p>
<h4 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h4><p> proxy_cache 是用于 proxy 模式（一般也可称为反代）的缓存功能，proxy_cache 在 Nginx 配置的 http 段、server段（location 段）中分别写入不同的配置。http 段中的配置用于定义 proxy_cache 空间，server 段中的配置用于调用 http 段中的定义，启用对 server 的缓存功能。<br> 属性使用说明<br><strong>proxy_cache_path：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /usr/local/openresty/nginx/cache levels=1:2</span><br><span class="line">keys_zone=openresty_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line">【作用】指定缓存存储的路径，缓存存储在/usr/local/openresty/nginx/cache目录</span><br><span class="line">【levels=1:2】设置一个两级目录层次结构存储缓存，在单个目录中包含大量文件会降低文件访问速度，因此我们建议对大</span><br><span class="line">多数部署使用两级目录层次结构。如果 levels 未包含该参数，Nginx 会将所有文件放在同一目录中。</span><br><span class="line">【keys_zone=openresty_cache:10m】设置共享内存区域，用于存储缓存键和元数据，例如使用计时器。拥有内存中的密</span><br><span class="line">钥副本，Nginx 可以快速确定请求是否是一个 HIT 或 MISS 不必转到磁盘，从而大大加快了检查速度。1 MB 区域可以存</span><br><span class="line">储大约 8,000 个密钥的数据，因此示例中配置的 10 MB 区域可以存储大约 80,000 个密钥的数据。</span><br><span class="line">【max_size=10g】设置缓存大小的上限。它是可选的; 不指定值允许缓存增长以使用所有可用磁盘空间。当缓存大小达到限</span><br><span class="line">制时，一个称为缓存管理器的进程将删除最近最少使用的缓存，将大小恢复到限制之下的文件。</span><br><span class="line">【inactive=60m】指定项目在未被访问的情况下可以保留在缓存中的时间长度。在此示例中，缓存管理器进程会自动从缓存</span><br><span class="line">中删除 60 分钟未请求的文件，无论其是否已过期。默认值为 10 分钟（10m）。非活动内容与过期内容不同。Nginx 不会</span><br><span class="line">自动删除缓存 header 定义为已过期内容（例如 Cache-Control:max-age=120）。过期（陈旧）内容仅在指定时间内未</span><br><span class="line">被访问时被删除。访问过期内容时，Nginx 会从原始服务器刷新它并重置 inactive 计时器。</span><br><span class="line">【use_temp_path=off】表示NGINX会将临时文件保存在缓存数据的同一目录中。这是为了避免在更新缓存时，磁盘之间互</span><br><span class="line">相复制响应数据，我们一般关闭该功能。</span><br></pre></td></tr></table></figure>

<p><strong>proxy_cache：</strong> </p>
<p>设置是否开启对后端响应的缓存，如果开启的话，参数值就是zone的名称，比如:proxy_cache openresty_cache;<br> <strong>proxy_cache_valid：</strong> </p>
<p>对不同的response code设定不同的缓存时间，如果不设置code，默认为200,301,302,也可以用any指定所有code<br>【proxy_cache_valid 200 304 10s;】所有200/304响应的数据都缓存10秒。<br>【proxy_cache_valid any 1m;】所有请求响应的值都缓存1分钟<br> <strong>proxy_cache_min_uses：</strong><br> 指定在多少次请求之后才缓存响应内容,这里表示将缓存内容写入到磁盘。<br>【proxy_cache_min_uses 3;】同一个请求达到了3次，才将缓存写入磁盘。<br> <strong>proxy_cache_lock：</strong><br> 默认不开启，开启的话则每次只能有一个请求更新相同的缓存，其他请求要么等待缓存有数据要么限时等待锁释放;nginx1.1.12才开始有。<br> <strong>proxy_cache_key：</strong><br> 缓存文件的唯一key，可以根据它实现对缓存文件的清理操作 </p>
<h4 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h4><p>我们在 nginx.conf 中添加如下配置： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#缓存配置</span><br><span class="line">proxy_cache_path /usr/local/openresty/nginx/cache levels=1:2 keys_zone=openresty_cache:10m</span><br><span class="line">max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name localhost;</span><br><span class="line">	#html配置</span><br><span class="line">	location ~ \.html &#123;</span><br><span class="line">	# 静态文件路径</span><br><span class="line">	root /usr/local/server/html;</span><br><span class="line">	#缓存10秒</span><br><span class="line">	expires 10s;</span><br><span class="line">&#125; </span><br><span class="line">  #非html配置</span><br><span class="line">location / &#123;</span><br><span class="line">  #启用缓存openresty_cache</span><br><span class="line">  proxy_cache openresty_cache;</span><br><span class="line">  #针对指定请求缓存</span><br><span class="line">  #proxy_cache_methods GET;</span><br><span class="line">  #设置指定请求会缓存</span><br><span class="line">  proxy_cache_valid 200 304 10s;</span><br><span class="line">  #最少请求1次才会缓存</span><br><span class="line">  proxy_cache_min_uses 3;</span><br><span class="line">  #如果并发请求，只有第1个请求会去服务器获取数据</span><br><span class="line">  #proxy_cache_lock on;</span><br><span class="line">      #唯一的key</span><br><span class="line">  proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">  proxy_pass http://myip:18081;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 /usr/local/openresty/nginx/cache 目录下只有1个temp文件夹。<br>我们执行3次请求 <a target="_blank" rel="noopener" href="http://192.168.211.141/user/wangwu%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%AD%A4%E6%97%B6%E5%A4%9A%E4%BA%86%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%BF%99%E4%BA%9B%E7%9B%AE%E5%BD%95%E5%B0%B1%E6%98%AF%E5%AD%98">http://192.168.211.141/user/wangwu，可以发现此时多了一些其他目录，这些目录就是存</a><br>储每个请求对应的缓存。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203756.png" alt="img"></p>
<h2 id="Nginx底层进程机制剖析"><a href="#Nginx底层进程机制剖析" class="headerlink" title="Nginx底层进程机制剖析"></a>Nginx底层进程机制剖析</h2><p>Nginx启动后，以daemon多进程⽅式在后台运⾏，包括⼀个Master进程和多个Worker进程， Master<br>进程是领导，是⽼⼤， Worker进程是⼲活的⼩弟。<br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203801.png" alt="img"></p>
<p><strong>master进程</strong><br>主要是管理worker进程，⽐如：<br>    接收外界信号向各worker进程发送信号(./nginx -s reload)<br>    监控worker进程的运⾏状态，当worker进程异常退出后Master进程会⾃动重新启动新的<br>    worker进程等<br><strong>worker进程</strong><br> worker进程具体处理⽹络请求。多个worker进程之间是对等的，他们同等竞争来⾃客户端的请<br>求， 各进程互相之间是独⽴的。⼀个请求，只可能在⼀个worker进程中处理，⼀个worker进程，<br>不可能处理其它进程的请求。 worker进程的个数是可以设置的，⼀般设置与机器cpu核数⼀致。 </p>
<p><strong>Nginx进程模型示意图如下</strong><br> <img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203805.png" alt="img"></p>
<p>以 ./nginx -s reload 来说明nginx信号处理这部分<br>1） master进程对配置⽂件进⾏语法检查<br>2）尝试配置（⽐如修改了监听端⼝，那就尝试分配新的监听端⼝）<br>3）尝试成功则使⽤新的配置，新建worker进程<br>4）新建成功，给旧的worker进程发送关闭消息<br>5）旧的worker进程收到信号会继续服务，直到把当前进程接收到的请求处理完毕后关闭<br>所以reload之后worker进程pid是发⽣了变化的 </p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210628203810.png" alt="img"></p>
<p><strong>worker进程处理请求部分的说明</strong><br>例如，我们监听9003端⼝，⼀个请求到来时，如果有多个worker进程，那么每个worker进程都有<br>可能处理这个链接。</p>
<ul>
<li><p>master进程创建之后，会建⽴好需要监听的的socket，然后从master进程再fork出多个<br>  worker进程。所以，所有worker进程的监听描述符listenfd在新连接到来时都变得可读。</p>
</li>
<li><p>nginx使⽤互斥锁来保证只有⼀个workder进程能够处理请求，拿到互斥锁的那个进程注册<br>  listenfd读事件，在读事件⾥调⽤accept接受该连接，然后解析、处理、返回客户端<br>  <strong>nginx多进程模型好处</strong></p>
</li>
<li><p>每个worker进程都是独⽴的，不需要加锁，节省开销</p>
</li>
<li><p>每个worker进程都是独⽴的，互不影响，⼀个异常结束，其他的照样能提供服务</p>
</li>
<li><p>多进程模型为reload热部署机制提供了⽀撑 </p>
</li>
</ul>
<h2 id="惊群效应"><a href="#惊群效应" class="headerlink" title="惊群效应"></a>惊群效应</h2><p> Nginx为了充分发挥性能，使用了多个worker子进程监听相同端口的设计，这样多个子进程在accept建立新连接时会有争抢，这会带来著名的“惊群”问题，子进程数量越多越明显，这会造成系统性能的下降。</p>
<p>nginx 通过加锁ngx_accept_mutex 解决了惊群效应。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><ul>
<li>Nginx限流就是限制用户请求速度，防止服务器受不了</li>
<li>限流有3种</li>
</ul>
<ol>
<li><p>正常限制访问频率（正常流量）</p>
</li>
<li><p>突发限制访问频率（突发流量）</p>
</li>
<li><p>限制并发连接数</p>
</li>
</ol>
<ul>
<li>Nginx的限流都是基于漏桶流算法，底下会说道什么是桶铜流</li>
</ul>
<p><strong>实现三种限流算法</strong></p>
<h5 id="正常限制访问频率（正常流量）："><a href="#正常限制访问频率（正常流量）：" class="headerlink" title="正常限制访问频率（正常流量）："></a>正常限制访问频率（正常流量）：</h5><ul>
<li>限制一个用户发送的请求，我Nginx多久接收一个请求。</li>
<li>Nginx中使用ngx_http_limit_req_module模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class="line"></span><br><span class="line">#绑定限流维度</span><br><span class="line">server&#123;</span><br><span class="line">	</span><br><span class="line">	location/seckill.html&#123;</span><br><span class="line">		limit_req zone=zone;	</span><br><span class="line">		proxy_pass http://lj_seckill;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1r/s代表1秒一个请求，1r/m一分钟接收一个请求， 如果Nginx这时还有别人的请求没有处理完，Nginx就会拒绝处理该用户请求。</li>
</ul>
<h5 id="突发限制访问频率（突发流量）："><a href="#突发限制访问频率（突发流量）：" class="headerlink" title="突发限制访问频率（突发流量）："></a>突发限制访问频率（突发流量）：</h5><ul>
<li>限制一个用户发送的请求，我Nginx多久接收一个。</li>
<li>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？Nginx提供burst参数结合nodelay参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加burst参数以及nodelay参数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class="line"></span><br><span class="line">#绑定限流维度</span><br><span class="line">server&#123;</span><br><span class="line">	</span><br><span class="line">	location/seckill.html&#123;</span><br><span class="line">		limit_req zone=zone burst=5 nodelay;</span><br><span class="line">		proxy_pass http://lj_seckill;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表Nginx对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求</li>
</ul>
<h5 id="限制并发连接数"><a href="#限制并发连接数" class="headerlink" title="限制并发连接数"></a>限制并发连接数</h5><ul>
<li>Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。接下来我们可以通过一个简单的例子来看下：</li>
</ul>
<p>上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lvxueyang.vip/post/65b69107.html">http://lvxueyang.vip/post/65b69107.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lvxueyang.vip" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165212.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f46cf4b5.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165213.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Shiro从入门到放弃</div></div></a></div><div class="next-post pull-right"><a href="/post/7b97cc4c.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20210806165209.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot之Test</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/8eebb21.html" title="Nginx架构"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Nginx架构</div></div></a></div><div><a href="/post/cc1b6e67.html" title="Nginx简介"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Nginx简介</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.</span> <span class="toc-text">Nginx基础回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E6%A0%B8%E2%BC%BC%E9%85%8D%E7%BD%AE%E2%BD%82%E4%BB%B6%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.</span> <span class="toc-text">Nginx核⼼配置⽂件解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Nginx配置语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gzip%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.</span> <span class="toc-text">gzip压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">6.</span> <span class="toc-text">配置负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">7.</span> <span class="toc-text">配置动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA"><span class="toc-number">8.</span> <span class="toc-text">设置二级域名虚拟主机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">配置反向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F-CORS-%E9%85%8D%E7%BD%AE"><span class="toc-number">10.</span> <span class="toc-text">跨域 CORS 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.0.1.</span> <span class="toc-text">跨域的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.0.2.</span> <span class="toc-text">同源的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">10.1.</span> <span class="toc-text">使用反向代理解决跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-header-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">10.2.</span> <span class="toc-text">配置 header 解决跨域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99"><span class="toc-number">11.</span> <span class="toc-text">地址重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8DPC%E6%88%96%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">12.</span> <span class="toc-text">适配PC或移动设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%EF%BC%88%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">配置高可用集群（双机热备）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-HTTPS"><span class="toc-number">14.</span> <span class="toc-text">配置 HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1"><span class="toc-number">15.</span> <span class="toc-text">静态服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-number">16.</span> <span class="toc-text">图片防盗链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BF%87%E6%BB%A4"><span class="toc-number">17.</span> <span class="toc-text">请求过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E9%A1%B9%E7%9B%AE-history-%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE"><span class="toc-number">18.</span> <span class="toc-text">单页面项目 history 路由配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0-HTTPS"><span class="toc-number">19.</span> <span class="toc-text">HTTP 请求转发到 HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%B7%AF%E5%BE%84%E5%88%86%E7%A6%BB"><span class="toc-number">20.</span> <span class="toc-text">泛域名路径分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%BD%AC%E5%8F%91"><span class="toc-number">21.</span> <span class="toc-text">泛域名转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E7%BC%93%E5%AD%98"><span class="toc-number">22.</span> <span class="toc-text">Nginx缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenRestry%E5%AE%89%E8%A3%85"><span class="toc-number">22.1.</span> <span class="toc-text">OpenRestry安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">22.2.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="toc-number">22.3.</span> <span class="toc-text">代理缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy-cache"><span class="toc-number">22.3.1.</span> <span class="toc-text">proxy_cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="toc-number">22.3.2.</span> <span class="toc-text">缓存操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E5%BA%95%E5%B1%82%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90"><span class="toc-number">23.</span> <span class="toc-text">Nginx底层进程机制剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94"><span class="toc-number">24.</span> <span class="toc-text">惊群效应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">25.</span> <span class="toc-text">限流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%EF%BC%88%E6%AD%A3%E5%B8%B8%E6%B5%81%E9%87%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">正常限制访问频率（正常流量）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%81%E5%8F%91%E9%99%90%E5%88%B6%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%EF%BC%88%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F%EF%BC%89%EF%BC%9A"><span class="toc-number">25.0.0.2.</span> <span class="toc-text">突发限制访问频率（突发流量）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E6%95%B0"><span class="toc-number">25.0.0.3.</span> <span class="toc-text">限制并发连接数</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>