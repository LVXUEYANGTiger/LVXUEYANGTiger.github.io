<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>DockerFile | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Docker"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述我们可以把刚才的对容器的所有操作命令都记录到一个文件里，就像写更脚本程序。 之后用 docker build 命令以此文件为基础制作一个镜像，并会自动提交到本地仓库。 这样的话镜像的构建会变的透明化，对镜像的维护起来也更加简单，只修改这个文件即可。 同时分享也更加简单快捷，因为只要分享这个文件即可。 Dokcerfile 是一个普通的文本文件，文件名一般叫 Dockerfile 其中包含了一系">
<meta property="og:type" content="article">
<meta property="og:title" content="DockerFile">
<meta property="og:url" content="https://lvxueyangtiger.github.io/post/f61655ea.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="概述我们可以把刚才的对容器的所有操作命令都记录到一个文件里，就像写更脚本程序。 之后用 docker build 命令以此文件为基础制作一个镜像，并会自动提交到本地仓库。 这样的话镜像的构建会变的透明化，对镜像的维护起来也更加简单，只修改这个文件即可。 同时分享也更加简单快捷，因为只要分享这个文件即可。 Dokcerfile 是一个普通的文本文件，文件名一般叫 Dockerfile 其中包含了一系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212055.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.193Z">
<meta property="article:modified_time" content="2022-11-27T09:16:30.695Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212055.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="https://lvxueyangtiger.github.io/post/f61655ea"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DockerFile',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 17:16:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212055.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DockerFile</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.193Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T09:16:30.695Z" title="更新于 2022-11-27 17:16:30">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/">java学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%AD%A6%E4%B9%A0/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="DockerFile"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们可以把刚才的对容器的所有操作命令都记录到一个文件里，就像写更脚本程序。</p>
<p>之后用 docker build 命令以此文件为基础制作一个镜像，并会自动提交到本地仓库。</p>
<p>这样的话镜像的构建会变的透明化，对镜像的维护起来也更加简单，只修改这个文件即可。</p>
<p>同时分享也更加简单快捷，因为只要分享这个文件即可。</p>
<p>Dokcerfile 是一个普通的文本文件，文件名一般叫 Dockerfile</p>
<p>其中包含了一系列的指令(Instruction)， 每一条指令都会构建一层，就是描述该层是如何创建的。</p>
<h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h4 id="编辑-Dockerfile-文件"><a href="#编辑-Dockerfile-文件" class="headerlink" title="编辑 Dockerfile 文件"></a>编辑 Dockerfile 文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat Dockerfile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>详细内容</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER    author <span class="string">&quot;author@xxxx.com&quot;</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     useradd baiyp</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;baiyp:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure>

<h5 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h5><ul>
<li>FORM 定义一个基础镜像</li>
<li>MAINTAINER 指定作者</li>
<li>LABEL 定义一些元数据信息，比如作者、版本、关于镜像的描述信息</li>
<li>RUN 行命令行的命令</li>
<li>EXPOSE 暴露容器端口</li>
<li>CMD exec模式</li>
</ul>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><h5 id="命令语法格式"><a href="#命令语法格式" class="headerlink" title="命令语法格式"></a>命令语法格式</h5><blockquote>
<p>docker bulid -t 仓库名/镜像名:tag .</p>
</blockquote>
<h5 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t centos:<span class="built_in">test</span> .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印信息</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  35.84kB</span><br><span class="line">Step 1/9 : FROM    centos:6.7</span><br><span class="line"> ---&gt; 9f1de3c6ad53</span><br><span class="line">Step 2/9 : MAINTAINER    author <span class="string">&quot;author@xxxx.com&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d8598710b287</span><br><span class="line">Removing intermediate container d8598710b287</span><br><span class="line"> ---&gt; 29575eb94c47</span><br><span class="line">Step 3/9 : RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 14609bc56811</span><br><span class="line">Removing intermediate container 14609bc56811</span><br><span class="line"> ---&gt; bf3c9f2538e2</span><br><span class="line">Step 4/9 : RUN     useradd baiyp</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 1b8edada3749</span><br><span class="line">Removing intermediate container 1b8edada3749</span><br><span class="line"> ---&gt; eec3097321fc</span><br><span class="line">Step 5/9 : RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;baiyp:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> ecda90b62c1d</span><br><span class="line">Removing intermediate container ecda90b62c1d</span><br><span class="line"> ---&gt; 8c50a85f9811</span><br><span class="line">Step 6/9 : RUN     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 07420e079c63</span><br><span class="line">Removing intermediate container 07420e079c63</span><br><span class="line"> ---&gt; 06cb8a6fa648</span><br><span class="line">Step 7/9 : EXPOSE  22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> a6168fe82b15</span><br><span class="line">Removing intermediate container a6168fe82b15</span><br><span class="line"> ---&gt; 0560cb59d461</span><br><span class="line">Step 8/9 : EXPOSE  80</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 4222e011e4c7</span><br><span class="line">Removing intermediate container 4222e011e4c7</span><br><span class="line"> ---&gt; 04528ff76564</span><br><span class="line">Step 9/9 : CMD     /usr/sbin/sshd -D</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9e4f2ffb0066</span><br><span class="line">Removing intermediate container 9e4f2ffb0066</span><br><span class="line"> ---&gt; a1969a6700f2</span><br><span class="line">Successfully built a1969a6700f2		<span class="comment"># 表示构建成功</span></span><br><span class="line">Successfully tagged centos:<span class="built_in">test</span>		<span class="comment"># TAG 标签</span></span><br></pre></td></tr></table></figure>

<h5 id="上下文-context"><a href="#上下文-context" class="headerlink" title="上下文(context)"></a>上下文(context)</h5><p> 这个 <code>.</code> 表示当前目录，这实际上是在指定上下文的目录是当前目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p> <code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<h4 id="最佳实战"><a href="#最佳实战" class="headerlink" title="最佳实战"></a>最佳实战</h4><p> 一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的</p>
<p> <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.qf</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p> 一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Dockerfile.qf</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── a.txt</span><br><span class="line">    ├── b.txt</span><br><span class="line">    └── test.qf</span><br><span class="line">[root@localhost dockerfile_qf_ignore]<span class="comment"># cat Dockerfile.qf</span></span><br><span class="line">FROM alpine</span><br><span class="line">COPY ./test.qf /root/test.qf</span><br><span class="line">$ docker build -f ../Dockerfile.qf -t alpine:test.qf .</span><br><span class="line">$ docker run -it alpine:test.qf /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h3><h4 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h4><blockquote>
<p>主要作用是指定一个镜像作为构建自定义镜像的基础镜像，在这个基础镜像之上进行修改定制。</p>
</blockquote>
<p>这个指令是 Dockerfile 中的必备指令，同时也必须是第一条指令。</p>
<p>在 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/">Docker Store</a> 上有很多高质量的官方镜像，可以直接作为我们的基础镜像。</p>
<p>作为服务类的，如 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/nginx/">Nginx</a> <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/mongo/">Mongo</a> 等</p>
<p>用于开发的， 如 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/python/">Python</a> <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/golang/">golang</a></p>
<p>操作系统类， 如 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/centos/">Centos</a> <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://store.docker.com/images/ubuntu/">ubuntu</a></p>
<p>除了一些现有的镜像，Docker 还有一个特殊的镜像 <code>scratch</code></p>
<blockquote>
<p>这个镜像是虚拟的，表示空白镜像</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FORM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这以为着这将不以任何镜像为基础镜像。</p>
<p>可以把可执行的二进制文件复制到镜像中直接执行，容器本身就是和宿主机共享 Linux内核的。</p>
<p>使用 Go 语言开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h5 id="制作-Hello-world"><a href="#制作-Hello-world" class="headerlink" title="制作 Hello world"></a>制作 Hello world</h5><h6 id="安装-gcc"><a href="#安装-gcc" class="headerlink" title="安装 gcc"></a>安装 gcc</h6><blockquote>
<p>在任意一台 Linux 机器上，安装 gcc</p>
</blockquote>
<blockquote>
<p>查看有没有安装</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa gcc glibc-static</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有的话，进行安装即可</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install gcc glibc-static</span><br></pre></td></tr></table></figure>

<h6 id="编辑-C-源代码文件"><a href="#编辑-C-源代码文件" class="headerlink" title="编辑 C 源代码文件"></a>编辑 C 源代码文件</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat hello.c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看文件内容</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello, Yangge! \n&quot;</span>);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc --static hello.c -o hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译好后，测试一下</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">hello  hello.c</span><br><span class="line"><span class="comment"># hello   是我们编译好的二进制文件</span></span><br><span class="line"><span class="comment"># hello.c 是 C 的源码文件</span></span><br><span class="line">$ ./hello</span><br><span class="line">Hello Yangge     <span class="comment"># 输出结果，说明编译成功</span></span><br></pre></td></tr></table></figure>

<h6 id="编辑-Dockerfile"><a href="#编辑-Dockerfile" class="headerlink" title="编辑 Dockerfile"></a>编辑 Dockerfile</h6><blockquote>
<p>在有 hello 二进制的文件目录下，编译 Dockerfile 文件，内容如下：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile  hello  hello.c</span><br><span class="line">$ cat Dockerfile</span><br><span class="line">FROM scratch</span><br><span class="line">ADD hello /</span><br><span class="line">CMD [<span class="string">&quot;/hello&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>ADD 是把当前目录下的 hello 文档拷贝到 容器中的根目录下</li>
<li>CMD 执行根目录下的 hello 文件</li>
</ul>
<h6 id="构建新的镜像"><a href="#构建新的镜像" class="headerlink" title="构建新的镜像"></a>构建新的镜像</h6><blockquote>
<p>注意命令的最后有个 <code>.</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t xiguatian/hello-yangge .</span><br><span class="line">Sending build context to Docker daemon  868.9kB</span><br><span class="line">Step 1/3 : FROM scratch</span><br><span class="line"> ---&gt;</span><br><span class="line">Step 2/3 : ADD hello /</span><br><span class="line"> ---&gt; 63ed3c13b7fd</span><br><span class="line">Step 3/3 : CMD [<span class="string">&quot;/hello&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> a26622affa68</span><br><span class="line">Removing intermediate container a26622affa68</span><br><span class="line"> ---&gt; dfadd4a86525</span><br><span class="line">Successfully built dfadd4a86525</span><br><span class="line">Successfully tagged xiguatian/hello-yange:latest</span><br></pre></td></tr></table></figure>

<h6 id="查看本地仓库验证"><a href="#查看本地仓库验证" class="headerlink" title="查看本地仓库验证"></a>查看本地仓库验证</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker image ls xiguatian/hello-yange</span><br><span class="line">REPOSITORY             TAG    IMAGE ID     CREATED         SIZE</span><br><span class="line">xiguatian/hello-yange latest dfadd4a86525  3 minutes ago   865kB</span><br></pre></td></tr></table></figure>

<p>可以看到镜像很小</p>
<h6 id="利用新的镜像运行一个容器"><a href="#利用新的镜像运行一个容器" class="headerlink" title="利用新的镜像运行一个容器"></a>利用新的镜像运行一个容器</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm qf/hello-yange</span><br><span class="line">Hello Yangge</span><br></pre></td></tr></table></figure>

<h5 id="关于-Alpine"><a href="#关于-Alpine" class="headerlink" title="关于 Alpine"></a>关于 Alpine</h5><blockquote>
<p>Alpine Linux是一款独立的非商业性通用Linux发行版，专为那些了解安全性，简单性和资源效率的高级用户而设计。</p>
</blockquote>
<h6 id="小"><a href="#小" class="headerlink" title="小"></a>小</h6><p> Alpine Linux围绕musl libc和busybox构建。这使得它比传统的GNU / Linux发行版更小，更节省资源。一个容器需要不超过8 MB的空间，而对磁盘的最小安装需要大约130 MB的存储空间。您不仅可以获得完整的Linux环境，还可以从存储库中选择大量的软件包。</p>
<p> 二进制软件包被缩减和拆分，使您可以更好地控制安装的内容，从而使您的环境尽可能地小巧高效。</p>
<h6 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h6><p> Alpine Linux是一个非常简单的发行版，它会尽量避免使用。它使用自己的包管理器，称为apk，OpenRC init系统，脚本驱动的设置，就是这样！这为您提供了一个简单，清晰的Linux环境，没有任何噪音。然后，您可以添加项目所需的软件包，因此无论是构建家用PVR还是iSCSI存储控制器，薄型邮件服务器容器或坚如磐石的嵌入式交换机，其他都不会挡道。</p>
<h6 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h6><p> Alpine Linux的设计考虑到了安全性。内核修补了一个非官方的grsecurity / PaX端口，并且所有的用户级二进制文件被编译为位置独立可执行文件（PIE）和堆栈粉碎保护。这些主动安全功能可防止利用整个类别的零日等漏洞。</p>
<h4 id="LABEL-指令"><a href="#LABEL-指令" class="headerlink" title="LABEL 指令"></a>LABEL 指令</h4><blockquote>
<p>LABEL 指令用于指定一个镜像的描述信息</p>
</blockquote>
<p>该<code>LABEL</code>指令将元数据添加到镜像中。</p>
<p><code>LABEL</code>是一个键值对。</p>
<p>要在<code>LABEL</code>值中包含空格，请像在命令行解析中一样使用引号和续行符<code>\</code>。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>几个用法示例</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LABEL maintainer=<span class="string">&quot;yangge@qf.com&quot;</span></span><br><span class="line">LABEL <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span><br><span class="line">LABEL com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span><br><span class="line">LABEL version=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">LABEL description=<span class="string">&quot;This text illustrates \</span></span><br><span class="line"><span class="string">that label-values can span multiple lines.&quot;</span></span><br></pre></td></tr></table></figure>

<p>一个镜像可以有多个<code>LABEL</code>标签。您可以在一行中指定多个标签。并且目前的版本不再会影响到镜像的大小了。</p>
<p>但是仍然可以把他们写在一行或用反斜线进行续航</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">&quot;value1&quot;</span> multi.label2=<span class="string">&quot;value2&quot;</span> other=<span class="string">&quot;value3&quot;</span></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">LABEL multi.label1=<span class="string">&quot;value1&quot;</span> \</span><br><span class="line">      multi.label2=<span class="string">&quot;value2&quot;</span> \</span><br><span class="line">      other=<span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>有继承关系的镜像，标签也会有面向对象编程中继承的关系和特性</strong></p>
<p>要查看镜像的 <code>LABEL</code> 信息，请使用该<code>docker inspect</code>命令。</p>
<h4 id="ENV-指令"><a href="#ENV-指令" class="headerlink" title="ENV 指令"></a>ENV 指令</h4><blockquote>
<p><strong>用于设置环境变量</strong></p>
</blockquote>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><blockquote>
<p>语法格式有两种</p>
</blockquote>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>推荐的方式，易读</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line"> NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不推荐都方式，不易读</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br></pre></td></tr></table></figure>

<h5 id="其他指令使用"><a href="#其他指令使用" class="headerlink" title="其他指令使用"></a>其他指令使用</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$NODE_VERSION</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下列指令可以支持环境变量： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p>
<h4 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h4><blockquote>
<p><code>RUN</code> 指令是在容器内执行 shell 命令，默认会是用 <code>/bin/sh -c</code> 的方式执行。</p>
</blockquote>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><blockquote>
<p>语法格式有两种</p>
</blockquote>
<ul>
<li><code>RUN &lt;command&gt;</code>（<strong>shell</strong>形式，该命令在shell中运行）</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>（<strong>exec</strong>形式）</li>
</ul>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>注意：<strong>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</strong></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><blockquote>
<p>在使用 <em>shell</em> 方式，尽量多的使用续行符<code>\</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">RUN /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; \</span></span><br><span class="line"><span class="string"> echo $HOME&#x27;</span></span><br></pre></td></tr></table></figure>

<p>写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<h6 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h6><p>注意当使用 <code>exec</code> 方式时，需要明确指定 <code>shell</code> 路径，否则变量可能不会生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">ENV name=<span class="string">&quot;yangge&quot;</span></span><br><span class="line">RUN [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;<span class="variable">$name</span>&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201291923240.png" alt="img"></p>
<blockquote>
<p>可以看到 <code>$name</code> 被作为普通的字符串输出了，因为 <code>$name</code> 是 shell 中的用法，而这里里并没有 使用到 shell</p>
</blockquote>
<h6 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">ENV name=<span class="string">&quot;yangge&quot;</span></span><br><span class="line">RUN [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/bin/echo <span class="variable">$name</span>&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> <strong>exec</strong>的方式下，列表中的内容会被解析为JSON数组，这意味着您必须在单词周围使用双引号（“） 而非单引号（’）。</p>
</blockquote>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202201291923834.png" alt="img"></p>
<h4 id="CMD-指令"><a href="#CMD-指令" class="headerlink" title="CMD 指令"></a>CMD 指令</h4><blockquote>
<p><code>Dockerfile</code> 中只能有一条<code>CMD</code>指令。如果列出多个，<code>CMD</code> 则只有最后一个<code>CMD</code>会生效。</p>
</blockquote>
<p><strong>CMD 主要目的是为运行容器时提供默认值</strong></p>
<p> Docker 不是虚拟机，容器就是进程，<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。在启动(运行)一个容器时可以指定新的命令来替代镜像设置中的这个默认命令。</p>
<p>可以包含可执行文件，当然也可以省略。</p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><blockquote>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
</blockquote>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
</ul>
<p>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</p>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><blockquote>
<p><strong>注意</strong>：不要混淆<code>RUN</code> 和 <code>CMD</code>。<code>RUN</code>实际上运行一个命令并提交结果; <code>CMD</code>在构建时不执行任何操作，但指定镜像的默认命令。</p>
</blockquote>
<p>Docker 不是虚拟机，容器内没有后台服务的概念。</p>
<p>不要期望这样启动一个程序到后台:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CMD systemctl start nginx</span><br></pre></td></tr></table></figure>

<p>这行被 <code>Docker</code> 理解为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CMD [<span class="string">&quot;sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;systemctl start nginx&quot;</span>]</span><br></pre></td></tr></table></figure>

<p> 对于容器而言，其启动程序就是容器的应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p> 就像上面的示例中，主进程是 <code>sh</code> , 那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会使容器退出。</p>
<p> 正确的做法是直接执行 <code>nginx</code> 这个可执行文件，并且关闭后台守护的方式，使程序在前台运行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="ENTRYPOINT-指令"><a href="#ENTRYPOINT-指令" class="headerlink" title="ENTRYPOINT 指令"></a>ENTRYPOINT 指令</h4><blockquote>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器的启动程序及参数。</p>
</blockquote>
<p> <code>ENTRYPOINT</code> 在运行时也可以被替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p> <code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，也分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<h5 id="ENTRYPOINT和CMD区别"><a href="#ENTRYPOINT和CMD区别" class="headerlink" title="ENTRYPOINT和CMD区别"></a>ENTRYPOINT和CMD区别</h5><blockquote>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，也就是实际执行时，将变为：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？</p>
<p>这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 给我们带来了什么好处么？</p>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>让我们来看几个场景。</p>
</blockquote>
<h6 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h6><blockquote>
<p>让镜像变成像命令一样使用</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum update \</span><br><span class="line">    &amp;&amp; yum install -y curl</span><br><span class="line">CMD [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构建镜像后, 运行容器</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm centos-echo-ip-cmd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行下面命令会报错</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm centos-echo-ip-cmd -i</span><br></pre></td></tr></table></figure>

<p> 我们可以看到报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 并不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。</p>
<p> 而是替换了原来的 <code>CMD</code>，变成了 <code>CMD [&quot;-i&quot;]</code>，而 <code>-i</code> 根本不是命令，所以报了<code>可执行文件找不到</code>。</p>
<p><strong>所以应该使用 <code>ENTRYPOINT</code> 方式</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y curl</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次构建镜像后</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm centos-echo-ip-entrypoint</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行容器</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm centos-echo-ip-entrypoint -i</span><br></pre></td></tr></table></figure>

<p>这样的话, 最终的指令就变成 <code>ENTRYPOINT [&quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot;, &quot;-i&quot;]</code></p>
<h6 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h6><blockquote>
<p>应用运行前的准备工作</p>
</blockquote>
<p> 启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<blockquote>
<p>官方镜像 <code>redis</code> 中的示例：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>可以看到其中为 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R redis .</span><br><span class="line">    <span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>

<p><strong>注意： <code>ENTRYPOINT</code> 指令不会被 <code>RUN</code> 指令覆盖，而 <code>CMD</code> 指令会被 <code>RUN</code> 指令覆盖</strong></p>
<h4 id="WORKDIR-指令"><a href="#WORKDIR-指令" class="headerlink" title="WORKDIR 指令"></a>WORKDIR 指令</h4><blockquote>
<p>用于声明当前的工作目录，以后各层的当前目录就被改为指定的目录。</p>
</blockquote>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><blockquote>
<p>WORKDIR &lt;工作目录路径&gt;</p>
</blockquote>
<p>如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>再次强调！不要以为编写 <code>Dockerfiel</code> 是在写 <code>shell</code> 脚本。</p>
</blockquote>
<h6 id="错误示例-1"><a href="#错误示例-1" class="headerlink" title="错误示例"></a>错误示例</h6><blockquote>
<p>下面是一个错误示例</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /app</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span><br></pre></td></tr></table></figure>

<p> 如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。</p>
<p> 原因其实很简单，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p> 之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。</p>
<p> 两行 <code>RUN</code> 分别构建了并启动了各自全新的容器。</p>
<h6 id="正确示例"><a href="#正确示例" class="headerlink" title="正确示例"></a>正确示例</h6><blockquote>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">WORKDIR /a/b</span><br><span class="line">RUN touch a_b_f.txt</span><br><span class="line">WORKDIR /a</span><br><span class="line">RUN touch a_f.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行容器</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run -it alpine:workdir /bin/sh</span><br><span class="line">/a <span class="comment"># ls</span></span><br><span class="line">a_f.txt  b</span><br><span class="line">/a <span class="comment"># cd b</span></span><br><span class="line">/a/b <span class="comment"># ls</span></span><br><span class="line">a_b_f.txt</span><br></pre></td></tr></table></figure>

<h4 id="COPY-指令"><a href="#COPY-指令" class="headerlink" title="COPY 指令"></a>COPY 指令</h4><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<h6 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h6><p> <code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于 <code>WORKDIR</code> 指定的工作目录的相对路径。目标路径不需要事先创建，如果目录不存在会在复制文件前先被创建。</p>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p><code>COPY</code> 指令将会从构建的上下文目录中，把源路径的文件或目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY qf.json /usr/src/app/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意下面是错误的</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY qf.json /usr/src/app</span><br></pre></td></tr></table></figure>

<p>这样会把 <code>qf.json</code> 拷贝成为 <code>/usr/src/</code> 目录下的 <code>app</code> 文件</p>
<p><code>&lt;源路径&gt;</code> 可以是多个，支持通配符，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY qf* /app/</span><br><span class="line">COPY q?.txt /app/</span><br></pre></td></tr></table></figure>

<p>使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。</p>
<p>比如读、写、执行权限、文件变更时间等。</p>
<h4 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a>ADD 指令</h4><blockquote>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
</blockquote>
<p> 支持自动解压缩，压缩格式支持： <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code></p>
<p> 官方推荐使用 <code>COPY</code> 进行文件的复制。</p>
<p> <code>ADD</code> 指定会使构建镜像时的缓存失效，导致构建镜像的速度很慢。</p>
<p> <code>COPY</code> 和 <code>ADD</code> 指令中选择的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">复制ADD qf.tar.gz  /</span><br></pre></td></tr></table></figure>

<h4 id="USER-指令"><a href="#USER-指令" class="headerlink" title="USER 指令"></a>USER 指令</h4><blockquote>
<p><code>USER</code> 则是改变执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
</blockquote>
<p>这个用户必须是事先在容器内存在(建立好)的，否则无法切换。</p>
<p> 如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</span> \</span><br><span class="line">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line">CMD [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>

<h4 id="HEALTHCHECK-健康检查指令"><a href="#HEALTHCHECK-健康检查指令" class="headerlink" title="HEALTHCHECK 健康检查指令"></a>HEALTHCHECK 健康检查指令</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<h5 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h5><blockquote>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器后的状态变化会是下面的演变过程：</p>
</blockquote>
<p>初始状态会为 <code>starting</code></p>
<ol>
<li><p>在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code></p>
</li>
<li><p>如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p> <code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
<li><code>--start-period=&lt;时长&gt;</code>: 容器的初始化实长，默认0秒，不计入健康检测时间内。</li>
</ul>
<p> 和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 在 Dockerfile 中只可以出现一次，如果写了多个，只有最后一个生效。</p>
</li>
<li><p>后面的命令同样支持 <code>shell</code> 方式和 <code>exec</code> 方式。</p>
</li>
<li><p>命令的返回值决定了该次健康检查的成功与否：</p>
<p> <code>0</code>：成功；<code>1</code>：失败。</p>
</li>
</ol>
<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><blockquote>
<p>使用 <code>curl</code> 命令来判断 nginx 提供的 web 服务是否正常。</p>
</blockquote>
<p>其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN rpm -ivh \</span><br><span class="line">http://mirrors.aliyun.com/epel/epel-release-latest-7.noarch.rpm &amp;&amp;  yum install nginx \</span><br><span class="line">                curl -y</span><br><span class="line">ADD index.html /usr/share/nginx/html/index.html</span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs \</span><br><span class="line">            http://localhost/ || <span class="built_in">exit</span> 1</span><br><span class="line">CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>

<p>这里设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>构建镜像后， 启动容器，并观察容器的状态变化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t ali_nginx .</span><br><span class="line">$ docker run -d ali_nginx</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED     STATUS                            PORTS        NAMES</span><br><span class="line">09a8b90b0f67  ali_nginx   <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   4 seconds ago       Up 3 seconds (health: starting)   80/tcp      vigorous_jang</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">09a8b90b0f67        ali_nginx           <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   19 seconds ago      Up 18 seconds (healthy)   80/tcp              vigorous_jang</span><br></pre></td></tr></table></figure>

<p>利用元数据查看容器的健康状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> vigorous_jang | python -m json.tool</span><br></pre></td></tr></table></figure>

<h4 id="ONBILUD-指令"><a href="#ONBILUD-指令" class="headerlink" title="ONBILUD 指令"></a>ONBILUD 指令</h4><blockquote>
<p><code>ONBILUD</code> 指令用于当其他 Dockerfile 以自己为基础镜像时将会运行的命令。</p>
</blockquote>
<h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><blockquote>
<p>ONBUILD &lt;其它指令&gt;</p>
</blockquote>
<p>其他指令可以是： 比如 <code>RUN</code>, <code>COPY</code> 等。</p>
<h5 id="基础应用场景"><a href="#基础应用场景" class="headerlink" title="基础应用场景"></a>基础应用场景</h5><blockquote>
<p>假如有两个项目 A 和 B，两个项目想分别有不同的文件</p>
</blockquote>
<h6 id="A-项目下的文件"><a href="#A-项目下的文件" class="headerlink" title="A 项目下的文件"></a>A 项目下的文件</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree A/</span><br><span class="line">A/</span><br><span class="line">├── a1.txt</span><br><span class="line">└── a.txt</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure>

<h6 id="B-项目下的文件"><a href="#B-项目下的文件" class="headerlink" title="B 项目下的文件"></a>B 项目下的文件</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree B</span><br><span class="line">B</span><br><span class="line">├── b1.txt</span><br><span class="line">├── b2.txt</span><br><span class="line">└── b.txt</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<h6 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h6><blockquote>
<p>现在任意的空目录下创建一个 <code>Dockerfile</code></p>
<p>文件内容：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line">FROM alpine</span><br><span class="line">ONBUILD COPY . /root/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着用这个 Dockerfile 来构建一个所有项目都要使用的一个基础镜像</p>
</blockquote>
<p>镜像名字： <code>alpine-base</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t alpine-base .</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/2 : FROM alpine</span><br><span class="line"> ---&gt; 3fd9065eaf02</span><br><span class="line">Step 2/2 : ONBUILD COPY . /root/</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 4d6fad2809be</span><br><span class="line">Removing intermediate container 4d6fad2809be</span><br><span class="line"> ---&gt; 804bfc0b47be</span><br><span class="line">Successfully built 804bfc0b47be</span><br><span class="line">Successfully tagged alpine-base:latest</span><br></pre></td></tr></table></figure>

<p>当使用这个镜像去运行容器的时候。查看 <code>/root</code> 目录下，可发现并没有任何东西，</p>
<blockquote>
<p>说明 <code>COPY . /root/</code> 并没有此次构建镜像的过程中去执行。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm alpine-base:latest ls /root/</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在我们在使用刚才构建的镜像为项目 A 的基础镜像，来构建 A 项目的镜像</p>
</blockquote>
<p>想看看目前 A 项目下的文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> A</span><br><span class="line">$ ls</span><br><span class="line">a1.txt  a.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在项目的 <code>A</code> 目录下编写 <code>Dockerfile</code> 文件内容如下：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line">FROM alpine-base:latest</span><br></pre></td></tr></table></figure>

<p>是的只需要这一行即可</p>
<blockquote>
<p>现在让我们来构建 <code>A</code> 项目的镜像</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t alpine-a .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/1 : FROM alpine-base:latest</span><br><span class="line"><span class="comment"># Executing 1 build trigger</span></span><br><span class="line"> ---&gt; 5a003e1dc65f</span><br><span class="line">Successfully built 5a003e1dc65f</span><br><span class="line">Successfully tagged alpine-a:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接着运行以这个镜像<code>alpine-a:latest</code>为基础镜像而运行的容器中的 <code>/root/</code> 目录下会有 <code>A</code> 项目目录下的所有文件:</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run --rm alpine-a:latest ls /root/</span><br><span class="line">Dockerfile</span><br><span class="line">a.txt</span><br><span class="line">a1.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>B</code> 项目的 <code>Dockerfile</code> 的内容：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">b1.txt  b2.txt  b.txt</span><br><span class="line">[root@docker B]<span class="comment"># cat Dockerfile</span></span><br><span class="line">FROM alpine-base:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样构建 B 项目的 镜像，运行容器后可以看到 <code>/root/</code> 目录下会有 B 项目目录下的所有文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t alpine-b .</span><br><span class="line">Sending build context to Docker daemon  3.584kB</span><br><span class="line">Step 1/1 : FROM alpine-base:latest</span><br><span class="line"><span class="comment"># Executing 1 build trigger</span></span><br><span class="line"> ---&gt; e66b6ee561a9</span><br><span class="line">Successfully built e66b6ee561a9</span><br><span class="line">Successfully tagged alpine-b:latest</span><br><span class="line">[root@docker B]<span class="comment"># docker run --rm alpine-b:latest ls /root/</span></span><br><span class="line">Dockerfile</span><br><span class="line">b.txt</span><br><span class="line">b1.txt</span><br><span class="line">b2.txt</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>ONBUILD</code> 指令后面内容会在，其他镜像以此镜像为基础镜像构建的时候执行。</p>
<h5 id="高级应用场景"><a href="#高级应用场景" class="headerlink" title="高级应用场景"></a>高级应用场景</h5><blockquote>
<p>python 项目都有自己的依赖包，通常会放在项目根目录下的一个文件，这个文件名叫：<code>requirements.txt</code></p>
</blockquote>
<p>此文件可以通过如下命令得到：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  pip3 freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内容一般为：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  head -3 requirement.txt</span><br><span class="line">Django==1.11</span><br><span class="line">PyMySQL==0.8.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以使用如下命令来安装这些项目的依赖模块。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirement.txt</span><br></pre></td></tr></table></figure>

<p>现在假设公司有多个 python3 的项目，每个项目都有自己不同的依赖模块。需要为每个项目制定一个 Dockerfile 或者镜像吗？</p>
<h6 id="操作示例-1"><a href="#操作示例-1" class="headerlink" title="操作示例"></a>操作示例</h6><blockquote>
<p>比如有两个项目： CMDB 和 SUPERMAN</p>
</blockquote>
<p>下面我们使用 <code>ONBUILD</code> 指令来构建一个基础 <code>python</code>镜像，</p>
<p>之后两个项目可以不必修改原来的 <code>Dockerfile</code> 就可以部署自己的环境依赖包了。</p>
<p><strong>CMDB 的 Dockerfile</strong></p>
<p><strong>CMDB</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree CMDB/</span><br><span class="line">CMDB/</span><br><span class="line">├── requirments.txt</span><br><span class="line">$ cat CMDB/requirmants.txt</span><br><span class="line">django==1.11</span><br><span class="line">$ cat CMDB/run.py</span><br><span class="line">import django</span><br><span class="line"><span class="built_in">print</span>(django.VERSION)</span><br></pre></td></tr></table></figure>

<p><strong>SUPERMAN</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ tree SUPERMAN/</span><br><span class="line">SUPERMAN/</span><br><span class="line">├── requirments.txt</span><br><span class="line">└── run.py</span><br><span class="line">$ cat SUPERMAN/requirmants.txt</span><br><span class="line">django==1.11</span><br><span class="line">$ cat SUPERMAN/run.py</span><br><span class="line">import django</span><br><span class="line"><span class="built_in">print</span>(django.VERSION)</span><br></pre></td></tr></table></figure>

<p><strong>使用 ONBUILD 指令构建 Python 基础镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line">FROM python</span><br><span class="line">ONBUILD COPY . /opt/</span><br><span class="line">ONBUILD RUN pip3 install -r /opt/requirments.txt</span><br><span class="line">ONBUILD CMD [<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;/opt/run.py&quot;</span>]</span><br><span class="line">[root@docker onbulid]<span class="comment"># docker build -t python3-base .</span></span><br></pre></td></tr></table></figure>

<p>之后分别在各自的项目目录下创建自己的 <code>Dockerfile</code></p>
<p><strong>CMDB 的 Dockerfile</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM python3-base</span><br></pre></td></tr></table></figure>

<p><strong>SUPERMAN 的 Dockerfile</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM python3-base</span><br></pre></td></tr></table></figure>

<p>这样就可以很简单的实现不同的项目只需要创建一个同样内容的镜像，而会得到自己的环境了。</p>
<blockquote>
<p>另外下面的是在 shell 中的执行 python 的命令：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM python</span><br><span class="line">ONBUILD COPY ./requirement.txt /</span><br><span class="line">ONBUILD RUN pip install -r /requirement.txt</span><br><span class="line">ONBUILD CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;-c&quot;</span> <span class="string">&quot;import django;print(django.VERSION)&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把这个构建成所有项目的基础镜像，名字为： python-onbuild:v1.0</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker build -t python-onbuild:v1.0 .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他 <code>python</code> 项目再使用此镜像为基础镜像时，<code>Dockerfile</code> 中只需一行即可：</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM python-onbuild:v1.0</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lvxueyangtiger.github.io/post/f61655ea.html">https://lvxueyangtiger.github.io/post/f61655ea.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lvxueyangtiger.github.io" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212055.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/594d6108.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082319.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker 安装</div></div></a></div><div class="next-post pull-right"><a href="/post/d9f07b99.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082110.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker-Swarm</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/fb6100d6.html" title="Docker-Compose"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212110.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Docker-Compose</div></div></a></div><div><a href="/post/33d07388.html" title="Docker-MySQL"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211108212050.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Docker-MySQL</div></div></a></div><div><a href="/post/f5f9fa9b.html" title="Docker"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082137.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Docker</div></div></a></div><div><a href="/post/11b45f95.html" title="Docker仓库"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082249.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Docker仓库</div></div></a></div><div><a href="/post/594d6108.html" title="Docker 安装"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082319.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Docker 安装</div></div></a></div><div><a href="/post/d9f07b99.html" title="Docker-Swarm"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/20211004082110.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-30</div><div class="title">Docker-Swarm</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80"><span class="toc-number">2.</span> <span class="toc-text">小试牛刀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%BE%91-Dockerfile-%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">编辑 Dockerfile 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">指令介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">2.2.</span> <span class="toc-text">构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">命令语法格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">构建镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87-context"><span class="toc-number">2.2.3.</span> <span class="toc-text">上下文(context)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E6%88%98"><span class="toc-number">2.3.</span> <span class="toc-text">最佳实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">Dockerfile 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FROM-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">FROM 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-Hello-world"><span class="toc-number">3.1.1.</span> <span class="toc-text">制作 Hello world</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-gcc"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">安装 gcc</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%BE%91-C-%E6%BA%90%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">编辑 C 源代码文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">编译源码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%BE%91-Dockerfile"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">编辑 Dockerfile</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%96%B0%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">构建新的镜像</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">查看本地仓库验证</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B0%E7%9A%84%E9%95%9C%E5%83%8F%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">利用新的镜像运行一个容器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Alpine"><span class="toc-number">3.1.2.</span> <span class="toc-text">关于 Alpine</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">简单</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">安全</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LABEL-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">LABEL 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENV-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">ENV 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">其他指令使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">RUN 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.2.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">错误示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">正确做法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMD-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.</span> <span class="toc-text">CMD 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">3.5.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">3.5.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENTRYPOINT-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.6.</span> <span class="toc-text">ENTRYPOINT 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT%E5%92%8CCMD%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.1.</span> <span class="toc-text">ENTRYPOINT和CMD区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">3.6.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">场景一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">场景二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WORKDIR-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.7.</span> <span class="toc-text">WORKDIR 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">3.7.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">3.7.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">错误示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">正确示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COPY-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.8.</span> <span class="toc-text">COPY 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.8.1.</span> <span class="toc-text">语法格式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">参数解释</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">3.8.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADD-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.9.</span> <span class="toc-text">ADD 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USER-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.10.</span> <span class="toc-text">USER 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEALTHCHECK-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="toc-number">3.11.</span> <span class="toc-text">HEALTHCHECK 健康检查指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">3.11.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.11.2.</span> <span class="toc-text">运行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">3.11.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ONBILUD-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.12.</span> <span class="toc-text">ONBILUD 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-5"><span class="toc-number">3.12.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.12.2.</span> <span class="toc-text">基础应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E9%A1%B9%E7%9B%AE%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.12.2.1.</span> <span class="toc-text">A 项目下的文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E9%A1%B9%E7%9B%AE%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.12.2.2.</span> <span class="toc-text">B 项目下的文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.12.2.3.</span> <span class="toc-text">操作示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.12.3.</span> <span class="toc-text">高级应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.12.3.1.</span> <span class="toc-text">操作示例</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="framework-info"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/202301132049386.png"/><span> </span><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">晋ICP备2022012091号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>