<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NIO | 小肥龙吃大冰淇淋</title><meta name="keywords" content="Netty"><meta name="author" content="小肥龙吃大冰淇淋"><meta name="copyright" content="小肥龙吃大冰淇淋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NIO简单介绍前言Java NIO有两种解释：  一种叫非阻塞IO（Non-blocking I&#x2F;O） 另一种叫新的IO（New I&#x2F;O）  其实两种概念也是相同的。 一、概述Java NIO是从Java1.4版本开始引入的一个新的IO API,可以代替标准的IO API。 NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的，基于通道的IO操作。NIO将以更加高效">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO">
<meta property="og:url" content="http://lvxueyang.vip/post/429dd195.html">
<meta property="og:site_name" content="小肥龙吃大冰淇淋">
<meta property="og:description" content="NIO简单介绍前言Java NIO有两种解释：  一种叫非阻塞IO（Non-blocking I&#x2F;O） 另一种叫新的IO（New I&#x2F;O）  其实两种概念也是相同的。 一、概述Java NIO是从Java1.4版本开始引入的一个新的IO API,可以代替标准的IO API。 NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的，基于通道的IO操作。NIO将以更加高效">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg">
<meta property="article:published_time" content="2024-05-30T01:10:36.409Z">
<meta property="article:modified_time" content="2023-10-12T04:17:42.181Z">
<meta property="article:author" content="小肥龙吃大冰淇淋">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg"><link rel="shortcut icon" href="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210805191028.png"><link rel="canonical" href="http://lvxueyang.vip/post/429dd195"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NIO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 12:17:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/ali_icon.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mogai.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小肥龙吃大冰淇淋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">303</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">73</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小肥龙吃大冰淇淋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouyex"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-zuixinwenzhang_huaban"></i><span> 找文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei1"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian1"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/timeline/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-gerenzhongxin"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NIO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-30T01:10:36.409Z" title="发表于 2024-05-30 09:10:36">2024-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T04:17:42.181Z" title="更新于 2023-10-12 12:17:42">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Netty/">Netty</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>110分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NIO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="NIO简单介绍"><a href="#NIO简单介绍" class="headerlink" title="NIO简单介绍"></a>NIO简单介绍</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>Java NIO有两种解释：</strong></p>
<ul>
<li>一种叫非阻塞IO（Non-blocking I/O）</li>
<li>另一种叫新的IO（New I/O）</li>
</ul>
<p>其实两种概念也是相同的。</p>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Java NIO是从Java1.4版本开始引入的一个新的IO API,可以代替标准的IO API。</p>
<p>NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，<strong>NIO支持面向缓冲区的，基于通道的IO操作</strong>。NIO将以更加高效的方式进行文件的读写操作。</p>
<p><strong>NIO有三大核心部分</strong></p>
<ul>
<li><strong>Channel（通道）</strong></li>
<li><strong>Buffer（缓冲区）</strong></li>
<li><strong>Selector（选择器）</strong></li>
</ul>
<h3 id="二、Java-NIO与BIO的区别"><a href="#二、Java-NIO与BIO的区别" class="headerlink" title="二、Java NIO与BIO的区别"></a>二、Java NIO与BIO的区别</h3><ul>
<li>BIO以流的方式处理数据，而NIO以块的方式处理数据，块IO的效率比流IO高很多；</li>
<li>BIO是阻塞的，NIO则是非阻塞的；</li>
<li>BIO基于字节流和字符流进行操作，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道；</li>
<li>BIO是单向的，如：InputStream, OutputStream；而<strong>NIO是双向的</strong>，既可以用来进行读操作，又可以用来进行写操作。</li>
</ul>
<h3 id="三、NIO三大核心原理"><a href="#三、NIO三大核心原理" class="headerlink" title="三、NIO三大核心原理"></a>三、NIO三大核心原理</h3><h4 id="3-1-Buffer-缓冲区"><a href="#3-1-Buffer-缓冲区" class="headerlink" title="3.1 Buffer(缓冲区)"></a>3.1 Buffer(缓冲区)</h4><p> 缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存，这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存，相比较直接对数组的操作，Buffer API更加容易操作和管理。</p>
<h4 id="3-2-Channel（通道）"><a href="#3-2-Channel（通道）" class="headerlink" title="3.2 Channel（通道）"></a>3.2 Channel（通道）</h4><p> Java NIO的通道类似流，但又有些不同： 既可以从通道中读取数据，又可以写数据到通道。但流的（input或output）读写通常是单向的。通道可以非阻塞读取和写入通道，也可以支持读取或写入缓冲区，同时支持异步地读写。</p>
<p><strong>常见的 Channel 有</strong></p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<h4 id="3-3-Selector（选择器）"><a href="#3-3-Selector（选择器）" class="headerlink" title="3.3 Selector（选择器）"></a>3.3 Selector（选择器）</h4><p> Selector是一个Java NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。一个单独的线程可以管理多个channel，从而管理多个网络连接。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/279987001.png" alt="01.NIO简单介绍01.png"></p>
<ul>
<li>每个Channel都会对应一个Buffer</li>
<li>一个线程对应Selector，一个Selector对应多个Channel（连接）</li>
<li>程序切换到那个Channel是由事件决定的</li>
<li>Selector会根据不同的事件，在各个通道上切换</li>
<li>Buffer就是一个内存块，底层是一个数组</li>
<li>数据的读取写入是通过Buffer完成的，BIO中要么是输入流，或者是输出流，不能双向，但是NIO的Buffer时可以读也可以写</li>
<li>Channel负责传输，Buffer负责存取数据</li>
</ul>
<h3 id="四、缓冲区Buffer"><a href="#四、缓冲区Buffer" class="headerlink" title="四、缓冲区Buffer"></a>四、缓冲区Buffer</h3><p>一个用于特定基本数据类型的容器。由 Java NIO包定义的，所有缓冲区都是Buffer抽象类的子类。Java NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/665867991.png" alt="01.NIO简单介绍02.png"></p>
<h4 id="Buffer类及其子类"><a href="#Buffer类及其子类" class="headerlink" title="Buffer类及其子类"></a>Buffer类及其子类</h4><p>Buffer就像一个数组，可以保存多个相同类型的数据。根据数据类型不同，有以下Buffer常用子类：</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<p>上述Buffer类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个Buffer对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>创建一个容量为capacity的xxxBuffer对象</span><br><span class="line"><span class="keyword">static</span> xxxBuffer <span class="keyword">allocate</span>(<span class="type">int</span> capacity);</span><br><span class="line">    <span class="operator">|</span></span><br><span class="line">    <span class="operator">|</span></span><br><span class="line">    <span class="operator">|</span></span><br><span class="line">IntBuffer buffer <span class="operator">=</span> IntBuffer.allocate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Buffer中的重要概念"><a href="#Buffer中的重要概念" class="headerlink" title="Buffer中的重要概念"></a>Buffer中的重要概念</h4><ul>
<li><p>**容量(capacity):**创建后不能更改,且容量不能为负;</p>
</li>
<li><p>**限制(limit):**表示缓冲区中可以操作数据的大小。缓冲区的限制不能为负,并且不能大于其容量；</p>
<p>  写入模式,限制等于buffer的容量。读取模式下,limit等于写入的数据量</p>
</li>
<li><p>**位置(position):**下一个要读取或写入的数据的索引。缓冲区的位置不能为负,并且不能大于其限制；</p>
</li>
<li><p>**标记(mark)与重置(reset):**标记是一个索引,通过Buffer中的mark()方法指定Buffer中一个特定的position,之后可以通过调用reset()方法恢复到这个position。</p>
</li>
</ul>
<h2 id="NIO之bytebuffer基本使用"><a href="#NIO之bytebuffer基本使用" class="headerlink" title="NIO之bytebuffer基本使用"></a>NIO之bytebuffer基本使用</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>本篇将通过nio读取一个文本文件来演示bytebuffer的基本使用</p>
<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ul>
<li><strong>数据准备</strong></li>
</ul>
<p>创建data.txt文件，增加如下内容：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890</span>abcd</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建Maven项目</strong></li>
<li><strong>安装lombok插件</strong></li>
</ul>
<h3 id="二、ByteBuffer-使用分析"><a href="#二、ByteBuffer-使用分析" class="headerlink" title="二、ByteBuffer 使用分析"></a>二、ByteBuffer 使用分析</h3><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><ul>
<li><strong>引入pom依赖</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/24</span></span><br><span class="line"><span class="comment"> * Description ByteBuffer Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * FileChannel</span></span><br><span class="line"><span class="comment">         * 方式1：输入输出流</span></span><br><span class="line"><span class="comment">         * 方式2：RandomAccessFile</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;datas/data.txt&quot;</span>).getChannel())&#123;</span><br><span class="line">            <span class="comment">//准备缓冲区</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//1.从 channel 读取数据，向buffer写入</span></span><br><span class="line">                <span class="keyword">int</span> len = channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">&quot;读取到的字节数:&#123;&#125;&quot;</span>,len);</span><br><span class="line">                <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;  <span class="comment">//判断内容是否读取完</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//打印buffer中的内容</span></span><br><span class="line">                buffer.flip(); <span class="comment">//2.切换至读模式</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining())&#123;  <span class="comment">//是否还有剩余未读数据</span></span><br><span class="line">                    <span class="keyword">byte</span> b = buffer.get();    <span class="comment">//3.读取数据内容</span></span><br><span class="line">                    log.debug(<span class="string">&quot;实际字节:&#123;&#125;&quot;</span>,(<span class="keyword">char</span>) b);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.clear(); <span class="comment">//4.切换到写模式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 读取到的字节数:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">3</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">4</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">5</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">6</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">7</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">8</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">9</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:<span class="number">0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 读取到的字节数:<span class="number">4</span></span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:a</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:b</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:c</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 实际字节:d</span><br><span class="line"><span class="number">10</span>:<span class="number">16</span>:<span class="number">41</span> [DEBUG] [main] c.l.n.b.TestByteBuffer - 读取到的字节数:-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>整体目录结构</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/879582621.jpg" alt="02.NIO之bytebuffer基本使用01.jpg"></p>
<h2 id="NIO之bytebuffer内部结构和方法"><a href="#NIO之bytebuffer内部结构和方法" class="headerlink" title="NIO之bytebuffer内部结构和方法"></a>NIO之bytebuffer内部结构和方法</h2><h3 id="一、bytebuffer内部结构"><a href="#一、bytebuffer内部结构" class="headerlink" title="一、bytebuffer内部结构"></a>一、bytebuffer内部结构</h3><h4 id="1-1-属性介绍"><a href="#1-1-属性介绍" class="headerlink" title="1.1 属性介绍"></a>1.1 属性介绍</h4><p><strong>Bytebuffer有以下重要属性：</strong></p>
<ul>
<li><strong>capacity（容量）</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改。</li>
<li><strong>position（指针）</strong>：读写指针，记录数据读写的位置，缓冲区的位置不能为负，并且<strong>不能大于limit</strong>。</li>
<li><strong>limit（读写限制）</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong>。</li>
</ul>
<h4 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h4><ul>
<li><strong>写模式</strong></li>
</ul>
<p>当缓冲区刚创建成功时</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3935100654.png" alt="03.NIO之bytebuffer内部结构和方法01.png"></p>
<p>写模式下，position 是写入位置，limit 等于容量。</p>
<p>下图表示写入了 4 个字节后的状态：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2417444730.png" alt="03.NIO之bytebuffer内部结构和方法02.png"></p>
<p>Position移动到第5个字节开始位置</p>
<ul>
<li><strong>读模式</strong></li>
</ul>
<p>flip动作发生后，position切换为读取位置，limit切换为读取限制</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1728412666.png" alt="03.NIO之bytebuffer内部结构和方法03.png"></p>
<ul>
<li>position重新赋值到开始位置，因为读取数据从开始位置开始读取</li>
<li>limit被赋值为position写入时的最后位置，作为数据读取的最终位置</li>
</ul>
<p>读取4个字节后，状态如下图：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/4205227856.png" alt="03.NIO之bytebuffer内部结构和方法04.png"></p>
<ul>
<li>当position位置与limit位置相同时，数据读取结束。</li>
<li><strong>数据未读取完重新切换到写模式时</strong></li>
</ul>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2245375026.png" alt="03.NIO之bytebuffer内部结构和方法05.png"></p>
<h3 id="二、ByteBuffer常见方法"><a href="#二、ByteBuffer常见方法" class="headerlink" title="二、ByteBuffer常见方法"></a>二、ByteBuffer常见方法</h3><ul>
<li><h5 id="put"><a href="#put" class="headerlink" title="put()"></a><strong>put()</strong></h5></li>
</ul>
<p><strong>描述：</strong>可以将一个数据放入到缓冲区中。</p>
<p>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/293181828.png" alt="03.NIO之bytebuffer内部结构和方法06.png"></p>
<ul>
<li><h5 id="flip"><a href="#flip" class="headerlink" title="flip()"></a><strong>flip()</strong></h5></li>
</ul>
<p><strong>描述</strong>：用来<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</p>
<p>进行该操作后：</p>
<ul>
<li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，capacity不变；</li>
<li>如果是读模式-&gt;写模式，则恢复为put()方法中的值。</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/4207702593.png" alt="03.NIO之bytebuffer内部结构和方法07.png"></p>
<ul>
<li><h5 id="get"><a href="#get" class="headerlink" title="get()"></a><strong>get()</strong></h5></li>
</ul>
<p><strong>描述</strong>：该方法会读取缓冲区中的一个值</p>
<p>进行该操作后，position会+1，如果超过了limit则会抛出异常</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3533719035.png" alt="03.NIO之bytebuffer内部结构和方法08.png"></p>
<p><em>注意：get(i)方法不会改变position的值</em></p>
<ul>
<li><h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a><strong>rewind()</strong></h5></li>
</ul>
<p><strong>描述</strong>：该方法<strong>只能在读模式下使用</strong></p>
<p>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1369941017.png" alt="03.NIO之bytebuffer内部结构和方法09.png"></p>
<ul>
<li><h5 id="clean"><a href="#clean" class="headerlink" title="clean()"></a>clean()</h5></li>
</ul>
<p>描述：会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</p>
<p><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2141478096.png" alt="03.NIO之bytebuffer内部结构和方法10.png"></p>
<ul>
<li><h5 id="mark-reset"><a href="#mark-reset" class="headerlink" title="mark()/reset()"></a><strong>mark()/reset()</strong></h5></li>
</ul>
<p><strong>描述</strong>：mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<p>**mark()**：将postion的值保存到mark属性中</p>
<p>**reset()**：将position的值改为mark中保存的值</p>
<p><em>注意：rewind 和 flip 都会清除 mark 位置</em></p>
<ul>
<li><h5 id="compact"><a href="#compact" class="headerlink" title="compact()"></a>compact()</h5></li>
</ul>
<p><strong>描述</strong>：compact会把未读完的数据向前压缩，然后切换到写模式</p>
<p>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1868787814.png" alt="03.NIO之bytebuffer内部结构和方法11.png"></p>
<p><em>注意：此方法为ByteBuffer的方法，而不是Buffer的方法</em></p>
<p><strong>clear()和compact()方法对比：</strong></p>
<p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>
<p><strong>需要根据情况来判断使用哪种方法进行模式切换</strong></p>
<h2 id="NIO之bytebuffer常见方法演示"><a href="#NIO之bytebuffer常见方法演示" class="headerlink" title="NIO之bytebuffer常见方法演示"></a>NIO之bytebuffer常见方法演示</h2><h3 id="1-分配内存空间"><a href="#1-分配内存空间" class="headerlink" title="1. 分配内存空间"></a>1. 分配内存空间</h3><p>可以使用allocate() 和 allocateDirect()方法为ByteBuffer分配空间，其他buffer类也有该方法</p>
<ul>
<li><strong>allocate()</strong>: 使用的是java的堆内存，堆内字节缓冲区，读写效率低，会受到GC的影响</li>
<li><strong>allocateDirect()</strong>:使用的是直接内存，直接内存字节缓冲区，读写效率高（零拷贝），不会受GC影响,因为是系统直接内存，所以分配内存要调用操作系统函数，所以分配内存的速度较慢，如果使用不当（资源没得到合理释放），会造成内存泄漏。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description 分配空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferAllocateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass());</span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">class java.nio.HeapByteBuffer</span><br><span class="line">class java.nio.DirectByteBuffer</span><br></pre></td></tr></table></figure>

<h3 id="2-向buffer写入数据"><a href="#2-向buffer写入数据" class="headerlink" title="2. 向buffer写入数据"></a>2. 向buffer写入数据</h3><p>有两种办法</p>
<ul>
<li><p>调用 channel 的 read 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readBytes = channel.read(buf);</span><br></pre></td></tr></table></figure></li>
<li><p>调用 buffer 自己的 put 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf.put((<span class="keyword">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-从buffer读取数据"><a href="#3-从buffer读取数据" class="headerlink" title="3. 从buffer读取数据"></a>3. 从buffer读取数据</h3><p>同样有两种办法</p>
<ul>
<li><p>调用 channel 的 write 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> writeBytes = channel.write(buf);</span><br></pre></td></tr></table></figure></li>
<li><p>调用 buffer 自己的 get 方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = buf.get();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 rewind 方法将 position 重新置为 0</li>
<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>
</ul>
<p><strong>读写示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description bytebuffer读写示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferReadWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>) <span class="number">0x61</span>);    <span class="comment">//a</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>&#125;); <span class="comment">//b、c、d</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        <span class="comment">//flip:切换对缓冲区的操作模式 写模式 --&gt; 读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        <span class="comment">//get(i):不会改变索引的位置</span></span><br><span class="line">        System.out.println(buffer.get(<span class="number">2</span>));</span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        <span class="comment">//compact:会把未读完的数据向前压缩，然后切换到写模式</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x65</span>,<span class="number">0x6f</span>&#125;);</span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        <span class="comment">// rewind 从头开始读</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">        buffer.rewind();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[1]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[10]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">61</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span>                   |<span class="selector-tag">a</span>.........      |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[4]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[10]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">61</span> <span class="selector-tag">62</span> <span class="selector-tag">63</span> <span class="selector-tag">64</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span>                   |<span class="selector-tag">abcd</span>......      |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">97</span></span><br><span class="line"><span class="selector-tag">99</span></span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[1]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[4]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">61</span> <span class="selector-tag">62</span> <span class="selector-tag">63</span> <span class="selector-tag">64</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span>                   |<span class="selector-tag">abcd</span>......      |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[3]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[10]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">62</span> <span class="selector-tag">63</span> <span class="selector-tag">64</span> <span class="selector-tag">64</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span>                   |<span class="selector-tag">bcdd</span>......      |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[5]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[10]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">62</span> <span class="selector-tag">63</span> <span class="selector-tag">64</span> <span class="selector-tag">65</span> <span class="selector-tag">6f</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span>                   |<span class="selector-tag">bcdeo</span>.....      |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line"><span class="selector-tag">c</span></span><br><span class="line"><span class="selector-tag">b</span></span><br></pre></td></tr></table></figure>

<h3 id="4-mark-和-reset"><a href="#4-mark-和-reset" class="headerlink" title="4. mark 和 reset"></a>4. mark 和 reset</h3><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description mark 和 reset方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferMarkAndReset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        byteBuffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 a</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 b</span></span><br><span class="line">        byteBuffer.mark(); <span class="comment">// 加标记  索引为2 的位置</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 c</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 d</span></span><br><span class="line">        byteBuffer.reset(); <span class="comment">// 将position 重置到索引为2的位置</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 c</span></span><br><span class="line">        System.out.println((<span class="keyword">char</span>) byteBuffer.get()); <span class="comment">// 读取 d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<h3 id="5-字符串与-ByteBuffer-互转"><a href="#5-字符串与-ByteBuffer-互转" class="headerlink" title="5. 字符串与 ByteBuffer 互转"></a>5. 字符串与 ByteBuffer 互转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">ByteBuffer buffer2 = Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"></span><br><span class="line">CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">         +<span class="comment">-------------------------------------------------+</span></span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|<span class="number">00000000</span>| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line">         +<span class="comment">-------------------------------------------------+</span></span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|<span class="number">00000000</span>| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line">class java.nio.HeapCharBuffer</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description 字符串与 ByteBuffer 互转 Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、字符串转为 ByteBuffer，还是写模式</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、Charset 字符集类，自动切换到读模式</span></span><br><span class="line">        ByteBuffer helloBuffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        debugAll(helloBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、wrap，自动切换到读模式</span></span><br><span class="line">        ByteBuffer buffer3 = ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer3);</span><br><span class="line">        <span class="comment">// 4、转换为字符串</span></span><br><span class="line">        CharBuffer charBuffer = StandardCharsets.UTF_8.decode(helloBuffer);</span><br><span class="line">        System.out.println(charBuffer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不起作用</span></span><br><span class="line">        buffer.flip(); <span class="comment">// 切换读模式，起作用</span></span><br><span class="line">        CharBuffer charBuffer1 = StandardCharsets.UTF_8.decode(buffer);</span><br><span class="line">        System.out.println(charBuffer1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[5]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[16]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">68</span> <span class="selector-tag">65</span> <span class="selector-tag">6c</span> <span class="selector-tag">6c</span> <span class="selector-tag">6f</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> <span class="selector-tag">00</span> |<span class="selector-tag">hello</span>...........|</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[5]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">68</span> <span class="selector-tag">65</span> <span class="selector-tag">6c</span> <span class="selector-tag">6c</span> <span class="selector-tag">6f</span>                                  |<span class="selector-tag">hello</span>           |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[5]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">68</span> <span class="selector-tag">65</span> <span class="selector-tag">6c</span> <span class="selector-tag">6c</span> <span class="selector-tag">6f</span>                                  |<span class="selector-tag">hello</span>           |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">hello</span></span><br><span class="line"><span class="selector-tag">hello</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Scattering-Reads（分散读）"><a href="#6-Scattering-Reads（分散读）" class="headerlink" title="6. Scattering Reads（分散读）"></a>6. Scattering Reads（分散读）</h3><p>分散读取集中写的方法不重要，重要的是思想，可以减少在ByteBuffer之间的拷贝，减少数据的复制次数，提高效率。</p>
<p><strong>示例</strong></p>
<ul>
<li>创建一个文本文件words.txt</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>

<ul>
<li>分散读取示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description 分散读 Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringReadsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(FileChannel channel = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;datas/words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel()) &#123;</span><br><span class="line">            ByteBuffer b1 = ByteBuffer.allocate(<span class="number">3</span>); <span class="comment">//  one</span></span><br><span class="line">            ByteBuffer b2 = ByteBuffer.allocate(<span class="number">3</span>); <span class="comment">//  two</span></span><br><span class="line">            ByteBuffer b3 = ByteBuffer.allocate(<span class="number">5</span>); <span class="comment">//  three</span></span><br><span class="line">            channel.read(<span class="keyword">new</span> ByteBuffer[]&#123;b1, b2, b3&#125;);</span><br><span class="line">            b1.flip();</span><br><span class="line">            b2.flip();</span><br><span class="line">            b3.flip();</span><br><span class="line">            debugAll(b1);</span><br><span class="line">            debugAll(b2);</span><br><span class="line">            debugAll(b3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[3]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">6f</span> <span class="selector-tag">6e</span> <span class="selector-tag">65</span>                                        |<span class="selector-tag">one</span>             |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[3]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">74</span> <span class="selector-tag">77</span> <span class="selector-tag">6f</span>                                        |<span class="selector-tag">two</span>             |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[5]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">74</span> <span class="selector-tag">68</span> <span class="selector-tag">72</span> <span class="selector-tag">65</span> <span class="selector-tag">65</span>                                  |<span class="selector-tag">three</span>           |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br></pre></td></tr></table></figure>

<h3 id="7-Gathering-Writes（集中写）"><a href="#7-Gathering-Writes（集中写）" class="headerlink" title="7. Gathering Writes（集中写）"></a>7. Gathering Writes（集中写）</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/25</span></span><br><span class="line"><span class="comment"> * Description 集中写Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatheringWritesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;datas/words.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            ByteBuffer d = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            ByteBuffer e = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">            channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            d.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;);</span><br><span class="line">            e.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">            d.flip();</span><br><span class="line">            e.flip();</span><br><span class="line">            debugAll(d);</span><br><span class="line">            debugAll(e);</span><br><span class="line">            channel.write(<span class="keyword">new</span> ByteBuffer[]&#123;d, e&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[4]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">66</span> <span class="selector-tag">6f</span> <span class="selector-tag">75</span> <span class="selector-tag">72</span>                                     |<span class="selector-tag">four</span>            |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">--------------------</span> <span class="keyword">all</span> <span class="selector-tag">------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-attr">[0]</span>, <span class="selector-tag">limit</span>: <span class="selector-attr">[4]</span></span><br><span class="line">         +<span class="selector-tag">-------------------------------------------------</span>+</span><br><span class="line">         |  <span class="selector-tag">0</span>  <span class="selector-tag">1</span>  <span class="selector-tag">2</span>  <span class="selector-tag">3</span>  <span class="selector-tag">4</span>  <span class="selector-tag">5</span>  <span class="selector-tag">6</span>  <span class="selector-tag">7</span>  <span class="selector-tag">8</span>  <span class="selector-tag">9</span>  <span class="selector-tag">a</span>  <span class="selector-tag">b</span>  <span class="selector-tag">c</span>  <span class="selector-tag">d</span>  <span class="selector-tag">e</span>  <span class="selector-tag">f</span> |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br><span class="line">|<span class="selector-tag">00000000</span>| <span class="selector-tag">66</span> <span class="selector-tag">69</span> <span class="selector-tag">76</span> <span class="selector-tag">65</span>                                     |<span class="selector-tag">five</span>            |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">-------------------------------------------------</span>+<span class="selector-tag">----------------</span>+</span><br></pre></td></tr></table></figure>

<h3 id="最后：调试工具类"><a href="#最后：调试工具类" class="headerlink" title="最后：调试工具类"></a>最后：调试工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.internal.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.util.internal.MathUtil.isOutOfBounds;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.util.internal.StringUtil.NEWLINE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/5/25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:调试工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> String[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> String[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="keyword">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugAll</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugRead</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startIndex = offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> remainder = length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="keyword">int</span> row, <span class="keyword">int</span> rowStartIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO之bytebuffer黏包和半包"><a href="#NIO之bytebuffer黏包和半包" class="headerlink" title="NIO之bytebuffer黏包和半包"></a>NIO之bytebuffer黏包和半包</h2><h3 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h3><blockquote>
<p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
</blockquote>
<ul>
<li>Hello,world\n</li>
<li>I’m zhangsan\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (黏包，半包)</p>
<ul>
<li>Hello,world\nI’m zhangsan\nHo</li>
<li>w are you?\n</li>
</ul>
<p><strong>分析</strong></p>
<p>本来分别将上方三条数据发送给服务端，但是发送到服务的却是两条</p>
<ul>
<li>第一条数据中的第二行和第三行中的Ho当作一条数据发送给了服务端，产生了<strong>黏包</strong>。</li>
<li>第二条数据，因为服务端并未接收到完整的第三条数据，所以产生了<strong>半包</strong>。</li>
</ul>
<h3 id="二、黏包和半包出现原因"><a href="#二、黏包和半包出现原因" class="headerlink" title="二、黏包和半包出现原因"></a>二、黏包和半包出现原因</h3><ul>
<li><strong>黏包</strong></li>
</ul>
<blockquote>
<p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p>
</blockquote>
<ul>
<li><strong>半包</strong></li>
</ul>
<blockquote>
<p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p>
</blockquote>
<h3 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h3><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。注意：get(index)不会改变position的值<ul>
<li>记录该段数据长度，以便于申请对应大小的缓冲区</li>
<li>将缓冲区的数据通过get()方法写入到target中</li>
</ul>
</li>
<li>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/26</span></span><br><span class="line"><span class="comment"> * Description 黏包和半包 Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufferExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">// 模拟黏包</span></span><br><span class="line">        buffer.put(<span class="string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">        split(buffer);</span><br><span class="line">        <span class="comment">//模拟半包</span></span><br><span class="line">        buffer.put(<span class="string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());</span><br><span class="line">        split(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer buffer)</span></span>&#123;</span><br><span class="line">        <span class="comment">//切换到读模式  才能从buffer中读取数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">int</span> oldLimit = buffer.limit();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;oldLimit;i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历寻找分隔符</span></span><br><span class="line">            <span class="comment">// get(i)不会移动position</span></span><br><span class="line">            <span class="keyword">if</span>(buffer.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="comment">// 缓冲区长度</span></span><br><span class="line">                <span class="keyword">int</span> length = i+<span class="number">1</span>-buffer.position();</span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="comment">// 0 ~ limit</span></span><br><span class="line">                buffer.limit(i + <span class="number">1</span>);</span><br><span class="line">                target.put(buffer); <span class="comment">//从buffer 读，向 target 写</span></span><br><span class="line">                debugAll(target);</span><br><span class="line">                buffer.limit(oldLimit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切换到写模式，但是缓冲区可能未读完，这里需要使用compact</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line"><span class="addition">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [12], limit: [12]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">24</span><br><span class="line"><span class="addition">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [13], limit: [13]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|00000000| 49 27 6d 20 7a 68 61 6e 67 73 61 6e 0a          |I&#x27;m zhangsan.   |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">12</span><br><span class="line"><span class="addition">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [13], limit: [13]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">18</span><br><span class="line"><span class="addition">+--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [6], limit: [6]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|00000000| 68 61 68 61 21 0a                               |haha!.          |</span><br><span class="line"><span class="addition">+--------+-------------------------------------------------+----------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="NIO之FileChannel介绍"><a href="#NIO之FileChannel介绍" class="headerlink" title="NIO之FileChannel介绍"></a>NIO之FileChannel介绍</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>FileChannel是一个连接到文件的<strong>通道</strong>，使用FileChannel可以从文件读数据，也可以向文件中写入数据。Java NIO的FileChannel是标准 Java IO 读写文件的替代方案。</p>
<p>FileChannel的主要作用是读取、写入、映射、操作文件。</p>
<p><strong>FileChannel 只能工作在阻塞模式下。</strong></p>
<h4 id="FileChannel-和-标准Java-IO对比"><a href="#FileChannel-和-标准Java-IO对比" class="headerlink" title="FileChannel 和 标准Java IO对比"></a>FileChannel 和 标准Java IO对比</h4><table>
<thead>
<tr>
<th>FileInputStream/FileOutputStream</th>
<th align="center">FileChannel</th>
</tr>
</thead>
<tbody><tr>
<td>单向</td>
<td align="center">双向</td>
</tr>
<tr>
<td>面向字节的读写</td>
<td align="center">面向Buffer读写</td>
</tr>
<tr>
<td>不支持</td>
<td align="center">支持内存文件映射</td>
</tr>
<tr>
<td>不支持</td>
<td align="center">支持转入或转出其他通道</td>
</tr>
<tr>
<td>不支持</td>
<td align="center">支持文件锁</td>
</tr>
<tr>
<td>不支持操作文件元信息</td>
<td align="center">不支持操作文件元信息</td>
</tr>
</tbody></table>
<h4 id="FileChannel的优点"><a href="#FileChannel的优点" class="headerlink" title="FileChannel的优点"></a>FileChannel的优点</h4><ul>
<li>在文件中的特定位置读取和写入</li>
<li>将文件的一部分直接加载到内存中，这样可以更高效</li>
<li>可以以更快的速度将文件数据从一个通道传输到另一个通道</li>
<li>可以锁定文件的一部分以限制其他线程的访问</li>
<li>为避免数据丢失，可以强制将文件更新立即写入存储</li>
</ul>
<h3 id="二、FileChannel-类结构"><a href="#二、FileChannel-类结构" class="headerlink" title="二、FileChannel 类结构"></a>二、FileChannel 类结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line">publicabstractclass FileChannel</span><br><span class="line">    extends AbstractInterruptibleChannel</span><br><span class="line">    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化一个无参构造器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FileChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开或创建一个文件，返回一个文件通道来访问文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileChannel <span class="title">open</span><span class="params">(Path path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Set&lt;? extends OpenOption&gt; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   FileAttribute&lt;?&gt;... attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileSystemProvider provider = path.getFileSystem().provider();</span><br><span class="line">        <span class="keyword">return</span> provider.newFileChannel(path, options, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    privatestaticfinal FileAttribute&lt;?&gt;[] NO_ATTRIBUTES = <span class="keyword">new</span> FileAttribute[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开或创建一个文件，返回一个文件通道来访问文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileChannel <span class="title">open</span><span class="params">(Path path, OpenOption... options)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Set&lt;OpenOption&gt; set = <span class="keyword">new</span> HashSet&lt;OpenOption&gt;(options.length);</span><br><span class="line">        Collections.addAll(set, options);</span><br><span class="line">        <span class="keyword">return</span> open(path, set, NO_ATTRIBUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从这个通道读入一个字节序列到给定的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从这个通道读入指定开始位置和长度的字节序列到给定的缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从这个通道读入一个字节序列到给定的缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从给定的缓冲区写入字节序列到这个通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从给定缓冲区的子序列向该信道写入字节序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从给定的缓冲区写入字节序列到这个通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通道读写缓冲区中的开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置通道读写缓冲区中的开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileChannel <span class="title">position</span><span class="params">(<span class="keyword">long</span> newPosition)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此通道文件的当前大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过指定的参数size来截取通道的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制将通道中的更新文件写入到存储设备（磁盘等）中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前通道中的文件写入到可写字节通道中</span></span><br><span class="line"><span class="comment">   * position就是开始写的位置，long就是写的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,WritableByteChannel target)</span><span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前通道中的文件写入可读字节通道中</span></span><br><span class="line"><span class="comment">   * position就是开始写的位置，long就是写的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src,<span class="keyword">long</span> position, <span class="keyword">long</span> count)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从通道中读取一系列字节到给定的缓冲区中</span></span><br><span class="line"><span class="comment">   * 从指定的读取开始位置position处读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst, <span class="keyword">long</span> position)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从给定的缓冲区写入字节序列到这个通道</span></span><br><span class="line"><span class="comment">     * 从指定的读取开始位置position处开始写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src, <span class="keyword">long</span> position)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Memory-mapped buffers --</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个文件映射模式类型安全枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    publicstaticclass MapMode &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只读映射模型</span></span><br><span class="line">        publicstaticfinal MapMode READ_ONLY</span><br><span class="line">            = <span class="keyword">new</span> MapMode(<span class="string">&quot;READ_ONLY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写映射模型</span></span><br><span class="line">        publicstaticfinal MapMode READ_WRITE</span><br><span class="line">            = <span class="keyword">new</span> MapMode(<span class="string">&quot;READ_WRITE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 私有模式（复制在写）映射</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        publicstaticfinal MapMode PRIVATE</span><br><span class="line">            = <span class="keyword">new</span> MapMode(<span class="string">&quot;PRIVATE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        privatefinal String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MapMode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将该通道文件的一个区域直接映射到内存中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,<span class="keyword">long</span> position, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前通道文件的给定区域上的锁</span></span><br><span class="line"><span class="comment">   * 区域就是从position处开始，size长度 </span></span><br><span class="line"><span class="comment">   * shared为true代表获取共享锁，false代表获取独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前通道文件上的独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取给定的通道文件区域上的锁</span></span><br><span class="line"><span class="comment">     * 区域就是从position处开始，size长度 </span></span><br><span class="line"><span class="comment">   * shared为true代表获取共享锁，false代表获取独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取当前通道文件上的独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryLock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、FileChannel常用方法介绍"><a href="#三、FileChannel常用方法介绍" class="headerlink" title="三、FileChannel常用方法介绍"></a>三、FileChannel常用方法介绍</h3><h4 id="3-1-通道获取"><a href="#3-1-通道获取" class="headerlink" title="3.1 通道获取"></a>3.1 通道获取</h4><p>FileChannel 可以通过 <code>FileInputStream</code>, <code>FileOutputStream</code>, <code>RandomAccessFile</code> 的对象中的 <code>getChannel()</code> 方法来获取，也可以通过静态方法 <code>FileChannel.open(Path, OpenOption ...)</code> 来打开。</p>
<ul>
<li><h5 id="FileChannel-open-的方式"><a href="#FileChannel-open-的方式" class="headerlink" title="FileChannel.open()的方式"></a><strong>FileChannel.open()的方式</strong></h5></li>
</ul>
<p>通过静态静态方法 FileChannel.open() 打开的通道可以指定打开模式，模式通过 StandardOpenOption 枚举类型指定。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channell = FileChannel.open(</span><br><span class="line">    Paths.get(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;c.txt&quot;</span>),    <span class="comment">// 路径:data/test/c.txt</span></span><br><span class="line">    StandardOpenOption.CREATE,</span><br><span class="line">    StandardOpenOption.WRITE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">FileChannel channel2 = FileChannel.open(</span><br><span class="line">    <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>).toPath(),</span><br><span class="line">    StandardOpenOption.CREATE_NEW,</span><br><span class="line">    StandardOpenOption.WRITE,StandardOpenOption.READ</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>path获取</strong></p>
<ul>
<li><strong>Paths.get(String first, String… more)</strong>:将传入的参数根据顺序进行统一拼接成为一个完整文件路径；</li>
<li><strong>new File(String pathname).toPath()</strong>:传入一个路径参数；</li>
</ul>
<p><strong>StandardOpenOption 枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StandardOpenOption</span> <span class="keyword">implements</span> <span class="title">OpenOption</span> </span>&#123;</span><br><span class="line">    READ, <span class="comment">// 读</span></span><br><span class="line">    WRITE, <span class="comment">// 写</span></span><br><span class="line">    APPEND, <span class="comment">// 在写模式下，进行追加写</span></span><br><span class="line">    TRUNCATE_EXISTING, <span class="comment">// 如果文件已经存在，并且它被打开以进行WRITE访问，那么它的长度将被截断为0。如果文件仅以READ访问方式打开，则忽略此选项。</span></span><br><span class="line">    CREATE, <span class="comment">// 如果文件不存在，请创建一个新文件。如果还设置了CREATE_NEW选项，则忽略此选项。与其他文件系统操作相比，检查文件是否存在以及创建文件(如果不存在)是原子性的。</span></span><br><span class="line">    CREATE_NEW, <span class="comment">// 创建一个新文件，如果文件已经存在则失败。与其他文件系统操作相比，检查文件是否存在以及创建文件(如果不存在)是原子性的。</span></span><br><span class="line">    DELETE_ON_CLOSE, <span class="comment">// 关闭时删除文件</span></span><br><span class="line">    SPARSE, <span class="comment">// 稀疏文件。当与CREATE_NEW选项一起使用时，此选项将提示新文件将是稀疏的。当文件系统不支持创建稀疏文件时，该选项将被忽略。</span></span><br><span class="line">    SYNC, <span class="comment">// 要求对文件内容或元数据的每次更新都以同步方式写入底层存储设备。</span></span><br><span class="line">    DSYNC; <span class="comment">// 要求对文件内容的每次更新都以同步方式写入底层存储设备。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="从-FileInputStream-FileOutputStream-中获取"><a href="#从-FileInputStream-FileOutputStream-中获取" class="headerlink" title="从 FileInputStream / FileOutputStream 中获取"></a>从 FileInputStream / FileOutputStream 中获取</h5></li>
</ul>
<p>从 <code>FileInputStream</code> 对象中获取的通道是以读的方式打开文件，从 <code>FileOutpuStream</code> 对象中获取的通道是以写的方式打开文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream ous = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">FileChannel out = ous.getChannel(); <span class="comment">// 获取一个只读通道</span></span><br><span class="line"></span><br><span class="line">FileInputStream ins = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">FileChannel in = ins.getChannel();  <span class="comment">// 获取一个只写通道</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="从-RandomAccessFile-中获取"><a href="#从-RandomAccessFile-中获取" class="headerlink" title="从 RandomAccessFile 中获取"></a>从 RandomAccessFile 中获取</h5></li>
</ul>
<p>从 RandomAccessFaile 中获取的通道取决于 RandomAccessFaile 对象是以什么方式创建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel channel = file.getChannel(); <span class="comment">// 获取一个可读写文件通道</span></span><br></pre></td></tr></table></figure>

<p><strong>模式说明</strong></p>
<ul>
<li><strong>r</strong>:读模式</li>
<li><strong>w</strong>:写模式</li>
<li><strong>rw</strong>:读写模式</li>
</ul>
<h4 id="3-2-读取数据"><a href="#3-2-读取数据" class="headerlink" title="3.2 读取数据"></a>3.2 读取数据</h4><p>读取数据的 <code>read(ByteBuffer buf)</code> 方法返回的值表示读取到的字节数，如果读到了文件末尾，返回值为 -1。读取数据时，position 会往后移动。</p>
<h5 id="将数据读取到单个缓冲区"><a href="#将数据读取到单个缓冲区" class="headerlink" title="将数据读取到单个缓冲区"></a>将数据读取到单个缓冲区</h5><p>和一般通道的操作一样，数据也是需要读取到1个缓冲区中，然后从缓冲区取出数据。在调用 read 方法读取数据的时候，可以传入参数 position 和 length 来指定开始读取的位置和长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;a.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(channel.read(buf)!=-<span class="number">1</span>)&#123;</span><br><span class="line">    buf.flip();</span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(buf.array()));</span><br><span class="line">    buf.clear();</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h5 id="读取到多个缓冲区"><a href="#读取到多个缓冲区" class="headerlink" title="读取到多个缓冲区"></a>读取到多个缓冲区</h5><p>文件通道 FileChannel 实现了 ScatteringByteChannel 接口，可以将文件通道中的内容同时读取到多个 ByteBuffer 当中，这在处理包含若干长度固定数据块的文件时很有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScatteringByteChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;a.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">ByteBuffer key = ByteBuffer.allocate(<span class="number">5</span>), value=ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">ByteBuffer[] buffers = <span class="keyword">new</span> ByteBuffer[]&#123;key, value&#125;;</span><br><span class="line"><span class="keyword">while</span>(channel.read(buffers)!=-<span class="number">1</span>)&#123;</span><br><span class="line">    key.flip();</span><br><span class="line">    value.flip();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(key.array()));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(value.array()));</span><br><span class="line">    key.clear();</span><br><span class="line">    value.clear();</span><br><span class="line">&#125;</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h4 id="3-3-写入数据"><a href="#3-3-写入数据" class="headerlink" title="3.3 写入数据"></a>3.3 写入数据</h4><h5 id="从单个缓冲区写入"><a href="#从单个缓冲区写入" class="headerlink" title="从单个缓冲区写入"></a>从单个缓冲区写入</h5><p>单个缓冲区操作也非常简单，它返回往通道中写入的字节数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;a.txt&quot;</span>), StandardOpenOption.WRITE);</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">&quot;Hello, Java NIO.&quot;</span>.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; ) &#123;</span><br><span class="line">    buf.put(data, i, Math.min(data.length - i, buf.limit() - buf.position()));</span><br><span class="line">    buf.flip();</span><br><span class="line">    i += channel.write(buf);</span><br><span class="line">    buf.compact();</span><br><span class="line">&#125;</span><br><span class="line">channel.force(<span class="keyword">false</span>);</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h5 id="从多个缓冲区写入"><a href="#从多个缓冲区写入" class="headerlink" title="从多个缓冲区写入"></a>从多个缓冲区写入</h5><p>FileChannel 实现了 GatherringByteChannel 接口，与 ScatteringByteChannel 相呼应。可以一次性将多个缓冲区的数据写入到通道中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;a.txt&quot;</span>), StandardOpenOption.WRITE);</span><br><span class="line">ByteBuffer key = ByteBuffer.allocate(<span class="number">10</span>), value = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">&quot;017 Robothy&quot;</span>.getBytes();</span><br><span class="line">key.put(data, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">value.put(data, <span class="number">4</span>, data.length-<span class="number">4</span>);</span><br><span class="line">ByteBuffer[] buffers = <span class="keyword">new</span> ByteBuffer[]&#123;key, value&#125;;</span><br><span class="line">key.flip();</span><br><span class="line">value.flip();</span><br><span class="line">channel.write(buffers);</span><br><span class="line">channel.force(<span class="keyword">false</span>); <span class="comment">// 将数据刷出到磁盘</span></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<p><strong>RandomAccessFile、FileInputStream、FileOutputStream比较</strong>：</p>
<table>
<thead>
<tr>
<th>获取方式</th>
<th>是否有文件读写权限</th>
</tr>
</thead>
<tbody><tr>
<td>RandomAccessFile.getChannel</td>
<td>可读，是否可写根据传入mode来判断</td>
</tr>
<tr>
<td>FileInputStream.getChannel</td>
<td>可读，不可写</td>
</tr>
<tr>
<td>FileOutputStream.getChannel</td>
<td>可写，不可读</td>
</tr>
</tbody></table>
<h4 id="3-4-数据刷出"><a href="#3-4-数据刷出" class="headerlink" title="3.4 数据刷出"></a>3.4 数据刷出</h4><p>为了减少访问磁盘的次数，通过文件通道对文件进行操作之后可能不会立即刷出到磁盘，此时如果系统崩溃，将导致数据的丢失。为了减少这种风险，在进行了重要数据的操作之后应该调用 force() 方法强制将数据刷出到磁盘。</p>
<p>无论是否对文件进行过修改操作，即使文件通道是以只读模式打开的，只要调用了 force(metaData) 方法，就会进行一次 I/O 操作。参数 metaData 指定是否将元数据（例如：访问时间）也刷出到磁盘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.force(<span class="keyword">false</span>); <span class="comment">// 将数据刷出到磁盘，但不包括元数据</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-关闭FileChannel"><a href="#3-5-关闭FileChannel" class="headerlink" title="3.5 关闭FileChannel"></a>3.5 关闭FileChannel</h4><p>用完FileChannel后必须将其关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>

<h4 id="3-6-其他方法"><a href="#3-6-其他方法" class="headerlink" title="3.6 其他方法"></a>3.6 其他方法</h4><ul>
<li><h5 id="position"><a href="#position" class="headerlink" title="position()"></a><strong>position()</strong></h5></li>
</ul>
<p>描述：如果想在 FileChannel 的某一个指定位置读写数据，可以通过调用 FileChannel 的 position() 方法来获取当前的 position 值，也可以调用 FileChannel 的 position(long pos) 方法设置 position 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line"></span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>如果设置的 position 值超出了 File 文件的最后位置，在读取该 Channel 时就会返回 -1 ，即返回“<strong>读取到文件的末尾</strong>”的标识。</p>
<p>但此时若向 Channel 中写入数据，该 Channel 连接的 File 会被“扩张”到这个设置的 position 值的位置，然后将数据写入到这个 File 中，这会导致该 File 带有“空洞”，<strong>存储在磁盘上的这个物理文件就会不连续</strong>。</p>
<ul>
<li><h5 id="size"><a href="#size" class="headerlink" title="size()"></a><strong>size()</strong></h5></li>
</ul>
<p>FileChannel 的 size() 方法会返回这个 FileChannel 连接的 File 文件的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="truncate"><a href="#truncate" class="headerlink" title="truncate()"></a><strong>truncate()</strong></h5></li>
</ul>
<p>可以调用 <code>FileChannel.truncate()</code> 方法截断一个 File。截断时需要指定一个长度。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">channel<span class="selector-class">.truncate</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>本示例将文件长度截断为1024个字节。</p>
<ul>
<li><p>如果给定大小小于该文件的当前大小，则截取该文件，丢弃文件末尾后面的所有字节。</p>
</li>
<li><p>如果给定大小大于或等于该文件的当前大小，则不修改文件。</p>
</li>
<li><p>无论是哪种情况，如果此通道的文件位置大于给定大小，则将位置设置为该大小。</p>
</li>
<li><h5 id="transferTo-和-transferFrom方法"><a href="#transferTo-和-transferFrom方法" class="headerlink" title="transferTo 和 transferFrom方法"></a><strong>transferTo 和 transferFrom方法</strong></h5></li>
</ul>
<p><strong>通道之间的数据传输：</strong>如果两个通道中有一个是 FileChannel，那你可以直接将数据从一个 channel 传输到另外一个 channel。</p>
<p><strong>transferFrom()</strong>:FileChannel 的 <code>transferFrom()</code>方法可以将数据从源通道传输到 <code>FileChannel</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src,<span class="keyword">long</span> position, <span class="keyword">long</span> count)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>src</strong>：源通道。</li>
<li><strong>position</strong>:文件中的位置，从此位置开始传输；必须为非负数。</li>
<li><strong>count</strong>: 要传输的最大字节数；必须为非负数。</li>
</ul>
<p>如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。</p>
<p><strong>transferTo()</strong>:将数据从 FileChannel 传输到其他的 channel 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,WritableByteChannel target)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>position</strong>:文件中的位置，从此位置开始传输，必须为非负数。</li>
<li><strong>count</strong>:要传输的最大字节数；必须为非负数。</li>
<li><strong>target</strong>:目标通道</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/27</span></span><br><span class="line"><span class="comment"> * Description 对文件进行复制操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copyFileChannelDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备输入流(源文件)</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;datas/data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//准备输出流(目标文件)</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;datas/data3.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据流获取通道</span></span><br><span class="line">        FileChannel inputStreamChannel = fileInputStream.getChannel();</span><br><span class="line">        FileChannel outputStreamChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向复制方法</span></span><br><span class="line"><span class="comment">//        outputStreamChannel.transferFrom(inputStreamChannel,0,inputStreamChannel.size());</span></span><br><span class="line">        inputStreamChannel.transferTo(<span class="number">0</span>,inputStreamChannel.size(),outputStreamChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO之FileChannel练习"><a href="#NIO之FileChannel练习" class="headerlink" title="NIO之FileChannel练习"></a>NIO之FileChannel练习</h2><blockquote>
<p>将数据写入指定文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/27</span></span><br><span class="line"><span class="comment"> * Description channel Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">channelDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得一个根据指定文件路径的读写权限文件通道</span></span><br><span class="line">        FileChannel fileChannel = FileChannel.open(<span class="keyword">new</span> File(<span class="string">&quot;datas/data.txt&quot;</span>).toPath(), StandardOpenOption.WRITE,StandardOpenOption.READ);</span><br><span class="line">        <span class="comment">//获得一段有指定内容的缓冲区</span></span><br><span class="line">        ByteBuffer source = ByteBuffer.wrap(<span class="string">&quot;helloWorld,Scala,Java&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        ByteBuffer target = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        log.info(<span class="string">&quot;fileChannel.position():&#123;&#125;&quot;</span>,fileChannel.position());</span><br><span class="line">        <span class="comment">//将缓冲区中的内容写入文件通道</span></span><br><span class="line">        fileChannel.write(source);</span><br><span class="line">        <span class="comment">//通道大小</span></span><br><span class="line">        log.info(<span class="string">&quot;fileChannel.position():&#123;&#125;&quot;</span>, fileChannel.position());</span><br><span class="line">        <span class="comment">//设置读写位置</span></span><br><span class="line">        fileChannel.position(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//将通道中的内容写到空缓冲区</span></span><br><span class="line">        fileChannel.read(target);</span><br><span class="line">        <span class="comment">//转换缓冲区读写模式</span></span><br><span class="line">        target.flip();</span><br><span class="line">        log.info(<span class="string">&quot;target:&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(target.array(), <span class="number">0</span>, target.limit()));</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据读写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/27</span></span><br><span class="line"><span class="comment"> * Description 数据读写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">channelDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;datas/data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//根据输出流获得一个&quot;写&quot;权限的通道</span></span><br><span class="line">        FileChannel outChannel = outputStream.getChannel();</span><br><span class="line">        <span class="comment">//获得一个有指定内容的缓冲区</span></span><br><span class="line">        ByteBuffer source = ByteBuffer.wrap(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//将缓冲区内容写入到通道</span></span><br><span class="line">        outChannel.write(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取输入流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;datas/data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//根据输入流获得一个&quot;读&quot;权限的通道</span></span><br><span class="line">        FileChannel inChannel = fileInputStream.getChannel();</span><br><span class="line">        <span class="comment">//获得一个空内容的缓冲区</span></span><br><span class="line">        ByteBuffer target = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//将通道中的内容读到缓冲区</span></span><br><span class="line">        inChannel.read(target);</span><br><span class="line">        <span class="comment">//转换缓冲区读写模式</span></span><br><span class="line">        target.flip();</span><br><span class="line">        <span class="comment">//读出缓冲区中的内容</span></span><br><span class="line">        log.info(<span class="string">&quot;target:&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(target.array(), <span class="number">0</span>, target.limit()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        outChannel.close();</span><br><span class="line">        inChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>超过 2g 大小的文件传输</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/27</span></span><br><span class="line"><span class="comment"> * Description 超过 2g 大小的文件传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileChannelTransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileChannel from = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;datas/data.txt&quot;</span>).getChannel();</span><br><span class="line">                FileChannel to = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;datas/to.txt&quot;</span>).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class="line">            <span class="keyword">long</span> size = from.size();</span><br><span class="line">            <span class="comment">// left 变量代表还剩余多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;position:&quot;</span> + (size - left) + <span class="string">&quot; left:&quot;</span> + left);</span><br><span class="line">                left -= from.transferTo((size - left), left, to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileChannel Demo 改变子缓冲区内容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/27</span></span><br><span class="line"><span class="comment"> * Description FileChannel Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileChannelDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        testSlice();</span></span><br><span class="line"><span class="comment">//        testFileChannel();</span></span><br><span class="line"><span class="comment">//        testIntBuffer();</span></span><br><span class="line"><span class="comment">//        writeFileChannel();</span></span><br><span class="line">        testFileChannelTransfer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切片:改变缓冲区的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSlice</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;datas/data.txt&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = accessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//将数据读入缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.position(<span class="number">3</span>);</span><br><span class="line">        buffer.limit(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于创建一个新的字节缓冲区，其内容是给定缓冲区内容的共享子序列。</span></span><br><span class="line">        ByteBuffer slice = buffer.slice();</span><br><span class="line">        <span class="comment">//改变子缓冲区内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;slice.capacity();i++)&#123;</span><br><span class="line">            <span class="keyword">byte</span> b = slice.get(i);</span><br><span class="line">            b *=<span class="number">2</span>;</span><br><span class="line">            slice.put(i,b);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.position(<span class="number">0</span>);</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fileChannel读文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        RandomAccessFile accessFile = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;datas/data.txt&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = accessFile.getChannel();</span><br><span class="line">        <span class="comment">//缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将数据读入缓冲区</span></span><br><span class="line">        <span class="comment">//返回的值表示读取到的字节数，如果读到了文件末尾，返回值为 -1</span></span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;file长度:&quot;</span>+read);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//切换到写模式,position=0,limit变为capacity</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            read = channel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        accessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * intBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIntBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//用于在现有缓冲区旁边分配一个新的int缓冲区</span></span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fileChannel写文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFileChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile rw = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;datas/data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = rw.getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;欢迎来到李林超博客!!!&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fileChannel通道之间传输</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFileChannelTransfer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile accessFileA = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;datas/data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channelFrom = accessFileA.getChannel();</span><br><span class="line">        RandomAccessFile accessFileB = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;datas/dataB.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channelTo = accessFileB.getChannel();</span><br><span class="line">        <span class="comment">//from 的内容传输到 channelTo</span></span><br><span class="line">        channelTo.transferFrom(channelFrom,<span class="number">0</span>,channelFrom.size());</span><br><span class="line">        accessFileA.close();</span><br><span class="line">        accessFileB.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO之Path介绍"><a href="#NIO之Path介绍" class="headerlink" title="NIO之Path介绍"></a>NIO之Path介绍</h2><h3 id="一、Path介绍"><a href="#一、Path介绍" class="headerlink" title="一、Path介绍"></a>一、Path介绍</h3><p>Path接口是java NIO2的一部分。首次在java 7中引入。Path接口在<code>java.nio.file</code>包下，所以全称是<code>java.nio.file.Path</code>。</p>
<p>java中的Path表示文件系统的路径。可以指向文件或文件夹。</p>
<p><strong>Path同时也有相对路径和绝对路径之分：</strong></p>
<ul>
<li><strong>绝对路径</strong>：表示从文件系统的根路径到文件或是文件夹的路径。</li>
<li><strong>相对路径</strong>：表示从特定路径下访问指定文件或文件夹的路径。</li>
</ul>
<h3 id="二、Path方法介绍"><a href="#二、Path方法介绍" class="headerlink" title="二、Path方法介绍"></a>二、Path方法介绍</h3><h4 id="2-1-创建Path实例"><a href="#2-1-创建Path实例" class="headerlink" title="2.1 创建Path实例"></a>2.1 创建Path实例</h4><p>如果使用java.nio.file.Path实例，必须先创建它。通过<code>Paths.get(String first, String… more)</code>静态工厂方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/5/29</span></span><br><span class="line"><span class="comment"> * Description 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Path实例</span></span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;D:\\path_test\\first_path.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-创建绝对路径"><a href="#2-2-创建绝对路径" class="headerlink" title="2.2 创建绝对路径"></a>2.2 创建绝对路径</h4><p><strong>以绝对路径文件作为参数</strong>调用Paths.get()工厂方法就是创建一个绝对Path实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// windows 系统</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\first_path.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unix系统</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;/home/path_test/first_path.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><p>参数<code>D:\\path_test\\first_path.txt</code>是一个绝对路径。</p>
<p>  有两个<code>\</code>字符的原因是第一个<code>\</code>是转义字符，表示紧跟着它的字符需要被转义。</p>
<p>  <code>\\</code>表示需要向字符串中写入一个<code>\</code>字符。</p>
</li>
<li><p>在Unix系统(Linux,MacOS,FreeBSD等)中通过使用<code>/</code>来表示路径</p>
</li>
</ul>
<h4 id="2-3-创建相对路径"><a href="#2-3-创建相对路径" class="headerlink" title="2.3 创建相对路径"></a>2.3 创建相对路径</h4><p><strong>相对路径指从一个已确定的路径开始到某一文件或文件夹的路径。将确定路径和相对路径拼接起来就是相对路径对应的绝对路径地址。</strong></p>
<p>Paths类可以创建相对路径的实例，可以使用<code>Paths.get(String basePath, String relativePath)</code>方法来创建一个相对路径的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个指向d:\path_test\demo文件夹路径的实例</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\path_test&quot;</span>, <span class="string">&quot;demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向d:\path_test\demo\first_path.txt文件路径的实例</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\path_test&quot;</span>, <span class="string">&quot;demo\\first_path.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过上方的示例，第一感觉就是，将两个参数拼接起来以构成一个访问该文件的绝对路径。</p>
<p>这样理解也没有错，只是，参数的路径表达方式更加的灵活，可以跟上特殊符号<code>.</code>和<code>..</code>。</p>
<ul>
<li><strong><code>.</code>代表当前目录</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绝对路径就是该代码运行时的目录的绝对路径</span></span><br><span class="line">Path currentDir = Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(currentDir.toAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">D:\Codes\idea\netty-demo\.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>..</code>代表父目录或者是上一级目录</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Path实例的绝对路径就是该代码运行时的父目录的绝对路径</span></span><br><span class="line">Path parentDir = Paths.get(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">System.out.println(parentDir.toAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">D:\Codes\idea\netty-demo\..</span></span><br></pre></td></tr></table></figure>

<ul>
<li>. <strong>和 … 可以在Paths.get() 方法中结合使用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(<span class="string">&quot;d:\\path_test&quot;</span>, <span class="string">&quot;.\\demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">Path path2 = Paths.get(<span class="string">&quot;d:\\path_test\\demo&quot;</span>,  <span class="string">&quot;..\\demo2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-Path-normalize-方法"><a href="#2-4-Path-normalize-方法" class="headerlink" title="2.4 Path.normalize()方法"></a>2.4 Path.normalize()方法</h4><p>Path接口中的normalize()可以标准化一个路径。标准化意思是解析路径中的<code>.</code>和 <code>..</code> 。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String originalPath =  <span class="string">&quot;d:\\path_test\\demo\\..\\demo2&quot;</span>;</span><br><span class="line"></span><br><span class="line">Path path1 = Paths.get(originalPath);</span><br><span class="line">System.out.println(<span class="string">&quot;path1 = &quot;</span> + path1);</span><br><span class="line"></span><br><span class="line">Path path2 = path1.normalize();</span><br><span class="line">System.out.println(<span class="string">&quot;path2 = &quot;</span> + path2);</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">path1</span> = d:\path_test\demo\..\demo2</span><br><span class="line"><span class="attr">path2</span> = d:\path_test\demo2</span><br></pre></td></tr></table></figure>

<p>我们可以看到规范化的路径没有包含<code>demo..</code>多余的部分，移除的部分对于绝对路径是无关紧要的。</p>
<h2 id="NIO之Files介绍"><a href="#NIO之Files介绍" class="headerlink" title="NIO之Files介绍"></a>NIO之Files介绍</h2><h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><p><code>Files</code>是Java1.7 在<code>nio</code>中新增的专门用于处理文件和目录的工具类。<code>Files</code>和<code>Path</code>配合可以很方便的完成对文件/目录的创建、读取、修改、删除等操作。</p>
<h3 id="二、常用方法介绍"><a href="#二、常用方法介绍" class="headerlink" title="二、常用方法介绍"></a>二、常用方法介绍</h3><h4 id="2-1-Files-exits"><a href="#2-1-Files-exits" class="headerlink" title="2.1 Files.exits()"></a>2.1 Files.exits()</h4><blockquote>
<p>boolean exists(Path path, LinkOption… options)</p>
</blockquote>
<p><strong>描述</strong>：方法检查一个路径是否存在于当前的文件系统中。</p>
<p><strong>参数</strong>：</p>
<ul>
<li>Path ：传入的文件路径。<strong>必须</strong></li>
<li>LinkOption：<code>exits()</code>方法的选项数组。如<code>LinkOption.NOFOLLOW_LINKS</code>代表不允许跟随文件系统中的符号链接来确定路径是否存在。<strong>非必须</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> exists = Files.exists(path);</span><br><span class="line">System.out.println(exists);</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Files-createDirectory"><a href="#2-2-Files-createDirectory" class="headerlink" title="2.2 Files.createDirectory()"></a>2.2 Files.createDirectory()</h4><blockquote>
<p>createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs)</p>
</blockquote>
<p><strong>描述</strong>：此方法使用给定的路径创建目录，如果创建目录成功，它将返回创建的目录的路径。</p>
<p><strong>参数</strong>：</p>
<ul>
<li>Path ：需要创建的文件路径。<strong>必须</strong></li>
<li>FileAttribute：是在创建不存在的目录时自动设置的可选参数，它返回创建的目录的路径。<strong>非必须</strong></li>
</ul>
<p>注意</p>
<ul>
<li>如果目录已经存在，那么它会抛出<strong>nio.file.FileAlreadyExistsException。</strong></li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Files-createDirectories"><a href="#2-3-Files-createDirectories" class="headerlink" title="2.3 Files.createDirectories()"></a>2.3 Files.createDirectories()</h4><blockquote>
<p>createDirectories(Path dir, FileAttribute&lt;?&gt;… attrs)</p>
</blockquote>
<p><strong>描述</strong>：此方法通过首先创建所有不存在的父目录来使用给定路径创建目录。如果由于目录已存在而无法创建该目录，则此方法不会引发异常。</p>
<p>该方法用来创建多级目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo3\\a\\b&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-Files-copy"><a href="#2-4-Files-copy" class="headerlink" title="2.4 Files.copy()"></a>2.4 Files.copy()</h4><blockquote>
<p>long copy(InputStream in, Path target, CopyOption… options)</p>
</blockquote>
<p><strong>描述</strong>：此方法将指定输入流中的所有字节复制到指定目标文件，并返回读取或写入的字节数作为长值。</p>
<ul>
<li><strong>将InputStream中的数据复制到目标文件</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\path_test\\demo\\first_input.txt&quot;</span>);</span><br><span class="line">Path targetPath = Paths.get(<span class="string">&quot;D:\\path_test\\demo3\\first_copy2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> size = Files.copy(inputStream, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">System.out.println(size);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>默认情况，如果目标文件已经存在或是一个符号链接，则复制失败；</li>
<li>指定了REPLACE_EXISTING的情况，如果目标文件已经存在，那么只要它不是一个非空目录（例如它是一个空目录，或者是一个符号链接），它就会被替换。截止到JDK1.8，options只支持<code>REPLACE_EXISTING</code>。</li>
</ul>
<blockquote>
<p>long copy(Path source, OutputStream out)</p>
</blockquote>
<p><strong>描述</strong>：此方法将指定源文件中的所有字节复制到给定的输出流，并返回读取或写入的字节数作为长值。</p>
<ul>
<li><strong>将本地文件中的内容复制到OutputStream</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo\\first_copy.txt&quot;</span>);</span><br><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\path_test\\demo\\first_output.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> size = Files.copy(path, outputStream);</span><br><span class="line">System.out.println(size);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>当发生异常的时候，由于输出了可能已经获取到了一部分内容，所以输出流此时的内容可能很奇怪，应该直接关闭。</li>
<li>如果输出流是Flushable的实现类的实例，在执行完方法以后应该调用flush方法以刷新缓存。</li>
</ul>
<blockquote>
<p>Path copy(Path source, Path target, CopyOption… options)</p>
</blockquote>
<p><strong>描述</strong>：此方法将给定的源文件复制到指定的目标文件，并返回目标文件的路径。</p>
<ul>
<li><strong>将文件first_copy.txt复制到文件first_copy2.txt</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo3\\first_copy.txt&quot;</span>);</span><br><span class="line">Path targetPath = Paths.get(<span class="string">&quot;D:\\path_test\\demo3\\first_copy2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Path copy = Files.copy(path, targetPath);</span><br><span class="line">System.out.println(copy);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>在默认情况下，如果目标文件已经存在，或者是一个符号链接，那么复制失败；</li>
</ul>
<p><strong>options参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>REPLACE_EXISTING</td>
<td>如果目标文件已经存在，那么只要它不是一个非空目录，它就会被替换。</td>
</tr>
<tr>
<td>COPY_ATTRIBUTES</td>
<td>把source的文件属性复制给target，被复制的属性取决于平台和文件系统，但是至少在source和target都支持的情况下，会复制最新修改时间。</td>
</tr>
<tr>
<td>NOFOLLOW_LINKS</td>
<td>直接复制符号链接自身，而不是符号链接指向的目的地。可被复制的属性也会被复制，也就是说NOFOLLOW_LINKS的情况下配置COPY_ATTRIBUTES是没有意义的。</td>
</tr>
</tbody></table>
<h4 id="2-5-Files-move"><a href="#2-5-Files-move" class="headerlink" title="2.5 Files.move()"></a>2.5 Files.move()</h4><blockquote>
<p>move(Path source, Path target, CopyOption… options)</p>
</blockquote>
<p><strong>描述</strong>：此方法将源文件移动或重命名为目标文件，并返回目标文件的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path sourcePath = Paths.get(<span class="string">&quot;D:\\path_test\\demo\\first_copy.txt&quot;</span>);</span><br><span class="line">Path targetPath = Paths.get(<span class="string">&quot;D:\\path_test\\demo3\\first_copy2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Path move = Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">System.out.println(move);</span><br></pre></td></tr></table></figure>

<p><strong>options参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>REPLACE_EXISTING</td>
<td>如果目标文件存在，则如果它不是非空目录，则替换它。</td>
</tr>
<tr>
<td>ATOMIC_MOVE</td>
<td>表示移动文件作为原子文件系统操作执行，所有其他选项都被忽略。</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<ul>
<li>如果目标文件存在但由于未指定<strong>REPLACE_EXISTING</strong>选项而无法替换，则此方法将引发<strong>FileAleadyExistsException</strong>。</li>
<li>如果指定了<strong>REPlACE_EXISTING</strong>选项，则此方法将引发<strong>DirectoryNotEmptyException</strong>但无法替换该文件，因为它是一个非空目录。</li>
</ul>
<h4 id="2-6-Files-delete"><a href="#2-6-Files-delete" class="headerlink" title="2.6 Files.delete()"></a>2.6 Files.delete()</h4><blockquote>
<p>void delete(Path path)</p>
</blockquote>
<p><strong>描述</strong>：删除一个文件或文件夹。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\path_test\\demo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果path指定到一个目录，并且目标不为空时会抛出异常</span></span><br><span class="line">Files.delete(path);</span><br></pre></td></tr></table></figure>

<p>如果目标存在，并且是文件或者空的文件夹，就删除文件；如果目标不存在，或者目标是非空的文件夹，就会抛出异常。</p>
<h4 id="2-7-Files-walkFileTree"><a href="#2-7-Files-walkFileTree" class="headerlink" title="2.7 Files.walkFileTree()"></a>2.7 Files.walkFileTree()</h4><p><strong>描述</strong>：<code>Files.walkFileTree()</code>方法可以递归遍历目录树。它使用一个<code>Path</code>和一个<code>FileVisitor</code>作为参数。</p>
<p><strong>首先先展示一下<code>FileVisitor</code>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Files.walkFileTree()</code>方法需要一个<code>FileVisitor</code>的实现类作为参数，实现<code>FileVisitor</code>接口就需要实现上述方法。</p>
<p>如果不想做特殊实现或者只想实现一部分，可以继承<code>SimpleFileVisitor</code>类，它其中有对<code>FileVisitor</code>的方法的默认实现。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> FileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;pre visit dir:&quot;</span> + dir);</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;visit file: &quot;</span> + file);</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;visit file failed: &quot;</span> + file);</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;post visit directory: &quot;</span> + dir);</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>这些方法在遍历的不同时间被调用</strong></p>
<ul>
<li><code>preVisitDirectory()</code>方法在访问任何目录前被调用。</li>
<li><code>postVisitDirectory()</code>方法在访问任何目录后被调用。</li>
<li><code>visitFile()</code>方法在访问任何文件时被调用。</li>
<li><code>visitFileFailed()</code>在访问任何文件失败时被调用。（比如没权限）</li>
</ul>
<p>每个方法返回一个<code>FileVisitResult</code>枚举，这些返回指决定了遍历如何进行。</p>
<p><strong>包括</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CONTINUE</td>
<td>表示遍历将继续正常进行</td>
</tr>
<tr>
<td>TERMINATE</td>
<td>表示文件遍历将终止</td>
</tr>
<tr>
<td>SKIP_SIBLINGS</td>
<td>表示文件遍历将继续，但不在访问此文件/目录的同级文件/目录</td>
</tr>
<tr>
<td>SKIP_SUBTREE</td>
<td>表示文件遍历将继续，但不再访问此目录内的文件</td>
</tr>
</tbody></table>
<h2 id="NIO之Files-Demo"><a href="#NIO之Files-Demo" class="headerlink" title="NIO之Files Demo"></a>NIO之Files Demo</h2><h3 id="一、遍历目录文件"><a href="#一、遍历目录文件" class="headerlink" title="一、遍历目录文件"></a>一、遍历目录文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 遍历目录，统计文件和文件夹个数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesTraverseDirectoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;D:\\Tools\\jdk1.8.0_201&quot;</span>);</span><br><span class="line">        AtomicInteger dirCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        Files.walkFileTree(path,<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">//preVisitDirectory()在访问任何目录前被调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(dir);</span><br><span class="line">                dirCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//visitFile()在访问任何文件时被调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                fileCount.incrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(dirCount);</span><br><span class="line">        System.out.println(fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、统计Jar的数目"><a href="#二、统计Jar的数目" class="headerlink" title="二、统计Jar的数目"></a>二、统计Jar的数目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 统计文件中Jar的个数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesCountJarNumberDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;D:\\Tools\\jdk1.8.0_201&quot;</span>);</span><br><span class="line">        AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        Files.walkFileTree(path,<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">//visitFile()在访问任何文件时被调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>))&#123;</span><br><span class="line">                    fileCount.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、删除多级目录"><a href="#三、删除多级目录" class="headerlink" title="三、删除多级目录"></a>三、删除多级目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 删除多级目录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesDeleteDirectoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;D:\\libs2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Files.walkFileTree(path,<span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">//visitFile()在访问任何文件时被调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//postVisitDirectory()在访问任何目录后被调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除完毕!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、拷贝多级目录"><a href="#四、拷贝多级目录" class="headerlink" title="四、拷贝多级目录"></a>四、拷贝多级目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 拷贝多级目录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesCopyDirectoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String source = <span class="string">&quot;D:\\libs&quot;</span>;</span><br><span class="line">        String target = <span class="string">&quot;D:\\libs_aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String targetName = path.toString().replace(source,target);</span><br><span class="line">                <span class="comment">//是目录</span></span><br><span class="line">                <span class="keyword">if</span>(Files.isDirectory(path))&#123;</span><br><span class="line">                    <span class="comment">//createDirectory()方法利用Path创建一个新的目录</span></span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Files.isRegularFile(path))&#123; <span class="comment">//是普通文件</span></span><br><span class="line">                    <span class="comment">//copy()方法将文件从一个path复制到另一个</span></span><br><span class="line">                    Files.copy(path,Paths.get(targetName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO之阻塞模式和非阻塞模式"><a href="#NIO之阻塞模式和非阻塞模式" class="headerlink" title="NIO之阻塞模式和非阻塞模式"></a>NIO之阻塞模式和非阻塞模式</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p><strong>SocketChannel方法介绍</strong></p>
<ul>
<li><p>创建一个服务器对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel.open()</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器对象需要绑定ip和端口，使用<code>bind(InetSocketAddress )</code>方法，需要使用传入<code>InetSocketAddress</code>，只需传入一个端口号即可;</li>
<li>服务器调用accept()方法获取客户端的连接请求;</li>
<li>通过接收到的客户端连接对象<code>read(buffer)</code>方法获取客户端发送的消息。</li>
</ul>
</li>
<li><p>创建客户端</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel.open()</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端使用<code>connect(InetSocketAddress server)</code>方法，连接对应的服务器;</li>
<li>通过<code>write(buffer)</code>方法发送消息到连接的服务器</li>
</ul>
</li>
</ul>
<h3 id="一、阻塞模式"><a href="#一、阻塞模式" class="headerlink" title="一、阻塞模式"></a>一、阻塞模式</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<h4 id="1-2-代码演示"><a href="#1-2-代码演示" class="headerlink" title="1.2 代码演示"></a>1.2 代码演示</h4><ul>
<li>服务端代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.util.ByteBufferUtil.debugRead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用 nio 来理解阻塞模式, 单线程  服务端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ByteBuffer缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//1. 创建服务器</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.绑定监听端口</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//3.连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环接收客户端的连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4. accept建立与客户端连接，SocketChannel 用来与客户端之间通信</span></span><br><span class="line">            log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">            <span class="comment">//阻塞方法，没有连接时，会阻塞线程</span></span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">            channels.add(sc);</span><br><span class="line">            <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channels)&#123;</span><br><span class="line">                <span class="comment">// 处理通道中的数据</span></span><br><span class="line">                <span class="comment">// 当通道中没有数据可读时，会阻塞线程</span></span><br><span class="line">                log.debug(<span class="string">&quot;befor read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                <span class="comment">//切换到读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                debugRead(buffer);</span><br><span class="line">                <span class="comment">//切换到写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">                log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-结果分析"><a href="#1-3-结果分析" class="headerlink" title="1.3 结果分析"></a>1.3 结果分析</h4><p><strong>1、启动服务端程序</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/973280649.jpg" alt="11.NIO之阻塞模式和非阻塞模式01.jpg"></p>
<ul>
<li>当刚启动服务端程序时，会在accept()方法产生阻塞，等待客户端的连接。</li>
</ul>
<p><strong>客户端-服务器建立连接前，服务器端因accept阻塞</strong></p>
<p><strong>2、通过Debug模式启动客户端</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2894464752.jpg" alt="11.NIO之阻塞模式和非阻塞模式02.jpg"></p>
<ul>
<li>客户端在acccept()方法没有继续阻塞，向下运行；</li>
<li>在read()方法等待读入数据，当客户端没有向服务器端发送数据时，会在此产生阻塞；</li>
</ul>
<p><strong>客户端-服务器建立连接后，客户端发送消息前，服务器端因通道为空被阻塞</strong></p>
<p><strong>3、客户端向服务端发送数据</strong></p>
<ul>
<li><strong>向服务端发送数据</strong></li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3235651179.jpg" alt="11.NIO之阻塞模式和非阻塞模式03.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;hello!&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>控制台打印结果</strong></li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1365421407.jpg" alt="11.NIO之阻塞模式和非阻塞模式04.jpg"></p>
<p><strong>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</strong></p>
<p><strong>4、之前的客户端再次发送消息</strong></p>
<p><strong>服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息，影响了整个程序的正常执行。</p>
<h3 id="二、非阻塞模式"><a href="#二、非阻塞模式" class="headerlink" title="二、非阻塞模式"></a>二、非阻塞模式</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><ul>
<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<h4 id="2-2-代码演示"><a href="#2-2-代码演示" class="headerlink" title="2.2 代码演示"></a>2.2 代码演示</h4><ul>
<li><p><strong>服务端代码</strong></p>
<ul>
<li><p>可以通过<code>ServerSocketChannel</code>的<code>configureBlocking(false)</code>方法将<strong>获得连接设置为非阻塞的</strong>。</p>
<p>  此时若没有连接，accept会返回null</p>
</li>
<li><p>可以通过<code>SocketChannel</code>的<code>configureBlocking(false)</code>方法将从通道中<strong>读取数据设置为非阻塞的</strong>。</p>
<p>  若此时通道中没有数据可读，read会返回-1</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.util.ByteBufferUtil.debugRead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/5/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用 nio 来理解非阻塞模式  服务端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ByteBuffer缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//1. 创建服务器</span></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);   <span class="comment">//非阻塞模式</span></span><br><span class="line">        <span class="comment">//2.绑定监听端口</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//3.连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环接收客户端的连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4. accept建立与客户端连接，SocketChannel 用来与客户端之间通信</span></span><br><span class="line">            SocketChannel sc = ssc.accept();    <span class="comment">//非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">            <span class="keyword">if</span>(sc != <span class="keyword">null</span>)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);    <span class="comment">//非阻塞模式</span></span><br><span class="line">                channels.add(sc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channels)&#123;</span><br><span class="line">                <span class="comment">//5. 接收客户端发送的数据</span></span><br><span class="line">                <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//切换到读模式</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugRead(buffer);</span><br><span class="line">                    <span class="comment">//切换到写模式</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端代码不变</li>
</ul>
<p>该方法虽然可以解决阻塞模式下的问题，但是因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求。</p>
<h2 id="NIO之选择器（Selector）"><a href="#NIO之选择器（Selector）" class="headerlink" title="NIO之选择器（Selector）"></a>NIO之选择器（Selector）</h2><h3 id="一、概述-2"><a href="#一、概述-2" class="headerlink" title="一、概述"></a>一、概述</h3><p> Selector一般称为选择器，也可以翻译为多路复用器，是Java NIO核心组件之一，主要功能是<strong>用于检查一个或者多个NIO Channel（通道）的状态是否处于可读、可写</strong>。如此可以实现单线程管理多个Channel（通道），当然也可以管理多个网络连接。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2649586076.png" alt="12.NIO之选择器（Selector）01.png"></p>
<p> 使用Selector的好处在于，可以<strong>使用更少的线程来处理更多的通道</strong>，相比使用更多的线程，<strong>避免了线程上下文切换带来的开销</strong>等。</p>
<h3 id="二、Selector（选择器）方法"><a href="#二、Selector（选择器）方法" class="headerlink" title="二、Selector（选择器）方法"></a>二、Selector（选择器）方法</h3><h4 id="2-1-Selector的创建"><a href="#2-1-Selector的创建" class="headerlink" title="2.1 Selector的创建"></a>2.1 Selector的创建</h4><p>通过调用静态工厂方法<code>Selector.open()</code>方法创建一个Selector对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<p>open()方法实际上是向SPI发出请求，通过默认的SelectorProvider对象获取一个新的Selector实例。</p>
<h4 id="2-2-注册Channel到Selector"><a href="#2-2-注册Channel到Selector" class="headerlink" title="2.2 注册Channel到Selector"></a>2.2 注册Channel到Selector</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代码的第一行</strong>：让这个Channel（通道）是非阻塞的。</p>
<ul>
<li><p>它是<strong>SelectableChannel</strong>抽象类里的方法，用于使通道处于阻塞模式或非阻塞模式，false表示非阻塞，true表示阻塞。</p>
</li>
<li><p>它的签名是：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>要想Channel注册到Selector中，那么这个Channel必须是<strong>非阻塞的</strong>。</p>
<p>  所以FileChannel不适合Selector，因为FileChannel不能切换为非阻塞模式，更准确的说是因为FileChannel没有继承SelectableChannel。但是SocketChannel可以正常使用。</p>
</li>
</ul>
</li>
<li><p><strong>代码的第二行</strong>：register()方法就是将通道注册到Selector中，并且让Selector监听感兴趣的事件（第二个参数）。</p>
<ul>
<li>着重讲一下第二个参数，它是一个“interest集合”，意思是在通过Selector监听Channel对什么事件感兴趣。可以监听四种不同类型的事件：Connect、Accept、Read、Write。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>常量表示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Connect</td>
<td>SelectionKey.OP_CONNECT</td>
<td>成功连接到另一个服务器称为“连接就绪”</td>
</tr>
<tr>
<td>Accept</td>
<td>SelectionKey.OP_ACCEPT</td>
<td>ServerSocketChannel准备好接收新进入的连接称为“接收就绪”</td>
</tr>
<tr>
<td>Read</td>
<td>SelectionKey.OP_READ</td>
<td>有数据可读的通道称为“读就绪”</td>
</tr>
<tr>
<td>Write</td>
<td>SelectionKey.OP_WRITE</td>
<td>等待写数据的通道称为“写就绪”</td>
</tr>
</tbody></table>
<p>如果对不止一种事件感兴趣，可以使用或（ | ）运算符来操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-SelectionKey"><a href="#2-3-SelectionKey" class="headerlink" title="2.3 SelectionKey"></a>2.3 SelectionKey</h4><p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key.attachment(); <span class="comment">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。</span></span><br><span class="line">key.channel(); <span class="comment">// 返回该SelectionKey对应的channel。</span></span><br><span class="line">key.selector(); <span class="comment">// 返回该SelectionKey对应的Selector。</span></span><br><span class="line">key.interestOps(); <span class="comment">//返回代表需要Selector监控的IO操作的bit mask</span></span><br><span class="line">key.readyOps(); <span class="comment">// 返回一个bit mask，代表在相应channel上可以进行的IO操作。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法介绍</strong></p>
<ul>
<li><strong>key.interestOps()</strong></li>
</ul>
<p><strong>描述</strong>：通过这个方法来判断Selector是否对Channel的某种事件感兴趣；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key.readyOps()</strong></li>
</ul>
<p><strong>描述</strong>：readySet 集合时通道已经准备就绪的操作的集合。</p>
<p>Java中定义了以下几个方法来检查这些操作是否就绪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ready集合的方法</span></span><br><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br><span class="line"><span class="comment">//检查这些操作是否就绪的方法</span></span><br><span class="line">selectionKey.isAcceptable();<span class="comment">//等价selectionKey.readyOps()&amp;SelectionKey.OP_ACCEPT</span></span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key.attachment()</strong></li>
</ul>
<p><strong>描述</strong>：可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个特定的通道。</p>
<p>例如，可以附加与通道一起使用的Buffer，或者包含聚集数据的某个对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key.attach(theObject);</span><br><span class="line">Object attachedObj = key.attachment();</span><br></pre></td></tr></table></figure>

<p>还可以在register()方法使用的时候（即Selector注册Channel的时候）附加对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key.channel()和key.selector()</strong></li>
</ul>
<p><strong>描述</strong>：取出SelectionKey关联的Channel和Selector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel channel = key.channel();</span><br><span class="line">Selector selector = key.selector();</span><br></pre></td></tr></table></figure>

<h3 id="三、Selector中的Channel"><a href="#三、Selector中的Channel" class="headerlink" title="三、Selector中的Channel"></a>三、Selector中的Channel</h3><p>选择器维护注册过的通道，这种选择器与通道的注册关系被封装在SelectionKey中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set <span class="title">selectedKeys</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line">    ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Selector维护的三种类型SelectionKey集合</strong></p>
<p><strong>（1）已注册的键的集合（Registered key set）</strong></p>
<p>所有与选择器关联的通道所生成的键的集合称为已注册键的集合。这个集合通过keys()方法返回，并且有可能是空的。</p>
<p><strong>注意：</strong>并不是所有注册过的键都有效。同时已注册键的集合是不可以直接修改的，若这么做的话，将会抛出<code>java.lang.UnsupportedOperationException</code> 异常。</p>
<p><strong>（2）已选择键的集合（Selected key set）</strong></p>
<p>已注册键的集合的子集，这个集合的每个成员都是相关的通道被选择器判断为已经准备好的并且包含于键的interest集合中的操作。这个集合通过selectedKeys()方法返回（有可能是空的）。</p>
<p><strong>注意</strong>：这些键可以直接从这个集合中移除，但是不能添加。若这么做的话将会抛出<code>java.lang.UnsupportedOperationException</code>异常。</p>
<p><strong>（3）已取消键的集合（Cancelled key set）</strong></p>
<p>已注册键的集合的子集，这个集合包含了cancel()方法被调用过的键（这个键已经被无效化），但他们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</p>
<p><strong>注意</strong>：当键被取消（可以通过isValid()方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用select()方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将会被清理掉，并且相应的注销也将会完成。通道会被注销，新的SelectionKey将被返回。当通道关闭时，所有相关的键会自动取消（一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相应的键将立即被无效化（取消），一旦键被无效化，调用它的与之相关的方法就将抛出CancelledKeyException 异常。</p>
<h3 id="四、select-方法"><a href="#四、select-方法" class="headerlink" title="四、select()方法"></a>四、select()方法</h3><p>在刚初始化的Selector对象中，上面讲述的三个集合都是空的。通过Selector的select()方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的事件）。比如你对读就绪的通道感兴趣，那么select()方法就会返回读事件已经就绪的那些通道。</p>
<p><strong>下面是Selector重载的几个select()方法：</strong></p>
<ul>
<li>**int select()**：阻塞到至少有一个通道在你注册的事件上就绪了；</li>
<li>**int select(long timeout)**：和select()一样，但最长阻塞时间为timeout毫秒；</li>
<li>**int selectNow()**：非阻塞，执行就绪检查过程，但不阻塞，如果当前没有通道就绪，立刻返回0；</li>
</ul>
<p>select()方法返回的int值表示有多少通道已经就绪，是自上次调用select()方法后有多少通道变成就绪状态。</p>
<p>之前在调用select()时进入就绪的通道不会在本次调用中被计入，而在前一次select()调用进入就绪但现在已经不在就绪状态的通道也不会被计入。</p>
<p>例如：首次调用select()方法，如果有一个通道变成了就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的Channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用了select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键的集合。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意keyIterator.remove()每次迭代结束时的调用。在Selector删除SelectionKey作为自己选择的关键实例，当你完成处理后，你必须这样做。这样的话才能在通道下一次变为“就绪”时，Selector将再次将其添加到所选的键集合。</p>
<h3 id="五、停止选择"><a href="#五、停止选择" class="headerlink" title="五、停止选择"></a>五、停止选择</h3><p>选择器执行选择的过程，系统底层会一次询问每个通道是否就绪，这个过程可能会造成调用线程进入阻塞状态，那么我们有以下两种方式来唤醒在Select()方法中阻塞的线程。</p>
<p>（<strong>1）wakeup()方法</strong>：一个线程调用select()方法的那个对象上调用Selector.wakeup()方法。阻塞在select()方法上的线程会立马返回。如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<p><strong>（2）close()方法</strong>：该方法使得任何一个在选择操作中阻塞的线程都被唤醒，用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭<em>。</em></p>
<h2 id="Selector处理accept和read事件"><a href="#Selector处理accept和read事件" class="headerlink" title="Selector处理accept和read事件"></a>Selector处理accept和read事件</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><ul>
<li><strong>多路复用</strong></li>
</ul>
<p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一、处理accept事件"><a href="#一、处理accept事件" class="headerlink" title="一、处理accept事件"></a>一、处理accept事件</h3><ul>
<li><strong>服务器端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Accept事件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Selector,可以管理多个channel</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立channel和selector之间的联系(注册)</span></span><br><span class="line">        <span class="comment">//SelectionKey:事件发生后通过这个可以获取到相应事件，以及对应事件发生的channel</span></span><br><span class="line">        SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//表名这个key只关注accept事件</span></span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.debug(<span class="string">&quot;register key:&#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3. selector.select()方法，没有事件就阻塞，有事件发送就恢复运行继续向下处理</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.处理事件，selectionKeys内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//注意，如果事件不调用accept进行处理，那么不会阻塞，因为事件没被处理，就不能阻塞</span></span><br><span class="line">                <span class="comment">//也就是说事件要么处理要么取消，不能不管</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key:&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//拿到触发事件的channel</span></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行</strong></li>
</ul>
<p>（1）启动服务端程序</p>
<p>（2）通过Debug模式启动客户端程序</p>
<p>（3）通过Debug模式再启动一个客户端程序</p>
<ul>
<li>客户端启动项，选择【Edit Configurations】</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3147726147.jpg" alt="13.Selector处理accept和read事件01.jpg"></p>
<ul>
<li>选择【Allow parallel run】，再点击【OK】</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/89113966.jpg" alt="13.Selector处理accept和read事件02.jpg"></p>
<ul>
<li>再通过Debug模式启动一个客户端</li>
<li><strong>服务端程序输出结果</strong></li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">05</span>:<span class="number">25.304</span> [main] DEBUG com.lilinchao.nio.accept.AcceptServer - register key:sun.nio.ch.SelectionKeyImpl@3b764bce</span><br><span class="line"><span class="number">17</span>:<span class="number">05</span>:<span class="number">38.141</span> [main] DEBUG com.lilinchao.nio.accept.AcceptServer - key:sun.nio.ch.SelectionKeyImpl@3b764bce</span><br><span class="line"><span class="number">17</span>:<span class="number">05</span>:<span class="number">38.142</span> [main] DEBUG com.lilinchao.nio.accept.AcceptServer - java.nio.channels.SocketChannel[connected <span class="keyword">local</span>=<span class="regexp">/127.0.0.1:8080 remote=/</span><span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">51904</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">05</span>:<span class="number">55.911</span> [main] DEBUG com.lilinchao.nio.accept.AcceptServer - key:sun.nio.ch.SelectionKeyImpl@3b764bce</span><br><span class="line"><span class="number">17</span>:<span class="number">05</span>:<span class="number">55.912</span> [main] DEBUG com.lilinchao.nio.accept.AcceptServer - java.nio.channels.SocketChannel[connected <span class="keyword">local</span>=<span class="regexp">/127.0.0.1:8080 remote=/</span><span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">51919</span>]</span><br></pre></td></tr></table></figure>

<p>从打印结果可以看出有两个客户端向服务端发送了连接请求。</p>
<h4 id="问题：事件发生后能否不处理？"><a href="#问题：事件发生后能否不处理？" class="headerlink" title="问题：事件发生后能否不处理？"></a>问题：事件发生后能否不处理？</h4><blockquote>
<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>
</blockquote>
<h3 id="二、处理read事件"><a href="#二、处理read事件" class="headerlink" title="二、处理read事件"></a>二、处理read事件</h3><ul>
<li><strong>服务端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.util.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Read事件 服务端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建selector,管理多个channel</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 建立channel和selector之间的联系（注册）</span></span><br><span class="line">        SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.debug(<span class="string">&quot;register key:&#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3. selector.select()方法，没有事件就阻塞，有了事件发送了就恢复运行继续向下处理</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 处理事件,selectionKeys拿到所有发生的可读可写的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//多个key的时候，accept和read方法都会触发事件，所以要区分事件类型</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//处理key的时候要从selectKeys中删除，否则会报错</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                log.debug(<span class="string">&quot;key:&#123;&#125;&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//拿到触发事件的channel</span></span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                    SocketChannel sc = channel.accept();</span><br><span class="line">                    <span class="comment">//设置为非阻塞</span></span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//scKey管sc的channel</span></span><br><span class="line">                    SelectionKey scKey = sc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//scKey关注读事件,也就是说客户端的通道关注可读事件</span></span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//客户端关闭之后也会引发read事件，这时需要从key中remove掉，否则拿不到channel，报错</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                        <span class="comment">//客户端正常断开，read返回值是-1</span></span><br><span class="line">                        <span class="keyword">int</span> read = channel.read(buffer1);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//正常断开</span></span><br><span class="line">                            key.channel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer1.flip();</span><br><span class="line">                        debugAll(buffer1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();<span class="comment">//客户端断开，需要将key取消（从selector的key集合中真正删除）</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lilinchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Read事件 客户端</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        SocketAddress localAddress = sc.getLocalAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行</strong></li>
</ul>
<p>（1）启动服务端程序</p>
<p>（2）Debug启动客户端程序</p>
<ul>
<li>选择【Evalute Expression】</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3551388388.jpg" alt="13.Selector处理accept和read事件03.jpg"></p>
<ul>
<li>输入如下内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;hello!&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/4223533605.jpg" alt="13.Selector处理accept和read事件04.jpg"></p>
<ul>
<li>点击【Evaluate】提交</li>
<li><strong>服务端输出结果</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">20</span>:<span class="number">50.713</span> [main] DEBUG com.lilinchao.nio.read.ReadServer - register key:sun.nio.ch.SelectionKeyImpl@3b764bce</span><br><span class="line"><span class="number">17</span>:<span class="number">21</span>:<span class="number">11.373</span> [main] DEBUG com.lilinchao.nio.read.ReadServer - key:sun.nio.ch.SelectionKeyImpl@3b764bce</span><br><span class="line"><span class="number">17</span>:<span class="number">21</span>:<span class="number">11.374</span> [main] DEBUG com.lilinchao.nio.read.ReadServer - java.nio.channels.SocketChannel[connected local=/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> remote=/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52466</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">48.603</span> [main] DEBUG com.lilinchao.nio.read.ReadServer - key:sun.nio.ch.SelectionKeyImpl@368102c8</span><br><span class="line"><span class="number">17</span>:<span class="number">23</span>:<span class="number">48.653</span> [main] DEBUG io.netty.util.internal.logging.InternalLoggerFactory - Using SLF4J as the <span class="keyword">default</span> logging framework</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">0</span>], limit: [<span class="number">6</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">68</span> <span class="number">65</span> 6c 6c <span class="number">6f</span> <span class="number">21</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |hello!..........|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>服务端监听到客户端的连接，并读取打印客户端发送过来的数据。</p>
<h4 id="问题：为何要-iter-remove"><a href="#问题：为何要-iter-remove" class="headerlink" title="问题：为何要 iter.remove()"></a>问题：为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey</li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h4 id="问题：cancel-的作用"><a href="#问题：cancel-的作用" class="headerlink" title="问题：cancel 的作用"></a>问题：cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
</blockquote>
<h2 id="NIO消息边界问题处理"><a href="#NIO消息边界问题处理" class="headerlink" title="NIO消息边界问题处理"></a>NIO消息边界问题处理</h2><h3 id="一、消息边界问题的产生"><a href="#一、消息边界问题的产生" class="headerlink" title="一、消息边界问题的产生"></a>一、消息边界问题的产生</h3><h4 id="1-1-服务端代码"><a href="#1-1-服务端代码" class="headerlink" title="1.1 服务端代码"></a>1.1 服务端代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 消息边界问题  服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建selector,管理多个channel</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 建立channel和selector之间的联系（注册）</span></span><br><span class="line">        SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3. selector.select()方法，没有事件就阻塞，有了事件发送了就恢复运行继续向下处理</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 处理事件,selectionKeys拿到所有发生的可读可写的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//多个key的时候，accept和read方法都会触发事件，所以要区分事件类型</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//处理key的时候要从selectKeys中删除，否则会报错</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//5.区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//拿到触发事件的channel</span></span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                    SocketChannel sc = channel.accept();</span><br><span class="line">                    <span class="comment">//设置为非阻塞</span></span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//scKey管sc的channel</span></span><br><span class="line">                    SelectionKey scKey = sc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//scKey关注读事件,也就是说客户端的通道关注可读事件</span></span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//客户端关闭之后也会引发read事件，这时需要从key中remove掉，否则拿不到channel，报错</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                        <span class="comment">//将缓冲区大小设置为4</span></span><br><span class="line">                        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">                        <span class="comment">//客户端正常断开，read返回值是-1</span></span><br><span class="line">                        <span class="keyword">int</span> read = channel.read(buffer1);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//正常断开</span></span><br><span class="line">                            key.channel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer1.flip();</span><br><span class="line">                        System.out.println(Charset.defaultCharset().decode(buffer1));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();<span class="comment">//客户端断开，需要将key取消（从selector的key集合中真正删除）</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-客户端代码"><a href="#1-2-客户端代码" class="headerlink" title="1.2 客户端代码"></a>1.2 客户端代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        SocketAddress localAddress = sc.getLocalAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行程序</strong></p>
<p>（1）运行服务端代码</p>
<p>（2）通过Debug模式运行客户端代码</p>
<p>（3）通过客户端向服务端发送如下请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;中国&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>服务端输出结果</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2258012529.jpg" alt="14.NIO消息边界问题处理01.jpg"></p>
<p>从输出结果可以看到，<strong>国</strong>字出现了乱码。</p>
<p><strong>问题分析</strong></p>
<p>因为在服务端代码中设置的接收客户端数据的缓冲区大小是4个字节，在UTF-8编码中，一个汉字占三个字节，也就是服务端在接收客户端发送到的消息时，只接收到了中字的三个字节和国字的第一个字节就进行了打印输出，导致国字出现了半包问题，产生了乱码。</p>
<h3 id="二、消息边界问题分析"><a href="#二、消息边界问题分析" class="headerlink" title="二、消息边界问题分析"></a>二、消息边界问题分析</h3><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/720319548.png" alt="14.NIO消息边界问题处理02.png"></p>
<p><strong>分析</strong></p>
<ul>
<li><strong>时刻1</strong>：ByteBufeer较小，但是发送过来的消息比较大，一次处理不完；</li>
<li><strong>时刻2</strong>：ByteBufeer较大，消息比较小。会出现半包现象</li>
<li><strong>时刻3</strong>：ButeBuffer可以一次性接收客户端发送过来的多条消息。此时会出现黏包现象</li>
</ul>
<p><strong>解决思路</strong></p>
<p>（1）<strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p>
<p>（2）<strong>按分隔符拆分</strong>，缺点是效率低，需要一个一个字符去匹配分隔符</p>
<p>（3）<strong>TLV 格式，即 Type 类型、Length 长度、Value 数据</strong>（也就是在消息开头<strong>用一些空间存放后面数据的长度</strong>），如HTTP请求头中的Content-Type与<strong>Content-Length</strong>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3010171246.png" alt="14.NIO消息边界问题处理03.png"></p>
<h3 id="三、解决消息边界问题"><a href="#三、解决消息边界问题" class="headerlink" title="三、解决消息边界问题"></a>三、解决消息边界问题</h3><p>本示例将按照第二种方式，<strong>按分隔符拆分</strong>来解决消息边界问题。</p>
<h4 id="3-1-附件与扩容"><a href="#3-1-附件与扩容" class="headerlink" title="3.1 附件与扩容"></a>3.1 附件与扩容</h4><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的<code>SelectionKey</code>绑定，可以从<code>SelectionKey</code>获取到对应通道的附件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br></pre></td></tr></table></figure>

<p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br></pre></td></tr></table></figure>

<p>需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择器中，同时设置附件</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 添加通道对应的Buffer附件</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_READ, buffer);</span><br></pre></td></tr></table></figure>

<p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果缓冲区太小，就进行扩容</span></span><br><span class="line"><span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">    ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity()*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 将旧buffer中的内容放入新的buffer中</span></span><br><span class="line">    newBuffer.put(buffer);</span><br><span class="line">    <span class="comment">// 将新buffer作为附件放到key中</span></span><br><span class="line">    key.attach(newBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-完整代码"><a href="#3-2-完整代码" class="headerlink" title="3.2 完整代码"></a>3.2 完整代码</h4><ul>
<li><strong>需求</strong></li>
</ul>
<blockquote>
<p>将服务端缓冲区大小设置成16，客户端向服务端发送数据21个字节的数据<code>0123456789abcdef3333\n</code></p>
<ul>
<li><code>\n</code>为消息的分隔符，占一个字节大小</li>
</ul>
</blockquote>
<ul>
<li><strong>过程分析</strong></li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1694622757.jpg" alt="14.NIO消息边界问题处理04.jpg"></p>
<ul>
<li><strong>服务端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBorderServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">        <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">        SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">            <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">                iter.remove();</span><br><span class="line">                log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">                <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel sc = channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                    <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                    SelectionKey scKey = sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                        <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            split(buffer);</span><br><span class="line">                            <span class="comment">// 需要扩容</span></span><br><span class="line">                            <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                                key.attach(newBuffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="comment">// 找到一条完整消息</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBorderClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>输出结果</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">04</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> sscKey:sun.nio.ch.SelectionKeyImpl<span class="variable">@7dc36524</span></span><br><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">32</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> key: sun.nio.ch.SelectionKeyImpl<span class="variable">@7dc36524</span></span><br><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">32</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> java.nio.channels.SocketChannel[connected <span class="keyword">local</span><span class="operator">=</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> remote<span class="operator">=</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">51861</span>]</span><br><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">32</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> scKey:sun.nio.ch.SelectionKeyImpl<span class="variable">@27f674d</span></span><br><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">32</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> key: sun.nio.ch.SelectionKeyImpl<span class="variable">@27f674d</span></span><br><span class="line"><span class="number">11</span>:<span class="number">50</span>:<span class="number">32</span> [DEBUG] [main] c.l.n.b.MessageBorderServer <span class="operator">-</span> key: sun.nio.ch.SelectionKeyImpl<span class="variable">@27f674d</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [<span class="number">21</span>], limit: [<span class="number">21</span>]</span><br><span class="line">         <span class="operator">+</span><span class="comment">-------------------------------------------------+</span></span><br><span class="line">         <span class="operator">|</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line"><span class="operator">|</span><span class="number">00000000</span><span class="operator">|</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">66</span> <span class="operator">|</span><span class="number">0123456789</span>abcdef<span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="number">00000010</span><span class="operator">|</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">33</span> <span class="number">0</span>a                                  <span class="operator">|</span><span class="number">3333.</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------------------------------------------+----------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="四、bytebuffer大小分配"><a href="#四、bytebuffer大小分配" class="headerlink" title="四、bytebuffer大小分配"></a>四、bytebuffer大小分配</h3><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
<h2 id="NIO-Selector之处理write事件"><a href="#NIO-Selector之处理write事件" class="headerlink" title="NIO Selector之处理write事件"></a>NIO Selector之处理write事件</h2><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li><p>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</p>
</li>
<li><p>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略</p>
<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，会每次可写均会触发 write 事件</li>
</ul>
</li>
<li><p><strong>服务端代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 可写事件  服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey sckey = sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1.向客户端发送内容</span></span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30000000</span>;i++)&#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.write表示实际写了多少字节</span></span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">//3.如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// read 1 write 4</span></span><br><span class="line">                        <span class="comment">//在原有关注事件的基础上，多关注一个写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">//把buffer作为附件加入sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务端运行结果</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">实际写入字节:5242840</span></span><br><span class="line"><span class="section">实际写入字节:3014633</span></span><br><span class="line"><span class="section">实际写入字节:4063201</span></span><br><span class="line"><span class="section">实际写入字节:4718556</span></span><br><span class="line"><span class="section">实际写入字节:2490349</span></span><br><span class="line"><span class="section">实际写入字节:2621420</span></span><br><span class="line"><span class="section">实际写入字节:2621420</span></span><br><span class="line"><span class="section">实际写入字节:2621420</span></span><br><span class="line"><span class="section">实际写入字节:2606161</span></span><br></pre></td></tr></table></figure>

<h2 id="NIO之多线程优化"><a href="#NIO之多线程优化" class="headerlink" title="NIO之多线程优化"></a>NIO之多线程优化</h2><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>之前说到的服务端程序都是在一个线程上进行的，这个线程不仅负责连接客户端发来的请求，同时还要处理读写事件，这样效率还是不够高。如今电脑都是多核处理器，这意味着可以同时进行多个线程，所以服务端应该充分利用这一点。</p>
<h3 id="一、概述-3"><a href="#一、概述-3" class="headerlink" title="一、概述"></a>一、概述</h3><p>服务端线程可以建立多个线程，将这些线程分成两组：</p>
<ul>
<li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li>
<li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li>
</ul>
<p><strong>关系图</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1394560525.jpg" alt="16.NIO之多线程优化01.jpg"></p>
<p><strong>说明</strong></p>
<ul>
<li>Boss线程只负责Accept事件，Worker线程负责客户端与服务端之间的读写问题，他们都各自维护一个Selector负责监听通道的事件。</li>
<li>当Boss线程检测到有客户端的连接请求，就会把这个连接返回的<code>SocketChannel</code>注册到某一个Worker线程上。</li>
<li>当有读写事件发生时，其中一个Worker线程就会检测到事件，就会在该线程中进行处理，这样的设计做到了功能在线程上的分离。</li>
</ul>
<h3 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h3><ul>
<li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程；</p>
</li>
<li><p><strong>Boss线程</strong>执行的操作</p>
<ul>
<li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识index去判断将任务分配给哪个Worker</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定数量的Worker</span></span><br><span class="line">Worker[] workers = <span class="keyword">new</span> Worker[Runtime.getRuntime().availableProcessors()];</span><br><span class="line"><span class="comment">// 用于负载均衡的原子整数</span></span><br><span class="line">AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 负载均衡，轮询分配Worker</span></span><br><span class="line">workers[index.getAndIncrement()% workers.length].register(socket);</span><br></pre></td></tr></table></figure></li>
<li><p><code>register(SocketChannel socket)</code>方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让<code>SocketChannel</code>的注册任务被Worker线程执行。添加任务后需要调用<code>selector.wakeup()</code>来唤醒被阻塞的Selector</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> SocketChannel socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只启动一次</span></span><br><span class="line">    <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">       <span class="comment">// 初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向同步队列中添加SocketChannel的注册事件</span></span><br><span class="line">    <span class="comment">// 在Worker线程中执行注册事件</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 唤醒被阻塞的Selector</span></span><br><span class="line">    selector.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Worker线程执行</strong>的操作</p>
<ul>
<li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li>
</ul>
</li>
</ul>
<h3 id="三、代码实现-1"><a href="#三、代码实现-1" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><ul>
<li><strong>服务端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.lilinchao.nio.bytebuffer_2.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/4</span></span><br><span class="line"><span class="comment"> * Description 多线程优化  -- 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 负责轮询Accept事件的Selector</span></span><br><span class="line">        Selector boss = Selector.open();</span><br><span class="line">        SelectionKey bossKey = ssc.register(boss, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建固定数量的worker = core 数</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> Worker[Runtime.getRuntime().availableProcessors()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;workers.length;i++)&#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于负载均衡的原子整数</span></span><br><span class="line">        AtomicInteger index = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;connected:&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 2. 关联 selector (静态内部类可以访问到selector)</span></span><br><span class="line">                    log.debug(<span class="string">&quot;before register:&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 负载均衡，轮询分配Worker</span></span><br><span class="line">                    workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                    log.debug(<span class="string">&quot;after register:&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>; <span class="comment">//还未初始化</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化线程和Selector</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//只启动一次</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.start)&#123;</span><br><span class="line">                <span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>,name);</span><br><span class="line">                <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">                <span class="keyword">this</span>.thread.start();</span><br><span class="line">                <span class="keyword">this</span>.start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向队列添加任务,但这个任务并没有立刻执行</span></span><br><span class="line">            queue.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector,SelectionKey.OP_READ,<span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">//唤醒select方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();  <span class="comment">//阻塞</span></span><br><span class="line">                    <span class="comment">// 通过同步队列获得任务并运行</span></span><br><span class="line">                    Runnable task = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(task != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        task.run(); <span class="comment">//获得任务,执行注册</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="comment">// Worker只负责Read事件</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            log.debug(<span class="string">&quot;read...&#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>客户端代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lilinchao</span></span><br><span class="line"><span class="comment"> * Date 2022/6/3</span></span><br><span class="line"><span class="comment"> * Description 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>运行结果</strong></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">03</span>:<span class="number">57</span> [DEBUG] [boss] c.l.n.t.MultiThreadServer - connected:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52622</span></span><br><span class="line"><span class="number">13</span>:<span class="number">03</span>:<span class="number">57</span> [DEBUG] [boss] c.l.n.t.MultiThreadServer - before register:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52622</span></span><br><span class="line"><span class="number">13</span>:<span class="number">03</span>:<span class="number">57</span> [DEBUG] [boss] c.l.n.t.MultiThreadServer - after register:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52622</span></span><br><span class="line"><span class="number">13</span>:<span class="number">03</span>:<span class="number">57</span> [DEBUG] [worker<span class="number">-0</span>] c.l.n.t.MultiThreadServer - <span class="built_in">read</span>.../<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52622</span></span><br><span class="line">+<span class="comment">--------+-------------------- all ------------------------+----------------+</span></span><br><span class="line">position: [<span class="number">0</span>], limit: [<span class="number">16</span>]</span><br><span class="line">         +<span class="comment">-------------------------------------------------+</span></span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br><span class="line">|<span class="number">00000000</span>| <span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">66</span> |<span class="number">0123456789</span>abcdef|</span><br><span class="line">+<span class="comment">--------+-------------------------------------------------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>在运行时，可以同时运行多个客户端程序，查看服务端的输出效果。</p>
<h4 id="问题：如何拿到-cpu-个数"><a href="#问题：如何拿到-cpu-个数" class="headerlink" title="问题：如何拿到 cpu 个数"></a>问题：如何拿到 cpu 个数</h4><blockquote>
<ul>
<li><code>Runtime.getRuntime().availableProcessors()</code> 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>
</ul>
</blockquote>
<h2 id="NIO之IO模型"><a href="#NIO之IO模型" class="headerlink" title="NIO之IO模型"></a>NIO之IO模型</h2><h3 id="一、IO流程"><a href="#一、IO流程" class="headerlink" title="一、IO流程"></a>一、IO流程</h3><p>就是对于 Linux 系统， I/O 操作不是一步完成的。此处的 I/O 操作是一个通用型的概念，对于 socket 通信，也可以看作一个 I/O 操作过程，只不过操作的是网络对象。</p>
<p><strong>I/O 操作一般分为两个部分：</strong></p>
<ul>
<li>应用程序发起 I/O 操作请求，等待数据，或者将要操作的数据拷贝到系统内核中（比如 socket）。</li>
<li>系统内核进行 I/O 操作（一般是内核将数据拷贝到用户进程中）。</li>
</ul>
<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>首先明确一点：<strong>阻塞和非阻塞发生在请求处，关注的是程序在等待调用结果时的状态</strong>。</p>
<p>通过上面的概念可以很容易的理解以下结论：</p>
<ul>
<li>阻塞调用是指<strong>调用结果返回之前，当前进程（线程）会被挂起</strong>。调用进程（线程）阻塞在 I/O 操作请求处，直到 I/O 操作请求完成，数据到来，最重要的是用户进程的函数在请求的过程中不会返回。</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前进程（线程），<strong>进程（线程）</strong>可以去干别的事情。一般使用轮询的方式来查询 I/O 操作数据是否准确好了。</li>
</ul>
<p>理解上面概念的一个要点是<strong>请求的结果是否立即返回</strong>，同时需要注意的是，结果立即返回，不代表 I/O 操作完成，阻塞和非阻塞只关注请求是否立即获得结果。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同样需要明确一点：<strong>同步和异步关注的是消息通信机制，具体来说就是调用者是否等待调用结果的返回，对于 I/O 操作而言，就是应用程序是否等待 I/O 操作完成</strong>。</p>
<p><strong>注意：此处的 I/O 操作一般是指上文中 I/O 操作中的两部分的第二部分。</strong></p>
<p>同步和异步其实就是指 I/O 操作的第二部分，也就是进行具体 I/O 操作过程中，用户进程是否等待 I/O 操作结果返回。</p>
<ul>
<li>阻塞和非阻塞是指进程访问的数据如果尚未就绪，进程是否需要等待，简单说这相当于函数内部的实现区别，也就是未就绪时是直接返回还是等待就绪。</li>
<li>同步和异步是指访问数据的机制，同步一般指主动请求并等待 I/O 操作完毕的方式，当数据就绪后在读写的时候必须等待，异步则指主动请求数据后便可以继续处理其它任务，随后等待 I/O，操作完毕的通知，这可以使进程在数据读写时也不阻塞。</li>
</ul>
<h3 id="二、IO模型"><a href="#二、IO模型" class="headerlink" title="二、IO模型"></a>二、IO模型</h3><h4 id="2-1-阻塞IO"><a href="#2-1-阻塞IO" class="headerlink" title="2.1 阻塞IO"></a>2.1 阻塞IO</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2354597183.png" alt="17.NIO之IO模型01.png"></p>
<p> 用户线程发起一次read，由用户空间切换到内核空间，但是可能数据还没发送过来，该read方法就会阻塞住，等到复制(网卡-&gt;内存)完数据后，再从内核切换到用户线程。这里的阻塞即用户线程被阻塞。</p>
<p><strong>从上面可以看到线程在两个阶段发生了阻塞：</strong></p>
<ul>
<li>CPU把数据从磁盘读到内核缓冲区。</li>
<li>CPU把数据从内核缓冲区拷贝到用户缓冲区。</li>
</ul>
<h4 id="2-2-非阻塞IO"><a href="#2-2-非阻塞IO" class="headerlink" title="2.2 非阻塞IO"></a>2.2 非阻塞IO</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2255231099.png" alt="17.NIO之IO模型02.png"></p>
<p> 非阻塞IO发出read请求后发现数据没准备好，会继续往下执行，此时应用程序会不断轮询polling内核询问数据是否准备好，当数据没有准备好时，内核立即返回EWOULDBLOCK错误。直到数据被拷贝到应用程序缓冲区，read请求才获取到结果。</p>
<p>需要注意的是最后一次 read 调用获取数据的过程，是一个同步的过程，是需要等待的过程。</p>
<p>这里的同步指的是<strong>内核态的数据拷贝到用户程序的缓存区</strong>这个过程。</p>
<p>这种方法并没有特别好的地方，它会牵扯到多次用户空间到内核空间的转换，切换太频繁会影响性能。</p>
<h4 id="2-3-IO多路复用"><a href="#2-3-IO多路复用" class="headerlink" title="2.3 IO多路复用"></a>2.3 IO多路复用</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2513520808.png" alt="17.NIO之IO模型03.png"></p>
<p> IO多路复用的原文叫 <code>I/O multiplexing</code>，这里的 <code>multiplexing</code> 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流。</p>
<p> 目的是尽量多的提高服务器的吞吐能力。实现一个线程监控多个IO请求，哪个IO有请求就把数据从内核拷贝到进程缓冲区，拷贝期间是阻塞的。</p>
<p><strong>多路复用与阻塞IO的区别</strong></p>
<ul>
<li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件；</li>
<li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行。</li>
</ul>
<h4 id="2-4-异步IO"><a href="#2-4-异步IO" class="headerlink" title="2.4 异步IO"></a>2.4 异步IO</h4><p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2947963201.png" alt="17.NIO之IO模型04.png"></p>
<p> 上面的提到过的操作都不是真正的异步，因为两个阶段总要等待会儿，而真正的异步 I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。</p>
<p> 很庆幸，Linux给我们准备了aio_read跟aio_write函数实现真实的异步，当用户发起aio_read请求后就会自动返回。内核会自动将数据从内核缓冲区拷贝到用户进程空间，应用进程啥都不用管。</p>
<h3 id="三、同步和异步详解"><a href="#三、同步和异步详解" class="headerlink" title="三、同步和异步详解"></a>三、同步和异步详解</h3><h4 id="3-1-同步"><a href="#3-1-同步" class="headerlink" title="3.1 同步"></a>3.1 同步</h4><p>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程完成，这里又分为同步阻塞跟同步非阻塞两种。</p>
<ul>
<li><strong>同步阻塞</strong>：此时一个线程维护一个连接，该线程完成数据从读写到处理全部过程，数据读写时线程是被阻塞的。</li>
<li><strong>同步非阻塞</strong>：非阻塞的意思是用户线程发出读请求后，读请求不会阻塞当前用户线程，不过用户线程还是要不断的去主动判断数据是否准备OK了。此时还是会阻塞等待内核复制数据到用户进程。他与同步BIO区别是使用一个连接全程等待</li>
</ul>
<p>以<strong>同步非阻塞</strong>为例，如下可看到，在将数据从内核拷贝到用户空间这一过程，是由用户线程阻塞完成的。</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2312162995.png" alt="17.NIO之IO模型05.png"></p>
<h4 id="3-2-异步"><a href="#3-2-异步" class="headerlink" title="3.2 异步"></a>3.2 异步</h4><p> 对于异步来说，用户进行读或者写后，将立刻返回，由内核去完成数据读取以及拷贝工作，完成后通知用户，并执行回调函数(用户提供的callback)，此时数据已从内核拷贝到用户空间，用户线程只需要对数据进行处理即可，不需要关注读写，用户不需要等待内核对数据的复制操作，用户在得到通知时数据已经被复制到用户空间。</p>
<p><strong>以如下的真实异步非阻塞为例：</strong></p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2624826873.png" alt="17.NIO之IO模型06.png"></p>
<p>可发现，用户在调用之后会立即返回，由内核完成数据的拷贝工作，并通知用户线程，进行回调。</p>
<h4 id="3-3-同步跟异步对比"><a href="#3-3-同步跟异步对比" class="headerlink" title="3.3 同步跟异步对比"></a>3.3 同步跟异步对比</h4><p> 同步关注的消息通信机制<code>synchronous communication</code>，在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。</p>
<p> 异步关注消息通信机制<code>asynchronous communication</code>，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<h2 id="NIO之零拷贝"><a href="#NIO之零拷贝" class="headerlink" title="NIO之零拷贝"></a>NIO之零拷贝</h2><h3 id="一、传统IO问题"><a href="#一、传统IO问题" class="headerlink" title="一、传统IO问题"></a>一、传统IO问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>

<p>内部工作流程是这样的：</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/3007087169.png" alt="18.NIO之零拷贝01.png"></p>
<ol>
<li>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu;</li>
<li>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA;</li>
<li>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝;</li>
<li>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu。</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h3 id="二、NIO-优化"><a href="#二、NIO-优化" class="headerlink" title="二、NIO 优化"></a>二、NIO 优化</h3><h4 id="2-1-优化一"><a href="#2-1-优化一" class="headerlink" title="2.1 优化一"></a>2.1 优化一</h4><p>通过 DirectByteBuf</p>
<ul>
<li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/1662871847.png" alt="18.NIO之零拷贝02.png"></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<h4 id="2-2-优化二"><a href="#2-2-优化二" class="headerlink" title="2.2 优化二"></a>2.2 优化二</h4><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2634306231.png" alt="18.NIO之零拷贝03.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<h4 id="2-3-优化三"><a href="#2-3-优化三" class="headerlink" title="2.3 优化三"></a>2.3 优化三</h4><p>进一步优化（linux 2.4）</p>
<p><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/2187344631.png" alt="18.NIO之零拷贝04.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小肥龙吃大冰淇淋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lvxueyang.vip/post/429dd195.html">http://lvxueyang.vip/post/429dd195.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lvxueyang.vip" target="_blank">小肥龙吃大冰淇淋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/mm_facetoface_collect_qrcode_1628169825807.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/LVXUEYANGTiger/blog@main/1628169797.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/8eebb21.html"><img class="prev-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx架构</div></div></a></div><div class="next-post pull-right"><a href="/post/7d584b4.html"><img class="next-cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Neo4j高级应用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/7f740e52.html" title="Netty入门-第三话(转载)"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">Netty入门-第三话(转载)</div></div></a></div><div><a href="/post/878bcc09.html" title="Netty入门-第二话(转载)"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">Netty入门-第二话(转载)</div></div></a></div><div><a href="/post/e2dd34c3.html" title="Netty入门-第一话(转载)"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/blog/bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">Netty入门-第一话(转载)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">NIO简单介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-NIO%E4%B8%8EBIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">二、Java NIO与BIO的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、NIO三大核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 Buffer(缓冲区)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 Channel（通道）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Selector%EF%BC%88%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 Selector（选择器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BABuffer"><span class="toc-number">1.5.</span> <span class="toc-text">四、缓冲区Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">Buffer类及其子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.2.</span> <span class="toc-text">Buffer中的重要概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8Bbytebuffer%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">NIO之bytebuffer基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87"><span class="toc-number">2.2.</span> <span class="toc-text">一、准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ByteBuffer-%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">二、ByteBuffer 使用分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">三、代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8Bbytebuffer%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">NIO之bytebuffer内部结构和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81bytebuffer%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">一、bytebuffer内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 属性介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ByteBuffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">二、ByteBuffer常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#put"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">put()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flip"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">flip()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rewind"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">rewind()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clean"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">clean()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mark-reset"><span class="toc-number">3.2.0.6.</span> <span class="toc-text">mark()&#x2F;reset()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compact"><span class="toc-number">3.2.0.7.</span> <span class="toc-text">compact()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8Bbytebuffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">NIO之bytebuffer常见方法演示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.</span> <span class="toc-text">1. 分配内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%91buffer%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.</span> <span class="toc-text">2. 向buffer写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8Ebuffer%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.</span> <span class="toc-text">3. 从buffer读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-mark-%E5%92%8C-reset"><span class="toc-number">4.4.</span> <span class="toc-text">4. mark 和 reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%AC"><span class="toc-number">4.5.</span> <span class="toc-text">5. 字符串与 ByteBuffer 互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Scattering-Reads%EF%BC%88%E5%88%86%E6%95%A3%E8%AF%BB%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">6. Scattering Reads（分散读）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Gathering-Writes%EF%BC%88%E9%9B%86%E4%B8%AD%E5%86%99%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">7. Gathering Writes（集中写）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%9A%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">最后：调试工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8Bbytebuffer%E9%BB%8F%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">NIO之bytebuffer黏包和半包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">一、示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%BB%8F%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.2.</span> <span class="toc-text">二、黏包和半包出现原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">三、代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.3.1.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BFileChannel%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">NIO之FileChannel介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">一、概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel-%E5%92%8C-%E6%A0%87%E5%87%86Java-IO%E5%AF%B9%E6%AF%94"><span class="toc-number">6.1.1.</span> <span class="toc-text">FileChannel 和 标准Java IO对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.2.</span> <span class="toc-text">FileChannel的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81FileChannel-%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">二、FileChannel 类结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81FileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.3.</span> <span class="toc-text">三、FileChannel常用方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%80%9A%E9%81%93%E8%8E%B7%E5%8F%96"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1 通道获取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FileChannel-open-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">FileChannel.open()的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-FileInputStream-FileOutputStream-%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">从 FileInputStream &#x2F; FileOutputStream 中获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-RandomAccessFile-%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">6.3.1.3.</span> <span class="toc-text">从 RandomAccessFile 中获取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2 读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%88%B0%E5%8D%95%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">将数据读取到单个缓冲区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">读取到多个缓冲区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3 写入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%8D%95%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E5%85%A5"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">从单个缓冲区写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E5%A4%9A%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%99%E5%85%A5"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">从多个缓冲区写入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%95%B0%E6%8D%AE%E5%88%B7%E5%87%BA"><span class="toc-number">6.3.4.</span> <span class="toc-text">3.4 数据刷出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%85%B3%E9%97%ADFileChannel"><span class="toc-number">6.3.5.</span> <span class="toc-text">3.5 关闭FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.6.</span> <span class="toc-text">3.6 其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#position"><span class="toc-number">6.3.6.1.</span> <span class="toc-text">position()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#size"><span class="toc-number">6.3.6.2.</span> <span class="toc-text">size()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#truncate"><span class="toc-number">6.3.6.3.</span> <span class="toc-text">truncate()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transferTo-%E5%92%8C-transferFrom%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.6.4.</span> <span class="toc-text">transferTo 和 transferFrom方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BFileChannel%E7%BB%83%E4%B9%A0"><span class="toc-number">7.</span> <span class="toc-text">NIO之FileChannel练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BPath%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.</span> <span class="toc-text">NIO之Path介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Path%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">一、Path介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Path%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.2.</span> <span class="toc-text">二、Path方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BAPath%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 创建Path实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 创建绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 创建相对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Path-normalize-%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">2.4 Path.normalize()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BFiles%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.</span> <span class="toc-text">NIO之Files介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="toc-number">9.1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.2.</span> <span class="toc-text">二、常用方法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Files-exits"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1 Files.exits()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Files-createDirectory"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2 Files.createDirectory()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Files-createDirectories"><span class="toc-number">9.2.3.</span> <span class="toc-text">2.3 Files.createDirectories()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Files-copy"><span class="toc-number">9.2.4.</span> <span class="toc-text">2.4 Files.copy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Files-move"><span class="toc-number">9.2.5.</span> <span class="toc-text">2.5 Files.move()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-Files-delete"><span class="toc-number">9.2.6.</span> <span class="toc-text">2.6 Files.delete()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-Files-walkFileTree"><span class="toc-number">9.2.7.</span> <span class="toc-text">2.7 Files.walkFileTree()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BFiles-Demo"><span class="toc-number">10.</span> <span class="toc-text">NIO之Files Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6"><span class="toc-number">10.1.</span> <span class="toc-text">一、遍历目录文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%9F%E8%AE%A1Jar%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">10.2.</span> <span class="toc-text">二、统计Jar的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%A0%E9%99%A4%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">10.3.</span> <span class="toc-text">三、删除多级目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8B%B7%E8%B4%9D%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">10.4.</span> <span class="toc-text">四、拷贝多级目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8B%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">NIO之阻塞模式和非阻塞模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-number">11.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">一、阻塞模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">11.2.2.</span> <span class="toc-text">1.2 代码演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">11.2.3.</span> <span class="toc-text">1.3 结果分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.3.</span> <span class="toc-text">二、非阻塞模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">11.3.1.</span> <span class="toc-text">2.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">11.3.2.</span> <span class="toc-text">2.2 代码演示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Selector%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">NIO之选择器（Selector）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-2"><span class="toc-number">12.1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Selector%EF%BC%88%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">二、Selector（选择器）方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Selector%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">12.2.1.</span> <span class="toc-text">2.1 Selector的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B3%A8%E5%86%8CChannel%E5%88%B0Selector"><span class="toc-number">12.2.2.</span> <span class="toc-text">2.2 注册Channel到Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-SelectionKey"><span class="toc-number">12.2.3.</span> <span class="toc-text">2.3 SelectionKey</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Selector%E4%B8%AD%E7%9A%84Channel"><span class="toc-number">12.3.</span> <span class="toc-text">三、Selector中的Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81select-%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">四、select()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%81%9C%E6%AD%A2%E9%80%89%E6%8B%A9"><span class="toc-number">12.5.</span> <span class="toc-text">五、停止选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector%E5%A4%84%E7%90%86accept%E5%92%8Cread%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">Selector处理accept和read事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-3"><span class="toc-number">13.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%A4%84%E7%90%86accept%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.2.</span> <span class="toc-text">一、处理accept事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">13.2.1.</span> <span class="toc-text">问题：事件发生后能否不处理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%84%E7%90%86read%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.3.</span> <span class="toc-text">二、处理read事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BD%95%E8%A6%81-iter-remove"><span class="toc-number">13.3.1.</span> <span class="toc-text">问题：为何要 iter.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9Acancel-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.3.2.</span> <span class="toc-text">问题：cancel 的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">NIO消息边界问题处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">14.1.</span> <span class="toc-text">一、消息边界问题的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">14.1.1.</span> <span class="toc-text">1.1 服务端代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">14.1.2.</span> <span class="toc-text">1.2 客户端代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">14.2.</span> <span class="toc-text">二、消息边界问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">14.3.</span> <span class="toc-text">三、解决消息边界问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%99%84%E4%BB%B6%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-number">14.3.1.</span> <span class="toc-text">3.1 附件与扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">14.3.2.</span> <span class="toc-text">3.2 完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81bytebuffer%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D"><span class="toc-number">14.4.</span> <span class="toc-text">四、bytebuffer大小分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO-Selector%E4%B9%8B%E5%A4%84%E7%90%86write%E4%BA%8B%E4%BB%B6"><span class="toc-number">15.</span> <span class="toc-text">NIO Selector之处理write事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="toc-number">15.0.1.</span> <span class="toc-text">一次无法写完例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="toc-number">16.</span> <span class="toc-text">NIO之多线程优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-4"><span class="toc-number">16.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-3"><span class="toc-number">16.2.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">16.3.</span> <span class="toc-text">二、实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">16.4.</span> <span class="toc-text">三、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-cpu-%E4%B8%AA%E6%95%B0"><span class="toc-number">16.4.1.</span> <span class="toc-text">问题：如何拿到 cpu 个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8BIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.</span> <span class="toc-text">NIO之IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81IO%E6%B5%81%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">一、IO流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">17.1.1.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">17.1.2.</span> <span class="toc-text">同步和异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">17.2.</span> <span class="toc-text">二、IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%98%BB%E5%A1%9EIO"><span class="toc-number">17.2.1.</span> <span class="toc-text">2.1 阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">17.2.2.</span> <span class="toc-text">2.2 非阻塞IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">17.2.3.</span> <span class="toc-text">2.3 IO多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%BC%82%E6%AD%A5IO"><span class="toc-number">17.2.4.</span> <span class="toc-text">2.4 异步IO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">17.3.</span> <span class="toc-text">三、同步和异步详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%90%8C%E6%AD%A5"><span class="toc-number">17.3.1.</span> <span class="toc-text">3.1 同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BC%82%E6%AD%A5"><span class="toc-number">17.3.2.</span> <span class="toc-text">3.2 异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%90%8C%E6%AD%A5%E8%B7%9F%E5%BC%82%E6%AD%A5%E5%AF%B9%E6%AF%94"><span class="toc-number">17.3.3.</span> <span class="toc-text">3.3 同步跟异步对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">18.</span> <span class="toc-text">NIO之零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%A0%E7%BB%9FIO%E9%97%AE%E9%A2%98"><span class="toc-number">18.1.</span> <span class="toc-text">一、传统IO问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NIO-%E4%BC%98%E5%8C%96"><span class="toc-number">18.2.</span> <span class="toc-text">二、NIO 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BC%98%E5%8C%96%E4%B8%80"><span class="toc-number">18.2.1.</span> <span class="toc-text">2.1 优化一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BC%98%E5%8C%96%E4%BA%8C"><span class="toc-number">18.2.2.</span> <span class="toc-text">2.2 优化二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%BC%98%E5%8C%96%E4%B8%89"><span class="toc-number">18.2.3.</span> <span class="toc-text">2.3 优化三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">18.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小肥龙吃大冰淇淋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'pinglun-9gh2lmcnd8587831',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'pinglun-9gh2lmcnd8587831',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="//code.tidio.co/smwivpnwumemac2wohardi3d3gpud1ag.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>